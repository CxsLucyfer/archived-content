---
title: Скрипты Content Scripts
slug: Mozilla/Add-ons/SDK/Guides/Скрипты_содержимого
tags:
  - Content script
  - Дополнение
translation_of: Archive/Add-ons/Add-on_SDK/Guides/Content_Scripts
---
<article id="wikiArticle">
<p></p><section class="Quick_links" id="Quick_Links">
  <ol>
    <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions"><strong>Browser extensions</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Getting started</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/What_are_WebExtensions">What are extensions?</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Your_first_WebExtension">Your first extension</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Your_second_WebExtension">Your second extension</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Anatomy_of_a_WebExtension">Anatomy of an extension</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Examples">Example extensions</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/What_next_">What next?</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Concepts</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Using_the_JavaScript_APIs">Using the JavaScript APIs</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Content_scripts">Content scripts</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Match_patterns">Match patterns</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Working_with_files">Working with files</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Internationalization">Internationalization</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Security_best_practices">Security best practices</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Content_Security_Policy">Content Security Policy</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Native_messaging">Native messaging</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>User interface</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface">User Interface</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Browser_action">Toolbar button</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Page_actions">Address bar button</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Sidebars">Sidebars</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Context_menu_items">Context menu items</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Options_pages">Options page</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Extension_pages">Extension pages</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Notifications">Notifications</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/Omnibox">Address bar suggestions</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/user_interface/devtools_panels">Developer tools panels</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>How to</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Intercept_HTTP_requests">Intercept HTTP requests</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Modify_a_web_page">Modify a web page</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Safely_inserting_external_content_into_a_page">Insert external content</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Add_a_button_to_the_toolbar">Add a button to the toolbar</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Implement_a_settings_page">Implement a settings page</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Working_with_the_Tabs_API">Work with the Tabs API</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Work_with_the_Bookmarks_API">Work with the Bookmarks API</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Work_with_the_Cookies_API">Work with the Cookies API</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Work_with_contextual_identities">Work with contextual identities</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/onboarding_upboarding_offboarding_best_practices">Onboard, upboard, and offboard users</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Porting</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Firefox_differentiators">Firefox differentiators</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Porting_a_Google_Chrome_extension">Porting a Google Chrome extension</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Porting_a_legacy_Firefox_add-on">Porting a legacy Firefox extension</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Embedded_WebExtensions">Embedded WebExtensions</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Comparison_with_the_Add-on_SDK">Comparison with the Add-on SDK</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Comparison_with_XUL_XPCOM_extensions">Comparison with XUL/XPCOM extensions</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Differences_between_API_implementations">Differences between API implementations</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Chrome_incompatibilities">Chrome incompatibilities</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Differences_between_desktop_and_Android">Differences between desktop and Android</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Firefox workflow</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Development_Tools">Developer tools</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/User_experience_best_practices">User Experience</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Temporary_Installation_in_Firefox">Temporary Installation in Firefox</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Debugging">Debugging</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Testing_persistent_and_restart_features">Testing persistent and restart features</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Developing_WebExtensions_for_Firefox_for_Android">Developing for Firefox for Android</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Getting_started_with_web-ext">Getting started with web-ext</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/web-ext_command_reference">web-ext command reference</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/WebExtensions_and_the_Add-on_ID">Extensions and the Add-on ID</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Request_the_right_permissions">Request the right permissions</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>JavaScript APIs</summary>
        <ol><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Browser_support_for_JavaScript_APIs">Browser support for JavaScript APIs</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/API/cookies">cookies</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/API/tabs">tabs</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/API/windows">windows</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/API/webRequest">webRequest</a></li></ol>
      </details>
    </li>

    <li class="toggle">
      <details>
      <summary>Manifest keys</summary>
      <ol><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/manifest.json/background">background</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/manifest.json/description">description</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/manifest.json/version">version</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/manifest.json/icons">ключ icons</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/manifest.json/manifest_version">ключ manifest_version</a></li><li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/manifest.json/name">ключ name</a></li></ol>
      </details>
    </li>

    <li><a href="/ru/docs/Mozilla/Add-ons/Themes"><strong>Themes</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Browser themes</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/Themes/Theme_concepts">Browser theme concepts</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Themes/Using_the_AMO_theme_generator">Using the AMO theme generator</a></li>
        </ol>
      </details>
    </li>
    <li><a href="/ru/docs/Mozilla/Add-ons/Distribution"><strong>Publishing and Distribution</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Publishing add-ons</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/Distribution">Signing and distribution overview</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Package_your_extension_">Package your extension</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Distribution/Submitting_an_add-on">Submit an add-on</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Source_Code_Submission">Source code submission</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Distribution/Resources_for_publishers">Resources for publishers</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Listing">Creating an appealing listing</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Distribution/Make_money_from_browser_extensions">Make money from browser extensions</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Distribution/Promoting_your_extension_or_theme">Promoting your extension or theme</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/AMO/Policy/Reviews">Review policies</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/AMO/Policy/Agreement">Developer agreement</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/AMO/Policy/Featured">Featured add-ons</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/Distribution/Retiring_your_extension">Retiring your extension</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Distributing add-ons</summary>
        <ol>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Alternative_distribution_options/Sideloading_add-ons">For sideloading</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Alternative_distribution_options/Add-ons_for_desktop_apps">For desktop apps</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/WebExtensions/Alternative_distribution_options/Add-ons_in_the_enterprise">For an enterprise</a></li>
        </ol>
      </details>
    </li>
    <li><a href="https://discourse.mozilla.org/c/add-ons"><strong>Community and Support</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Channels</summary>
        <ol>
          <li><a href="https://blog.mozilla.org/addons">Add-ons blog</a></li>
          <li><a href="https://discourse.mozilla.org/c/add-ons">Add-on forums</a></li>
          <li><a href="https://stackoverflow.com/questions/tagged/firefox-addon">Stack Overflow</a></li>
          <li><a href="/ru/docs/Mozilla/Add-ons/#Contact_us">Contact us</a></li>
        </ol>
      </details>
    </li>
  </ol>
</section><p></p>

<div class="warning notecard">
<p>Support for extensions using XUL/XPCOM or the Add-on SDK was removed in Firefox 57, released November 2017. As there is no supported version of Firefox enabling these technologies, this page will be removed by December 2020.</p>
</div>

<p></p><div class="warning notecard"><p>Add-ons using the techniques described in this document are considered a legacy technology in Firefox. Don&apos;t use these techniques to develop new add-ons. Use <a href="/en-US/Add-ons/WebExtensions">WebExtensions</a> instead. If you maintain an add-on which uses the techniques described here, consider migrating it to use WebExtensions.</p><p><strong>Starting from <a href="https://wiki.mozilla.org/RapidRelease/Calendar">Firefox 53</a>, no new legacy add-ons will be accepted on addons.mozilla.org (AMO) for desktop Firefox and Firefox for Android.</strong></p><p><strong>Starting from <a href="https://wiki.mozilla.org/RapidRelease/Calendar">Firefox 57</a>, only extensions developed using WebExtensions APIs will be supported on Desktop Firefox and Firefox for Android. </strong></p><p>Even before Firefox 57, changes coming up in the Firefox platform will break many legacy extensions. These changes include multiprocess Firefox (e10s), sandboxing, and multiple content processes. Legacy extensions that are affected by these changes should migrate to use WebExtensions APIs if they can. See the <a href="https://blog.mozilla.org/addons/2017/02/16/the-road-to-firefox-57-compatibility-milestones/">&quot;Compatibility Milestones&quot; document</a> for more information.</p><p>A wiki page containing <a href="https://wiki.mozilla.org/Add-ons/developer/communication">resources, migration paths, office hours, and more</a>, is available to help developers transition to the new technologies.</p></div><p></p>

<p>Многим дополнениям (add-on) необходим доступ к веб-страницам и возможность их изменения. Но основной код дополнения не имеет прямого доступа к веб-содержимому. Взамен, SDK-дополнений необходим способ в коде, который даст доступ к веб-содержимому в отдельных скриптах, которые называются <code>content scripts</code> (скрипты содержимого). Эта страница описывает как разрабатывать и реализовывать <code>content scripts</code>.</p>

<p>Скрипты <code>content scripts</code>, вероятно, один из наиболее сбивающих с толку аспектов при работе с SDK, но вам они скорее всего будут нужны. Существуют пять основных принципов:</p>

<ul>
 <li>расширения основного кода, включая &quot;main.js&quot; и другие модули в &quot;lib&quot;, могут использовать SDK <a href="/en-US/Add-ons/SDK/High-Level_APIs">верхнего-уровня</a> и <a href="/en-US/Add-ons/SDK/Low-Level_APIs">нижнего-уровня</a> API, но не имеют доступа к веб-содержимому напрямую;</li>
 <li>скрипты <code>content scripts </code><a href="/en-US/Add-ons/SDK/Guides/Two_Types_of_Scripts#API_Access_for_Add-on_Code_and_Content_Scripts">не могут использовать API в SDK</a> (нет доступа к глобальным <code>exports</code>, <code>require</code>) но есть доступ к веб-содержимому;</li>
 <li>API в SDK которые используют <code>content scripts</code>, например <a href="/en-US/Add-ons/SDK/High-Level_APIs/page-mod">page-mod</a> и <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs">tabs</a>, предоставляют функции, которые позволяют коду расширения загружать скрипты содержимого в веб-страницы;</li>
 <li>скрипты <code>content scripts </code>могут быть загружены как строки, но чаще они хранятся как отдельные файлы в папке &quot;data&quot;. jpm не создаёт каталог &quot;data&quot; по умолчанию, поэтому вы должны создать его и положить туда ваши скрипты;</li>
 <li>API передачи сообщений позволяет основному коду и скриптам <code>content scripts </code>взаимодействовать друг с другом.</li>
</ul>

<p>Следующее дополнение (полностью завершённое) показывает эти принципы. &quot;main.js&quot; прикрепляет <code>content scripts</code> к текущей вкладке, используя модуль <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs">tabs</a>. В этом случае, <code>content scripts</code> передаётся, как строка. Скрипт <code>content scripts</code> просто заменяет содержимое страницы:</p>

<pre class="brush: js">// main.js
var tabs = require(&quot;sdk/tabs&quot;);
var contentScriptString = &apos;document.body.innerHTML = &quot;&lt;h1&gt;this page has been eaten&lt;/h1&gt;&quot;;&apos;

tabs.activeTab.attach({
  contentScript: contentScriptString
});</pre>

<p>Следующие высокоуровневые SDK-модули, могут использовать скрипты <code>content scripts </code>для изменения веб-страниц:</p>

<ul>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/page-mod">page-mod</a>: позволяет вам прикреплять <code>content scripts</code> к веб-страницам, которые соответствуют заданному URL шаблону.</li>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs">tabs</a>: экспортирует объект <code>Tab</code> для работы с вкладкой браузера. <code>Tab-объект включает</code> функцию <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs#attach(options)"><code>attach()</code></a>, которая позволяет прикрепить <code>content scripts</code> ко вкладке.</li>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/page-worker">page-worker</a>: позволяет вам получить страницу, без отображения её. Вы можете прикрепить <code>content scripts</code> к странице, чтобы иметь доступ и возможность изменять DOM страницы.</li>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/context-menu">context-menu</a>: использует <code>content scripts</code> для взаимодействия со страницей, в которой вызывается меню.</li>
</ul>

<p>В дополнение к этому, некоторые SDK компоненты пользовательского интерфейса - <code>panel, sidebar, frame</code> - заданы в помощью HTML, и необходимо использовать отдельные скрипты для взаимодействия с их контентом. В большинстве случаев они похожи на скрипты <code>content scripts</code>, но в данной статье они не описываются. Для изучения способов взаимодействия с данными модулями пользовательского интерфейса обратитесь к документации: <a href="/en-US/Add-ons/SDK/High-Level_APIs/panel">panel</a>, <a href="/en-US/Add-ons/SDK/Low-Level_APIs/ui_sidebar">sidebar</a>, <a href="/en-US/Add-ons/SDK/Low-Level_APIs/ui_frame">frame</a>.</p>

<p>Почти все примеры дополнений, представленных в этом руководстве, доступны в полнофункциональном, но минимально необходимом, виде. На GitHub: <a href="https://github.com/mdn/addon-sdk-content-scripts">addon-sdk-content-scripts repository</a>.</p>

<h2 id="Загрузка_content_scripts">Загрузка content scripts</h2>

<article id="wikiArticle">
<p>Вы можете загрузить одиночный скрипт посредством задания строкового атрибута <code>contentScript</code> или <code>contentScriptFile.</code> Атрибут<code> contentScript</code> определяет строковое значение как сам скрипт:</p>

<pre class="brush: js">// main.js

var pageMod = require(&quot;sdk/page-mod&quot;);
var contentScriptValue = &apos;document.body.innerHTML = &apos; +
                         &apos; &quot;&lt;h1&gt;Page matches ruleset&lt;/h1&gt;&quot;;&apos;;

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScript: contentScriptValue
});</pre>

<p>Атрибут <code>contentScriptFile</code> определяет строковое значение как путь к ресурсу<code>://<em>URL-путь к скрипту, который находится в подкаталоге вашего дополнения</em>.</code> jpm не создаёт папку &quot;data&quot; по умолчанию, поэтому вы должны добавить её и положить внутрь файл <code>content scripts</code>.</p>

<p>Следующее дополнение использует URL для ссылки на файл &quot;content-script.js&quot;, находящийся в папке <code>data </code>в корне дополнения.</p>

<pre class="brush: js">// main.js

var data = require(&quot;sdk/self&quot;).data;
var pageMod = require(&quot;sdk/page-mod&quot;);

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScriptFile: data.url(&quot;content-script.js&quot;)
});</pre>

<pre class="brush: js">// content-script.js

document.body.innerHTML = &quot;&lt;h1&gt;Page matches ruleset&lt;/h1&gt;&quot;;</pre>

<div class="note notecard">
<p>Начиная с Firefox 34 и далее , вы можете использовать &quot;./content-script.js&quot; как синоним для self.data.url(&quot;content-script.js&quot;). Поэтому можно переписать код main.js, указанный выше, следующим образом:</p>

<pre class="brush: js">var pageMod = require(&quot;sdk/page-mod&quot;);

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScriptFile: &quot;./content-script.js&quot;
});
</pre>
</div>

<div class="warning notecard">
<p>Настоятельно рекоммендуется использовать  <code>contentScript </code>только для очень простых скриптов или статичных строк: если это не так, то могут возникнуть проблемы с принятием Вашего дополнения на AMO (<span class="st">addons.<em>mozilla</em>.org</span>).</p>

<p>Содержите ваши скрипты в отдельном файле и загружайте их, используя <code>contentScriptFile</code>. Это сделает ваш код проще в поддержке, отладке, безопаснее, удобочитаемее.</p>
</div>

<p>Для любого из параметров<code> contentScript</code> или <code>contentScriptFile</code> вы можете загружать несколько скриптов, передавая массив строк:</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);

tabs.on(&apos;ready&apos;, function(tab) {
  tab.attach({
      contentScript: [&apos;document.body.style.border = &quot;5px solid red&quot;;&apos;, &apos;window.alert(&quot;hi&quot;);&apos;]
  });
});
</pre>

<pre class="brush: js">// main.js

var data = require(&quot;sdk/self&quot;).data;
var pageMod = require(&quot;sdk/page-mod&quot;);

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScriptFile: [data.url(&quot;jquery.min.js&quot;), data.url(&quot;my-content-script.js&quot;)]
});</pre>

<p>Если так сделать, то скрипты смогут взаимодействовать друг с другом, как скрипты загружаемые на одной web-странице.</p>

<p>Можно использовать параметры <code>contentScript</code> and <code>contentScriptFile </code>одновременно. В таком случае скрипты, загружаемые <code>contentScriptFile</code>  загрузятся до <code>contentScript. </code>Это похволяет загружать библиотеки JavaScript, такие как jQuery по URL, а затем использвать их в простом скрипте, загруженном через <code>contentScript</code>:</p>

<pre class="brush: js">// main.js

var data = require(&quot;sdk/self&quot;).data;
var pageMod = require(&quot;sdk/page-mod&quot;);

var contentScriptString = &apos;$(&quot;body&quot;).html(&quot;&lt;h1&gt;Page matches ruleset&lt;/h1&gt;&quot;);&apos;;

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScript: contentScriptString,
  contentScriptFile: data.url(&quot;jquery.js&quot;)
});</pre>

<div class="warning notecard">
<p>Настоятельно рекоммендуется использовать  <code>contentScript </code>только для очень простых скриптов или статичных строк: если это не так, то могут возникнуть проблемы с принятием Вашего дополнения на AMO (<span class="st">addons.<em>mozilla</em>.org</span>).</p>

<p>Содержите ваши скрипты в отдельном файле и загружайте их, используя <code>contentScriptFile</code>. Это сделает ваш код проще в поддержке, отладке, безопаснее, удобочитаемее.</p>
</div>

<h3 id="Определение_момента_(времени)_подключения_скрипта">Определение момента (времени) подключения скрипта</h3>

<p>Опция <code>contentScriptWhen </code>определяет момент, когда <code>content script</code> должен быть загружен. Возможные варианты:</p>

<ul>
 <li><code>&quot;start&quot;</code>: загрузить сразу после того, как элемент документа страницы вставляется в DOM. В таком случае DOM-контент ещё пока не загружен, поэтому скрипт не может работать с ним.</li>
 <li><code>&quot;ready&quot;</code>: загрузить скрипт после того, как DOM страницы загружен: то есть в точке активации событий <a href="https://developer.mozilla.org/en/Gecko-Specific_DOM_Events">DOMContentLoaded</a>. В этот момент content scripts уже могут взаимодействовать с DOM-контентом, но загрузка внешних CSS и картинок ещё могла не завершиться.</li>
 <li><code>&quot;end&quot;</code>: загрузить скрипт после завершения загрузки всего контента (DOM, JS, CSS, картинки), в то время, как активируется событие <a href="https://developer.mozilla.org/en/DOM/window.onload">window.onload event</a>.</li>
</ul>

<p>Значение по умолчанию <code>&quot;<strong>end</strong>&quot;</code>.</p>

<p>Обратите внимание, что <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs#attach(options)"><code>tab.attach()</code></a> не имеет параметра <code>contentScriptWhen</code>, потому что он обычно вызывается после загрузки страницы.<a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs#attach(options)"><code> </code></a></p>

<h3 id="Передача_конфигурационных_опций">Передача конфигурационных опций</h3>

<p><code>Атрибут contentScriptOptions</code> это JSON-объект, который используется скриптом как read-only значение доступное через свойство <code><a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/self">self</a>.options</code>:</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);

tabs.on(&apos;ready&apos;, function(tab) {
  tab.attach({
      contentScript: &apos;window.alert(self.options.message);&apos;,
      contentScriptOptions: {&quot;message&quot; : &quot;hello world&quot;}
  });
});</pre>

<p>Могут быть использованы любые варианты JSON-объектов (object, array, string, etc.).</p>

<h2 id="Доступ_к_DOM">Доступ к DOM</h2>

<p>Скрипты <code>content scripts</code> могут иметь доступ к DOM страницы, конечно, только те скрипты, которые уже загрузились на странице. При этом скрипты content scripts изолированы от скриптов web-страницы:</p>

<ul>
 <li>content scripts не видят объектов JavaScript, добавленных скриптами web-страницы.</li>
 <li>Если скриты web-страницы переопределят поведения каких-либо DOM-объектов, то скрипты <code>content script</code> обнаружат исходное поведение.</li>
</ul>

<p>То же происходит в обратную сторону: скрипты web-страницы не увидят объектов JavaScript, добавленных скриптами <code>content scripts</code>.</p>

<p>Например, рассмотрим страницу, где скрипты web-страницы создают переменную <code>foo </code>в объекте <code>window</code>:</p>

<pre class="brush: html">&lt;!DOCTYPE html&quot;&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
    window.foo = &quot;hello from page script&quot;
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre>

<p>Другой скрипт (но тоже page-script), загруженный на страницу после этого скрипта (указанного выше), будет иметь доступ к foo. Но скрипт <code>content script</code> нет:</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);
var mod = require(&quot;sdk/page-mod&quot;);
var self = require(&quot;sdk/self&quot;);

var pageUrl = self.data.url(&quot;page.html&quot;)

var pageMod = mod.PageMod({
  include: pageUrl,
  contentScript: &quot;console.log(window.foo);&quot;
})

tabs.open(pageUrl);</pre>

<pre>console.log: my-addon: null
</pre>

<p>Есть веские причины для изоляции. Во-первых, из <code>content script</code> не утекают объекты в web-страницу, что потенциально является дырой в безопасности. Во-вторых, <code>content scripts</code> могут не беспокоиться о пересечении объектов с объектами, созданных скриптами web-страницы.</p>

<p>Такая изоляция необходима, например, в случае, если web-страница загружает библиотеку jQuery, но <code>content script</code> не увидит объектов, созданных этой библиотекой. В этом случае content script может добавить свою собственный jQuery-объект, который не пересечётся со страничным объектом.</p>

<h3 id="Взаимодействие_со_скриптами_web-страницы">Взаимодействие со скриптами web-страницы</h3>

<p>Обычно изоляция content scripts и page scripts (скрипты web-страницы) необходима. Но иногда вы захотите наладить такое взаимодействие: вы можете захотеть иметь общие объекты между <code>content scripts</code> и <code>page scripts</code> или передевать между ними сообщения. Если появится такая необходимость, то прочтите о <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/Interacting_with_page_scripts">взаимодействии со скриптами web-страницы</a> (<a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/Interacting_with_page_scripts">interacting with page scripts</a>).</p>

<h3 id="Прослушивание_событий">Прослушивание событий</h3>

<p>Вы можете прослушивать события DOM в скриптах <code>content scripts</code> также, как в обычных скриптах web-страницы. Но есть два важных отличия:</p>

<p>Первое. Если вы определите слушатель через передачу строки в функцию<a href="https://developer.mozilla.org/en/DOM/element.setAttribute"><code> setAttribute()</code></a>, то слушатель будет вызываться в контексте web-страницы, поэтому он не будет иметь доступа ни к каким переменным, определённым в <code>content script</code>.</p>

<p>Например, при выполнении в данном <code>content script</code> появится ошибка &quot;theMessage is not defined&quot;:</p>

<pre class="brush: js">var theMessage = &quot;Hello from content script!&quot;;
anElement.setAttribute(&quot;onclick&quot;, &quot;alert(theMessage);&quot;);</pre>

<p>Второе. Если вы определите слушатель напрямую через <a href="/en-US/docs/Web/API/GlobalEventHandlers">GlobalEventHandlers</a>, например на <code>onclick</code>, то такое определение может быть переопределено на web-странице. Например, здесь представлен add-on, который пытается добавить обработчик click-события при помощи присвоения <code>window.onclick</code>:</p>

<pre class="brush: js">var myScript = &quot;window.onclick = function() {&quot; +
               &quot;  console.log(&apos;unsafewindow.onclick: &apos; + window.document.title);&quot; +
               &quot;}&quot;;

require(&quot;sdk/page-mod&quot;).PageMod({
  include: &quot;*&quot;,
  contentScript: myScript,
  contentScriptWhen: &quot;start&quot;
});</pre>

<p>Это всё будет прекрасно работать на многих страницах, но не сработает там, где также присваивается <code>onclick</code>:</p>

<pre class="brush: html">&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
    window.onclick = function() {
      window.alert(&quot;it&apos;s my click now!&quot;);
    }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<p>По этим причинам, лучший вариант для добавления слушалелей это использование <a href="https://developer.mozilla.org/en/DOM/element.addEventListener"><code>addEventListener()</code></a>, определяющем функцию:</p>

<pre class="brush: js">var theMessage = &quot;Hello from content script!&quot;;

anElement.onclick = function() {
  alert(theMessage);
};

anotherElement.addEventListener(&quot;click&quot;, function() {
  alert(theMessage);
});</pre>

<h2 id="Взаимодействие_с_скриптом_дополнения_(add-on)">Взаимодействие с скриптом дополнения (add-on)</h2>

<p>Для организации взаимодействия друг с другом скрипта дополнения (<code>add-on script</code>) и скрипта <code>content script</code> нужно обоим дать доступ к объекту <code>port</code>.</p>

<ul>
 <li>для отправки сообщений используется <code>port.emit()</code></li>
 <li>для получения сообщений - <code>port.on()</code></li>
</ul>

<p><img alt src="https://mdn.mozillademos.org/files/7873/content-scripting-overview.png" style="display: block; margin-left: auto; margin-right: auto;">Сообщения асинхронны: то есть, отправитель не ждёт ответа от получателя, а только отправляет сообщение и продолжает работать дальше.</p>

<p>Вот пример простого дополнения, которое отправляет сообщение скрипту <code>content script, используя port</code>:</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);
var self = require(&quot;sdk/self&quot;);

tabs.on(&quot;ready&quot;, function(tab) {
  var worker = tab.attach({
    contentScriptFile: self.data.url(&quot;content-script.js&quot;)
  });
  worker.port.emit(&quot;alert&quot;, &quot;Message from the add-on&quot;);
});

tabs.open(&quot;http://www.mozilla.org&quot;);</pre>

<pre class="brush: js">// content-script.js

self.port.on(&quot;alert&quot;, function(message) {
  window.alert(message);
});</pre>

<div class="note notecard">
<p>Модуль <code>context-menu</code> не использует данную модель коммуникации. Для изучения варианта взаимодействия скриптов <code>content scripts</code>, загруженных с использованием <code>context-menu</code>, смотрите <a href="/en-US/Add-ons/SDK/High-Level_APIs/context-menu">context-menu documentation</a>. </p>
</div>

<h3 id="Доступ_к_порту_в_content_script">Доступ к порту в content script</h3>

<p>В скрипте <code>content script</code> объект <code>port </code>доступен через свойство глобального объекта <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/self"><code>self</code></a>.  Чтобы послать сообщение из <code>content script</code>:</p>

<pre class="brush: js">self.port.emit(&quot;myContentScriptMessage&quot;, myContentScriptMessagePayload);</pre>

<p>Чтобы получить сообщение из кода дополнения:</p>

<pre class="brush: js">self.port.on(&quot;myAddonMessage&quot;, function(myAddonMessagePayload) {
  // Handle the message
});</pre>

<div class="note notecard">
<p><span>Учтите, что глобальный объект <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/self"><code>self</code></a> совершенно отличается от модуля <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/self"><code>self</code> module</a>, предоставляющим API дополнению для доступа к его файлам и ID.</span></p>
</div>

<h3 id="Доступ_к_порту_в_скрипте_дополнения_(add-on_script)">Доступ к порту в скрипте дополнения (add-on script)</h3>

<p>В коде дополнения канал взаимодействия между дополнением и конкретным <code>content script</code> инкапсулируется посредством объекта <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/content_worker"><code>worker</code></a>. Поэтому объект <code>port </code>для для связи со скриптом content script это свойство связанного worker.</p>

<p>Тем не менее, объект worker не расширен на код дополнения так же, как в других модулях.</p>

<h4 id="Сообщения_из_page-worker">Сообщения из<code> page-worker</code></h4>

<p>Объект <code>page-worker</code> интегрирует в себе <code>worker API</code>. Поэтому для получения сообщений от скрипта content script, ассоциированного с <code>page-worker нужно использовать </code><code>pageWorker.port.on()</code>:</p>

<pre class="brush: js">// main.js

var self = require(&quot;sdk/self&quot;);

var pageWorker = require(&quot;sdk/page-worker&quot;).Page({
  contentScriptFile: self.data.url(&quot;content-script.js&quot;),
  contentURL: &quot;http://en.wikipedia.org/wiki/Internet&quot;
});

pageWorker.port.on(&quot;first-para&quot;, function(firstPara) {
  console.log(firstPara);
});</pre>

<p>Для отправки пользовательских сообщений их дополнения нужно вызвать <code>pageWorker.port.emit()</code>:</p>

<pre class="brush: js">// main.js

var self = require(&quot;sdk/self&quot;);

var pageWorker = require(&quot;sdk/page-worker&quot;).Page({
  contentScriptFile: self.data.url(&quot;content-script.js&quot;),
  contentURL: &quot;http://en.wikipedia.org/wiki/Internet&quot;
});

pageWorker.port.on(&quot;first-para&quot;, function(firstPara) {
  console.log(firstPara);
});

pageWorker.port.emit(&quot;get-first-para&quot;);</pre>

<pre class="brush: js">// content-script.js

self.port.on(&quot;get-first-para&quot;, getFirstPara);

function getFirstPara() {
  var paras = document.getElementsByTagName(&quot;p&quot;);
  if (paras.length &gt; 0) {
    var firstPara = paras[0].textContent;
    self.port.emit(&quot;first-para&quot;, firstPara);
  }
}</pre>

<h4 id="Сообщения_из_page-mod">Сообщения из <code>page-mod</code></h4>

<p>Один объект <code>page-mod</code> может привязать свои скрипты к нескольким страницам, каждая из них со своим контекстом, в котором запускаются <code>content scripts</code>. Поэтому для каждой страницы необходим отдельный канал (<code>worker</code>) связи.</p>

<p><code>page-mod</code> не интегрирует в себе <code>worker API напрямую</code>. Вместо этого, когда скрипт <code>content script</code> привязывается к странице, <code>page-mod</code> бросает событие <code>attach</code> тому слушателю, который связан с worker. Создавая слушатель для события <code>attach</code>, вы можете получить доступ через объект <code>port </code>к тому скрипту <code>content scripts</code>, который связан с нужной страницей (через <code>page-mod)</code>:</p>

<pre class="brush: js">// main.js

var pageMods = require(&quot;sdk/page-mod&quot;);
var self = require(&quot;sdk/self&quot;);

var pageMod = pageMods.PageMod({
  include: [&apos;*&apos;],
  contentScriptFile: self.data.url(&quot;content-script.js&quot;),
  onAttach: startListening
});

function startListening(worker) {
  worker.port.on(&apos;click&apos;, function(html) {
    worker.port.emit(&apos;warning&apos;, &apos;Do not click this again&apos;);
  });
}</pre>

<pre class="brush: js">// content-script.js

window.addEventListener(&apos;click&apos;, function(event) {
  self.port.emit(&apos;click&apos;, event.target.toString());
  event.stopPropagation();
  event.preventDefault();
}, false);

self.port.on(&apos;warning&apos;, function(message) {
  window.alert(message);
});
</pre>

<p>В дополнении, описанном выше, есть два сообщения:</p>

<ul>
 <li><code>click</code> отправляется из <code>page-mod</code> в дополнение, когда пользователь кликает на элемент на web-странице</li>
 <li><code>warning</code> отправляет прикольную строчку обратно в объект <code>page-mod</code></li>
</ul>

<h4 id="Сообщения_из_Tab.attach()">Сообщения из <code>Tab.attach()</code></h4>

<p>Функция <code>Tab.attach()</code> возвращает <code>worker</code>, который можно использовать для связи со скриптом content script(s).</p>

<p>Следующее дополнение добавляет кнопку в Firefox: когда пользователь надимает её, то дополнение привязывает скрипт <code>content script</code> к активной вкладке, отправляет этому скрипту сообщение &quot;my-addon-message&quot; и ждёт ответ &quot;my-script-response&quot;:</p>

<pre class="brush: js">//main.js

var tabs = require(&quot;sdk/tabs&quot;);
var buttons = require(&quot;sdk/ui/button/action&quot;);
var self = require(&quot;sdk/self&quot;);

buttons.ActionButton({
  id: &quot;attach-script&quot;,
  label: &quot;Attach the script&quot;,
  icon: &quot;./icon-16.png&quot;,
  onClick: attachScript
});

function attachScript() {
  var worker = tabs.activeTab.attach({
    contentScriptFile: self.data.url(&quot;content-script.js&quot;)
  });
  worker.port.on(&quot;my-script-response&quot;, function(response) {
    console.log(response);
  });
  worker.port.emit(&quot;my-addon-message&quot;, &quot;Message from the add-on&quot;);
}
</pre>

<pre class="brush: js">// content-script.js

self.port.on(&quot;my-addon-message&quot;, handleMessage);

function handleMessage(message) {
  alert(message);
  self.port.emit(&quot;my-script-response&quot;, &quot;Response from content script&quot;);
}</pre>

<h3 id="Описание_port_API">Описание port API</h3>

<p>Смотрите <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/port">reference page for the <code>port</code> object</a>.</p>
</article>

<h3 id="Описание_postMessage_API">Описание postMessage API</h3>

<p>До того, как был введён объект port, дополнения и <code>content scripts </code>общались следующим образом, используя различные API:</p>

<ul>
 <li>скрипт content script <code>вызывал self.postMessage()</code> для отправки и <code>self.on()</code> для получения</li>
 <li>дополнение (add-on) вызывал <code>worker.postMessage()</code> для отправки и <code>worker.on()</code> для получения</li>
</ul>

<p>Данный API до сих пор доступно и <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/using_postMessage">документировано</a>, но желательно использовать <code>port API</code>, описанный здесь выше. Исключением является модуль <a href="/en-US/Add-ons/SDK/High-Level_APIs/context-menu">context-menu</a>, который ещё использует <code>postMessage</code>.</p>

<h3 id="Взаимодействие_скриптов_content_script_со_скриптами_content_script">Взаимодействие скриптов content script со скриптами content script</h3>

<p>Скрипты <code>content scripts</code> могут взаимодействовать друг с другом напрямую если они загружены в одном контексте. Например, если один вызов <code>Tab.attach()</code> привязывает два скрипта <code>content scripts</code>, то они видят друг друга напрямую, как если два скрипта загружены на одну страницу. Но если вызвать <code>Tab.attach()</code> дважды, привязывая <code>content scripts</code> каждый раз, то они уже не будут загружены в одном контексте, и дожны взаимодействовать способами как скрипты из разных контекстов. Один из вариантом это пересылать сообщения через основной код дополнения, используя port API с передачей сообщения другим скриптам <code>context script</code>. Этои вариант будет работать независимо от контекста, в котором загружен скрипт <code>content script</code>.</p>

<p>В отдельном случае, когда два скрипта загружены на одной странице, существует возможность для обоих скриптов <code>content scripts</code> взаимодействовать друг с другом, используя<a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Content_Scripts/Communicating_With_Other_Scripts#Using_the_DOM_postMessage_API"> DOM postMessage() API</a> или <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">CustomEvent</a>. Следующее дополнение показывает как скрипт <code>content script</code>, добавленный через <code>page-mod</code>, получает событие CustomEvent, отправленное из <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK/High-Level_APIs/context-menu">context-menu</a>, когда элемент меню был кликнут. Скрипт <code>page-mod</code> будет отображать алерт с URL той ссылки, по которой было отображено контекстное меню. URL передан в скрипт <code>page-mod</code> с использованием CustomEvent.</p>

<pre><code>var pageMod = require(&quot;sdk/page-mod&quot;);
pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScript: &apos;function contextMenuAlert(href) {&apos;
               + &apos;    window.alert(&quot;The context menu was clicked on URL:\\n&quot; + href);&apos;
               + &apos;};&apos;
               + &apos;window.addEventListener(&quot;myAddonId-contextMenu-clicked&quot;,&apos;
               + &apos;    function(event){contextMenuAlert(event.detail);});&apos;
});

let cm = require(&quot;sdk/context-menu&quot;);
cm.Item({
    label: &quot;Alert URL&quot;,
    context: [
        cm.URLContext([&quot;*.mozilla.org&quot;]),
        cm.SelectorContext(&quot;a[href]&quot;)
    ],
    contentScript: &apos;self.on(&quot;click&quot;, function (node, data) {&apos;
                 + &apos;    var event = new CustomEvent(&quot;myAddonId-contextMenu-clicked&quot;,&apos;
                 + &apos;                                {detail:node.href});&apos;
                 + &apos;    window.dispatchEvent(event);&apos;
                 + &apos;});&apos;
});</code></pre>

<h2 id="Междоменные_скрипты_content_script">Междоменные скрипты <code>content script</code></h2>

<p>По умолчанию скрипты <code>content script </code>не имеют никаких междоменных привилегий. В частности, они не имеют доступа к содержимому в <code>iframe</code>, если содержимое получено из другого домена, или выполняются междоменные XMLHttpRequests.</p>

<p>Однако, вы можете разрешить эти функции для заданных доменов, путём добавления их в <a href="/en-US/Add-ons/SDK/Tools/package_json">package.json</a> дополнения в ключе <code>&quot;cross-domain-content&quot;</code>, который расположен в ключе <code>&quot;permissions&quot;</code>. Смотрите статью <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/Cross_Domain_Content_Scripts">междоменные скрипты содержимого</a>.</p>
</article>
