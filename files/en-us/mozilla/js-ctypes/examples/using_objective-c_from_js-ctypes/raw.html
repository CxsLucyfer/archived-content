<section class="Quick_links" id="Quick_Links">
<ol>
 <li><a href="/en-US/docs/Mozilla/js-ctypes"><strong><em>js-ctypes</em></strong></a></li>
 <li class="toggle">
  <details><summary>Introduction</summary>
  <ol>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Debugging_Tips" title="Editorial review completed.">Debugging Tips</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_calling_functions" title="Functions are declared using the Library object's declare() method. Once declared, functions can be called using standard function syntax.">Declaring and Calling Functions</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_Using_Callbacks" title="C functions occasionally take function pointers as arguments, which are generally used as callbacks. In these cases, js-ctypes allows you to pass a regular JavaScript function as the callback. This is very powerful, since it allows native code to transparently call into JavaScript.">Declaring and Using Callbacks</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_types" title="The ctypes object offers a number of constructor methods that let you declare types. Every type is represented by a CType object, which, in turn, provides a constructor method you can call to define values of those types. Each type you declare using js-ctypes corresponds to a compatible C declaration.">Declaring types</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Memory_Management" title="If JS code creates a structure or an array, that memory will be valid as long as the JS object stays alive. Pointers to that memory must be carefully managed to make sure the underlying memory is still referenced.">Memory Management</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Standard_OS_Libraries" title="This article gives the names of standard libraries that can be accessed with js-ctypes. These libraries are what enable js-ctypes to work. The alternative to standard libraries is creating your own DLL (for Windows) or SO (for Linux) file with C functions that can be called from your add-on with js-ctypes. The DLL/SO/etc file you make must be shipped with your add-on. Standard libraries offer the advantage of not having to ship anything. They are already available on the operating system for you. You just need to supply the path to appropriate files and set up the proper types of values/arguments in the js-ctypes code. This article allows you to find out what types to give to values/arguments by supplying links to the documentation of the OS libraries.">Standard OS Libraries</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Type_conversion" title="In js-ctypes, data could be converted implicitly when passing to or returning from a FunctionType call, or setting pointer content, an array element or a struct field.">Type conversion</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_ArrayBuffers" title="An ArrayBuffer is a simply byte array. The js-ctypes equivalent is a ctypes.uint8_t.array(###) (ctypes.unsigned_char are also ctypes.uint8_t).">Working with ArrayBuffers</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_data" title="Data types for use with js-ctypes are represented by CType objects. These are JavaScript constructors; as such, they're callable functions that you can use to create new CData objects of that type. There are several ways you can go about creating new CData objects.">Working with data</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/ctypes.open" title="At the heart of js-ctypes is the ctypes.open() function. This must be called before any work can commence. There are two options:">ctypes.open</a></li>
  </ol>
  </details>
 </li>
 <li class="toggle">
  <details><summary>References</summary>
  <ol>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ABI" title="This article describes the calling conventions with respect to js-ctypes while programming x86 and x86-64/x64/AMD64 architectures. A calling convention is an implementation-level (low-level) scheme regarding how subroutines receive parameters from their caller and how they revert."><code>ABI</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ArrayType" title="ArrayType represents C arrays"><code>ArrayType</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CData" title="A CData object represents a C value or function located in memory."><code>CData</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CType" title="All data types declared using the js-ctypes API are represented by CType objects. These objects have assorted methods and properties that let you create objects of these types, find out information about them, and so forth. The specific properties and methods on each object vary depending on the data type represented."><code>CType</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/FunctionType" title=""><code>FunctionType</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Int64" title="Because JavaScript doesn't currently include standard support for 64-bit integer values, js-ctypes offers the Int64 and UInt64 objects to let you work with C functions and data that need (or may need) values represented using a 64-bit data type."><code>Int64</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Library" title="The Library object represents a native library loaded by the ctypes open() method. Its methods let you declare symbols exported by the library, and to manage the library."><code>Library</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/PointerType" title="Returns a new CType object describing a new pointer data type."><code>PointerType</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/StructType" title="Returns a CType object describing a new structure data type. This data type provides the ability to define and manipulate values of the C struct type."><code>StructType</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/UInt64" title="As JavaScript doesn't currently include standard support for 64-bit integer values, js-ctypes offers the Int64 and UInt64 objects to let you work with C functions and data that need (or may need) to use data represented using a 64-bit data type."><code>UInt64</code></a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ctypes" title="The ctypes object contains methods and predefined data types used to create and manage a library."><code>ctypes</code></a></li>
  </ol>
  </details>
 </li>
 <li class="toggle">
  <details open><summary>Examples</summary>
  <ol>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Add_to_iPhoto" title="This extension for Mac OS X serves as a demonstration of how to use js-ctypes to call Mac OS X Carbon, Core Foundation, and other system frameworks from an extension written entirely in JavaScript.">Add to iPhoto</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_C_structs_and_pointers" title="In this example, we show how to use C structs and pointers with js-ctypes.">Using C struct and pointers</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_COM_from_js-ctypes" title="The Windows API mostly concerns itself with the interaction between the operating system and an application. For communication between the different Windows applications among themselves, Microsoft has developed a series of technologies alongside the main Windows API. This started out with Dynamic Data Exchange (DDE), which was superseded by Object Linking and Embedding (OLE) and later by the Component Object Model (COM), Automation Objects, ActiveX controls, and the .NET Framework.">Using COM from js-ctypes</a></li>
   <li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes" title="Objective-C has its own syntax, it cannot be written directly with js-ctypes. This guide explains how to convert Objective-C code into js-ctypes code.">Using Objective-C from js-ctypes</a></li>
  </ol>
  </details>
 </li>
</ol>
</section>

<p><span class="seoSummary">Objective-C has its own syntax, it cannot be written directly with js-ctypes. This guide explains how to convert Objective-C code into js-ctypes code.</span></p>

<div class="note">
<p>A simple example is also in <a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Standard_OS_Libraries#Cocoa">Standard OS Libraries</a> page.</p>
</div>

<h2 id="Converting_Objective-C_code_to_C_code">Converting Objective-C code to C code</h2>

<p>To convert Objective-C code to js-ctypes, we need to convert it to C code first. We can then convert it straight to js-ctypes code.</p>

<h3 id="Speech_Synthesis_Example">Speech Synthesis Example</h3>

<p>Let's start with the following Objective-C code, which invokes the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSSpeechSynthesizer_Class/">Speech Synthesis API</a> to say "Hello, Firefox!". It uses the default system voice and waits until the speaking is done.</p>

<pre class="brush: cpp">#import &lt;AppKit/AppKit.h&gt;

int
main(void) {
  NSSpeechSynthesizer* synth = [[NSSpeechSynthesizer alloc] initWithVoice: nil];

  [synth startSpeakingString: @"Hello, Firefox!"];
  // Wait until start speaking.
  while (![synth isSpeaking]) {}
  // Wait while speaking.
  while ([synth isSpeaking]) {}

  [synth release];

  return 0;
}
</pre>

<p>Save this file as <code>test.m</code>, and run with the following command, inside the same directory as the saved file (needs XCode).</p>

<pre class="brush: cpp">$ clang -framework AppKit test.m &amp;&amp; ./a.out
</pre>

<h3 id="Class_Message_and_Selector">Class, Message, and Selector</h3>

<p>Our task at hand is to convert Objective-C syntax to C syntax. Let's look at the following codelet:</p>

<pre class="brush: cpp">[NSSpeechSynthesizer alloc]
</pre>

<p>It passes an <code>alloc</code> message to the <code>NSSpeechSynthesizer</code> class, in Objective-C syntax. It performs the following through this Objective-C syntax:</p>

<ol>
 <li>Get the <code>NSSpeechSynthesizer</code> class definition.</li>
 <li>Register the <code>alloc</code> selector for the message.</li>
 <li>Send a message to the class, with the selector.</li>
</ol>

<h4 id="Get_a_reference_to_a_class">Get a reference to a class</h4>

<p>Class definitions are retrieved with the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_getClass"><code>objc_getClass</code></a> function, declared in <code>/usr/include/objc/runtime.h</code>. The <code>objc_getClass</code> function receives the name of the class, looks up the definition, and returns it.</p>

<pre class="brush: cpp">Class objc_getClass(const char *name);
</pre>

<p>In <code>/usr/include/objc/objc.h</code>, <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/tdef/Class"><code>Class</code></a> is defined as an opaque type by the following:</p>

<pre class="brush: cpp">typedef struct objc_class *Class;
</pre>

<p>In this example, we need the class<code>NSSpeechSynthesizer</code>, which is retrieved with the following code:</p>

<pre class="brush: cpp">Class NSSpeechSynthesizer = objc_getClass("NSSpeechSynthesizer");
</pre>

<h4 id="Registering_a_selector">Registering a selector</h4>

<p>Selectors can be registered and retrieved with <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/sel_registerName"><code>sel_registerName</code></a> function, also declared in <code>/usr/include/objc/runtime.h</code>. <code>sel_registerName</code> receives the name of the selector, and returns the selector.</p>

<pre class="brush: cpp">SEL sel_registerName(const char *str);
</pre>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/tdef/SEL"><code>SEL</code></a> is defined as follows, in <code>/usr/include/objc/objc.h</code>. It's also an opaque type.</p>

<pre class="brush: cpp">typedef struct objc_selector *SEL;
</pre>

<p>In this example, we need to send <code>alloc</code>, its selector can be retrieved with the following code:</p>

<pre class="brush: cpp">SEL alloc = sel_registerName("alloc");
</pre>

<h4 id="Sending_a_message">Sending a message</h4>

<p>Once target class and selector are ready, you can send a message. This message can be sent using the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/objc_msgSend"><code>objc_msgSend</code></a> function, and its variants, which are declared in <code>/usr/include/objc/message.h</code>. <code>objc_msgSend</code> function, receives the instance which receives the message, the selector, and variable argument list for the message, returning the returned value from the method.</p>

<pre class="brush: cpp">id objc_msgSend(id self, SEL op, ...);
</pre>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/tdef/id"><code>id</code></a> is defined as the following, in <code>/usr/include/objc/objc.h</code>, it's also an opaque type. <code>Class</code> can be cast into <code>id</code>, so we can pass <code>Class</code> returned by <code>objc_getClass</code>.</p>

<pre class="brush: cpp">typedef struct objc_object *id;
</pre>

<p>In this example, we send an <code>alloc</code> message without any arguments using the following code. This code returns an allocated <code>NSSpeechSynthesizer</code> instance that has not yet been initialized.</p>

<pre class="brush: cpp">id tmp = objc_msgSend((id)NSSpeechSynthesizer, alloc);
</pre>

<p>Here, <code>Class</code> is always cast into <code>id</code>, which is an opaque type. We could choose to use <code>id</code> instead, reducing casting and making our code more efficient in future.</p>

<pre class="brush: cpp">id NSSpeechSynthesizer = (id)objc_getClass("NSSpeechSynthesizer");
id tmp = objc_msgSend(NSSpeechSynthesizer, alloc);
</pre>

<h3 id="Selector_for_a_method_with_arguments">Selector for a method with arguments</h3>

<p><code>In this case, [NSSpeechSynthesizer initWithVoice:]</code> takes one argument; the selector name with a trailing colon.</p>

<pre class="brush: cpp">SEL initWithVoice = sel_registerName("initWithVoice:");
</pre>

<p>If a method takes two or more arguments, the selector name becomes a concatenation of each name.</p>

<pre class="brush: cpp">// [NSString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]
SEL foo = sel_registerName("getBytes:maxLength:usedLength:encoding:options:range:remainingRange:");
</pre>

<h3 id="Method_which_returns_non-id_type">Method which returns non-id type</h3>

<p>If a method returns a type which is compatible with <code>id</code>, we can cast it, or just use it as <code>id</code> type (since we don't need to use a different type for each instance, in terms of C).</p>

<p>Otherwise, the following functions can be used, depending on return type and architecture.</p>

<dl>
 <dt><code>objc_msgSend_stret</code></dt>
 <dd>For the method which returns structs on the stack.</dd>
 <dt><code>objc_msgSend_fpret</code> / <code>objc_msgSend_fp2ret</code></dt>
 <dd>For the method which returns floating-point values on the stack.</dd>
 <dt><code>objc_msgSend</code></dt>
 <dd>For the method which returns the value in a register, or returns nothing.</dd>
</dl>

<p>For example, <code>[NSSpeechSynthesizer isSpeaking]</code> returns <code>BOOL</code>. In this case, <code>BOOL</code> can be passed through a register, and we can use <code>objc_msgSend</code>. As <code>[NSObject release]</code> returns nothing, we can also use <code>objc_msgSend</code>.</p>

<h3 id="NSString_literals">NSString literals</h3>

<p>Another Objective-C syntax used is the <code>@"..."</code> literal, which creates NSString instance. This could be converted by the following Objective-C code (may not be exactly the same).</p>

<pre class="brush: cpp">NSString* text = [NSString initWithCString: "Hello, Firefox!"
                                  encoding: NSUTF8StringEncoding];
</pre>

<p>This will be converted into the following C code. <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/#//apple_ref/doc/constant_group/String_Encodings"><code>NSUTF8StringEncoding</code></a> is defined as <code>4</code>.</p>

<pre class="brush: cpp">id NSString = (id)objc_getClass("NSString");
SEL initWithCString_encoding = sel_registerName("initWithCString:encoding:");
int NSUTF8StringEncoding = 4;
id tmp = objc_msgSend(NSString, alloc);
id text = objc_msgSend(tmp, initWithCString_encoding,
                       "Hello, Firefox!", NSUTF8StringEncoding);
</pre>

<p>Note that you need to release this allocated <code>NSString</code> instance.</p>

<h3 id="Converted_C_code">Converted C code</h3>

<p>Now we can translate our whole code into C syntax.</p>

<pre class="brush: cpp">#include &lt;objc/objc.h&gt;
#include &lt;objc/runtime.h&gt;
#include &lt;objc/message.h&gt;

int
main(void) {
  // NSSpeechSynthesizer* synth = [[NSSpeechSynthesizer alloc] initWithVoice: nil];
  id NSSpeechSynthesizer = (id)objc_getClass("NSSpeechSynthesizer");
  SEL alloc = sel_registerName("alloc");
  SEL initWithVoice = sel_registerName("initWithVoice:");
  id tmp = objc_msgSend(NSSpeechSynthesizer, alloc);
  id synth = objc_msgSend(tmp, initWithVoice, NULL);

  // @"Hello, Firefox!"
  id NSString = (id)objc_getClass("NSString");
  SEL initWithCString_encoding = sel_registerName("initWithCString:encoding:");
  int NSUTF8StringEncoding = 4;
  id tmp2 = objc_msgSend(NSString, alloc);
  id text = objc_msgSend(tmp2, initWithCString_encoding,
                         "Hello, Firefox!", NSUTF8StringEncoding);

  // [synth startSpeakingString: @"Hello, Firefox!"];
  SEL startSpeakingString = sel_registerName("startSpeakingString:");
  objc_msgSend(synth, startSpeakingString, text);

  SEL isSpeaking = sel_registerName("isSpeaking");

  // Wait until start speaking.
  // [synth isSpeaking]
  while (!objc_msgSend(synth, isSpeaking)) {}
  // Wait while speaking.
  // [synth isSpeaking]
  while (objc_msgSend(synth, isSpeaking)) {}

  SEL release = sel_registerName("release");

  // [synth release];
  objc_msgSend(synth, release);
  // [text release];
  objc_msgSend(text, release);

  return 0;
}
</pre>

<p>To run this code, save it as <code>test.c</code>, and run the following command in the same directory.</p>

<pre class="brush: cpp">$ clang -lobjc -framework AppKit test.c &amp;&amp; ./a.out
</pre>

<h2 id="Converting_C_code_to_js-ctypes_code">Converting C code to js-ctypes code</h2>

<p>Now we have working C code, it can be converted into js-ctypes in a relatively straightforward manner.</p>

<h3 id="Types_and_Functions">Types and Functions</h3>

<p>In addition to the above code, we need to declare function and types.</p>

<h4 id="Types">Types</h4>

<p>Types can be readily declared. <code>BOOL</code> is defined in <code>/usr/include/objc/objc.h</code>.</p>

<pre class="brush: js">let id = ctypes.StructType("objc_object").ptr;
let SEL = ctypes.StructType("objc_selector").ptr;
let BOOL = ctypes.signed_char;
</pre>

<h4 id="Functions">Functions</h4>

<p>All functions in our example are exported by <code>/usr/lib/libobjc.dylib</code>.</p>

<pre class="brush: js">let lib = ctypes.open(ctypes.libraryName("objc"));
</pre>

<p>Function definition is the more tricky part. In this example, <code>objc_msgSend</code> is used in 3 ways. We need to declare three different <code>FunctionType</code> <code>CData</code>s:</p>

<ul>
 <li>Returns <code>id</code> or compatible type.</li>
 <li>Returns <code>BOOL</code>.</li>
 <li>Returns nothing.</li>
</ul>

<pre class="brush: js">let objc_msgSend_id = lib.declare("objc_msgSend", ctypes.default_abi,
                                  id, id, SEL, "...");
let objc_msgSend_BOOL = lib.declare("objc_msgSend", ctypes.default_abi,
                                    BOOL, id, SEL, "...");
let objc_msgSend_void = lib.declare("objc_msgSend", ctypes.default_abi,
                                    ctypes.void_t, id, SEL, "...");
</pre>

<p>The first two cases are both integers (including pointer), so we can cast them after receiving the value in pointer type. The third case is <code>void</code>, but we're going to use the same function internally, the only difference is if we need to ignore the returned value or not. In fact, here we can use the same definition in all cases, as a minimal case.</p>

<pre class="brush: js">let objc_msgSend = lib.declare("objc_msgSend", ctypes.default_abi,
                               id, id, SEL, "...");
</pre>

<p>Declaring a dedicated function for <code>BOOL</code> might be more efficient, directly getting the primitive value.</p>

<pre class="brush: js">let objc_msgSend = lib.declare("objc_msgSend", ctypes.default_abi,
                               id, id, SEL, "...");
let objc_msgSend_BOOL = lib.declare("objc_msgSend", ctypes.default_abi,
                                    BOOL, id, SEL, "...");
</pre>

<p>Other functions can be declared fluently, using <code>id</code> instead of <code>Class</code> as the return type of <code>objc_getClass</code>.</p>

<pre class="brush: js">let objc_getClass = lib.declare("objc_getClass", ctypes.default_abi,
                                id, ctypes.char.ptr);
let sel_registerName = lib.declare("sel_registerName", ctypes.default_abi,
                                    SEL, ctypes.char.ptr);
</pre>

<h3 id="Calling_variadic_function">Calling variadic function</h3>

<p><code>objc_msgSend</code> is a variadic function, so we should always pass it a <code>CData</code> instance, other than this first and second argument, to declare each argument type.</p>

<p>For example, let's take the following function call:</p>

<pre class="brush: cpp">id text = objc_msgSend(tmp2, initWithCString_encoding,
                       "Hello, Firefox!", NSUTF8StringEncoding);
</pre>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/#//apple_ref/occ/instm/NSString/initWithCString:encoding:"><code>[NSString initWithCString:encoding:]</code></a> is defined as:</p>

<pre class="brush: cpp">- (instancetype)initWithCString:(const char *)nullTerminatedCString
                       encoding:(NSStringEncoding)encoding
</pre>

<p>And <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/#//apple_ref/c/tdef/NSStringEncoding"><code>NSStringEncoding</code></a> is defined as:</p>

<pre class="brush: cpp">typedef unsigned long NSUInteger;
typedef NSUInteger NSStringEncoding;
</pre>

<p>So, our function call can be converted into the following js-ctypes code:</p>

<pre class="brush: js">let text = objc_msgSend(tmp2, initWithCString_encoding,
                        ctypes.char.array()("Hello, Firefox!"),
                        ctypes.unsigned_long(NSUTF8StringEncoding));
</pre>

<h3 id="Converted_js-ctypes_code">Converted js-ctypes code</h3>

<p>Finally, we have our converted code. This can run with a copy-and-paste into a JavaScript shell.</p>

<div class="warning">This example uses a busy loop, and thus, Firefox won't respond until the speaking is done. If this code were to be used in a production add-on, then to avoid Firefox locking up, run this code from a <a href="/en-US/docs/Web/API/ChromeWorker">ChromeWorker</a>.</div>

<pre class="brush: js">let { ctypes } = Components.utils.import("resource://gre/modules/ctypes.jsm", {});

let id = ctypes.StructType("objc_object").ptr;
let SEL = ctypes.StructType("objc_selector").ptr;
let BOOL = ctypes.signed_char;

let lib = ctypes.open(ctypes.libraryName("objc"));

let objc_getClass = lib.declare("objc_getClass", ctypes.default_abi,
                                id, ctypes.char.ptr);
let sel_registerName = lib.declare("sel_registerName", ctypes.default_abi,
                                    SEL, ctypes.char.ptr);
let objc_msgSend = lib.declare("objc_msgSend", ctypes.default_abi,
                               id, id, SEL, "...");
let objc_msgSend_BOOL = lib.declare("objc_msgSend", ctypes.default_abi,
                                    BOOL, id, SEL, "...");

let NSSpeechSynthesizer = objc_getClass("NSSpeechSynthesizer");
let alloc = sel_registerName("alloc");
let initWithVoice = sel_registerName("initWithVoice:");
let tmp = objc_msgSend(NSSpeechSynthesizer, alloc);
let synth = objc_msgSend(tmp, initWithVoice, ctypes.voidptr_t(null));

let NSString = objc_getClass("NSString");
let initWithCString_encoding = sel_registerName("initWithCString:encoding:");
let NSUTF8StringEncoding = 4;
let tmp2 = objc_msgSend(NSString, alloc);
let text = objc_msgSend(tmp2, initWithCString_encoding,
                        ctypes.char.array()("Hello, Firefox!"),
                        ctypes.unsigned_long(NSUTF8StringEncoding));

let startSpeakingString = sel_registerName("startSpeakingString:");
objc_msgSend(synth, startSpeakingString, text);

let isSpeaking = sel_registerName("isSpeaking");

// Wait until start speaking.
while (!objc_msgSend_BOOL(synth, isSpeaking)) {}
// Wait while speaking.
while (objc_msgSend_BOOL(synth, isSpeaking)) {}

let release = sel_registerName("release");

objc_msgSend(synth, release);
objc_msgSend(text, release);

lib.close();
</pre>

<h2 id="Creating_Objective-C_Blocks">Creating Objective-C Blocks</h2>

<p>Objective-C API calls sometimes require you to pass in a block. Reading the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">Apple Developer :: Programming with Objective-C - Working with Blocks</a> you can learn more about blocks. To create a block with js-ctypes, use the function:</p>

<pre>function createBlock(aFuncTypePtr) {
	/**
	 * Creates a C block instance from a JS Function.
	 * Blocks are regular Objective-C objects in Obj-C, and can be sent messages;
	 * thus Block instances need are creted using the core.wrapId() function.
	 */
	// Apple Docs :: Working with blocks - https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html

	var _NSConcreteGlobalBlock = ctypes.open(ctypes.libraryName('objc')).declare('_NSConcreteGlobalBlock', ctypes.voidptr_t); // https://dxr.mozilla.org/mozilla-central/source/js/src/ctypes/Library.cpp?offset=0#271

	/**
	 * The "block descriptor" is a static singleton struct. Probably used in more
	 * complex Block scenarios involving actual closure variables needing storage
	 * (in `NodObjC`, JavaScript closures are leveraged instead).
	 */
	// struct is seen here in docs: http://clang.llvm.org/docs/Block-ABI-Apple.html
	var Block_descriptor_1 = ctypes.StructType('Block_descriptor_1', [
		{ reserved: ctypes.unsigned_long_long },
		{ size: ctypes.unsigned_long_long }
	]);

	/**
	 * We have to simulate what the llvm compiler does when it encounters a Block
	 * literal expression (see `Block-ABI-Apple.txt` above).
	 * The "block literal" is the struct type for each Block instance.
	 */
	// struct is seen here in docs: http://clang.llvm.org/docs/Block-ABI-Apple.html
	var Block_literal_1 = ctypes.StructType('Block_literal_1', [
		{ isa: ctypes.voidptr_t },
		{ flags: ctypes.int32_t },
		{ reserved: ctypes.int32_t },
		{ invoke: ctypes.voidptr_t },
		{ descriptor: Block_descriptor_1.ptr }
	]);

	var BLOCK_CONST = {
		BLOCK_HAS_COPY_DISPOSE: 1 &lt;&lt; 25,
		BLOCK_HAS_CTOR: 1 &lt;&lt; 26,
		BLOCK_IS_GLOBAL: 1 &lt;&lt; 28,
		BLOCK_HAS_STRET: 1 &lt;&lt; 29,
		BLOCK_HAS_SIGNATURE: 1 &lt;&lt; 30
	};

	// based on work from here: https://github.com/trueinteractions/tint2/blob/f6ce18b16ada165b98b07869314dad1d7bee0252/modules/Bridge/core.js#L370-L394
	var bl = Block_literal_1();
	// Set the class of the instance
	bl.isa = _NSConcreteGlobalBlock;
	// Global flags
	bl.flags = BLOCK_CONST.BLOCK_HAS_STRET;
	bl.reserved = 0;
	bl.invoke = aFuncTypePtr;

	// create descriptor
	var desc = Block_descriptor_1();
	desc.reserved = 0;
	desc.size = Block_literal_1.size;

	// set descriptor into block literal
	bl.descriptor = desc.address();

	return bl;
}</pre>

<p>An example of this function in use can be seen here: <a href="https://gist.github.com/Noitidart/8645b47b0e46a0eb284e">_ff-addon-snippet-objc_monitorEvents - Shows how to monitor and block mouse and key events on Mac OS X</a></p>