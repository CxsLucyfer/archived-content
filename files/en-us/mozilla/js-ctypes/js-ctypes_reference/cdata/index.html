---
title: CData
slug: Mozilla/js-ctypes/js-ctypes_reference/CData
tags:
  - JavaScript
  - Reference
  - js-ctypes
---
<section class="Quick_links" id="Quick_Links">
 <ol>
  <li><a href="/en-US/docs/Mozilla/js-ctypes"><strong><em>js-ctypes</em></strong></a></li>
  <li class="toggle">
      <details>
        <summary>Introduction</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Debugging_Tips">Debugging Tips</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_calling_functions">Declaring and Calling Functions</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_Using_Callbacks">Declaring and Using Callbacks</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_types">Declaring types</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Memory_Management">Memory Management</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Standard_OS_Libraries">Standard OS Libraries</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Type_conversion">Type conversion</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_ArrayBuffers">Working with ArrayBuffers</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_data">Working with data</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/ctypes.open">ctypes.open</a></li></ol>
      </details>
  </li>
  <li class="toggle">
      <details open>
        <summary>References</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ABI"><code>ABI</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ArrayType"><code>ArrayType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CData"><code>CData</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CType"><code>CType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/FunctionType"><code>FunctionType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Int64"><code>Int64</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Library"><code>Library</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/PointerType"><code>PointerType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/StructType"><code>StructType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/UInt64"><code>UInt64</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ctypes"><code>ctypes</code></a></li></ol>
      </details>
  </li>
  <li class="toggle">
      <details>
        <summary>Examples</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Add_to_iPhoto">Add to iPhoto</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_C_structs_and_pointers">Using C struct and pointers</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_COM_from_js-ctypes">Using COM from js-ctypes</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes">Using Objective-C from js-ctypes</a></li></ol>
      </details>
  </li>
 </ol>
</section>

<div><div class="draft notecard">
    <p><strong>Draft</strong><br>
    This page is not complete.</p>

</div></div>

<p>A <code>CData</code> object represents a C value or function located in memory.</p>

<h2 id="Method_overview">Method overview</h2>

<h3 id="Methods_available_on_all_CData_objects">Methods available on all CData objects</h3>

<table class="standard-table">
 <tbody>
  <tr>
   <td><code><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CData" title="A CData object represents a C value or function located in memory."><code>CData</code></a> <a href="/en-US/docs/js-ctypes/js-ctypes_reference/CData#address()" title="js-ctypes/js-ctypes reference/CData#address()">address</a>()</code></td>
  </tr>
  <tr>
   <td><code>String <a href="/en-US/docs/js-ctypes/js-ctypes_reference/CData#toSource()" title="js-ctypes/js-ctypes reference/CData#toSource()">toSource</a>()</code></td>
  </tr>
  <tr>
   <td><code>String <a href="/en-US/docs/js-ctypes/js-ctypes_reference/CData#toString()" title="js-ctypes/js-ctypes reference/CData#toString()">toString</a>()</code></td>
  </tr>
 </tbody>
</table>

<h2 id="Properties">Properties</h2>

<h3 id="Properties_of_all_CData_objects">Properties of all CData objects</h3>

<table class="standard-table" style="width: auto;">
 <tbody>
  <tr>
   <td class="header">Property</td>
   <td class="header">Type</td>
   <td class="header">Description</td>
  </tr>
  <tr>
   <td><code>constructor</code></td>
   <td><a href="/en-US/docs/js-ctypes/js-ctypes_reference/CType" title="js-ctypes/js-ctypes reference/CType"><code>CType</code></a></td>
   <td>
    <p>The data type of the <code>CData</code> object, as a <a href="/en-US/docs/js-ctypes/js-ctypes_reference/CType" title="js-ctypes/js-ctypes reference/CType"><code>CType</code></a>. <strong>Read only.</strong></p>

    <div class="note"><strong>Note:</strong> This is never <code>ctypes.void_t</code> or an array type with an unspecified length.</div>
   </td>
  </tr>
  <tr>
   <td><code>value</code></td>
   <td>object</td>
   <td>The JavaScript equivalent of the <code>CData</code> object&apos;s value. This will throw a <code>TypeError</code> exception if the value can&apos;t be converted.</td>
  </tr>
 </tbody>
</table>

<h2 id="Methods_available_on_all_CData_objects_2">Methods available on all CData objects</h2>

<h3 id="address">address()</h3>

<p>Returns a <code>CData</code> object of the pointer type <code>ctypes.PointerType(<em>dataObject</em>.constructor)</code> whose value points to the C object referred to by the object. This provides a way to get a pointer to the actual data of the C value represented by the <code>CData</code> object.</p>

<pre>CData address()
</pre>

<h6 id="Parameters">Parameters</h6>

<p>None.</p>

<h6 id="Return_value">Return value</h6>

<p>A <code>CData</code> object of the pointer type <code>ctypes.PointerType(<em>dataObject</em>.constructor)</code> whose value points to the C object referred to by the object.</p>

<h3 id="toSource">toSource()</h3>

<p>Returns the string &quot;<em>t</em>(<em>arg</em>)&quot;, where <em>t</em> and <em>arg</em> are implementation-defined JavaScript expressions intended to represent the type of the CData object and its value, respectively.</p>

<pre>String toSource()
</pre>

<h6 id="Parameters_2">Parameters</h6>

<p>None.</p>

<h6 id="Return_value_2">Return value</h6>

<p>A string that, ideally, should be able to be evaluated to produce a new <code>CData</code> object containing a copy of the original object. However, this only works if the object&apos;s type happens to be bound to an appropriate name in scope.</p>

<p>In theory, in other words, the following JavaScript expression should return a copy of the original <code>CData</code> object:</p>

<pre class="brush: js">eval(dataObject.toSource());
</pre>

<h3 id="toString">toString()</h3>

<p>Returns a string identifying the data.</p>

<pre class="language-html"><code class="language-html">String toString();</code></pre>

<div class="line-number" style="top: 0px;"> </div>

<h6 id="Parameters_3">Parameters</h6>

<p>None.</p>

<h6 id="Return_value_3">Return value</h6>

<p>A string identifying the data.</p>

<h2 id="Methods_available_on_string_objects">Methods available on string objects</h2>

<p>These methods must be called on objects that are arrays or pointers to 8-bit or 16-bit character or integer types, terminated by a null character.</p>

<h3 id="readString">readString()</h3>

<p>Converts a character array to a JavaScript string.  8-bit strings are assumed to be encoded as UTF-8.</p>

<p>If the 8-bit string contains invalid encoded character, a TypeError exception is thrown.</p>

<pre>String readString();
</pre>

<h6 id="Parameters_4">Parameters</h6>

<p>None.</p>

<h6 id="Return_value_4">Return value</h6>

<p>A new <code>String</code> object that is a copy of the original string contents.</p>

<h3 id="readStringReplaceMalformed">readStringReplaceMalformed()</h3>

<p>Converts a character array to a JavaScript string.  8-bit strings are assumed to be encoded as UTF-8.</p>

<p>If the 8-bit string contains invalid encoded character, no exception is thrown.</p>

<pre>String readStringReplaceMalformed();
</pre>

<h6 id="Parameters_5">Parameters</h6>

<p>None.</p>

<h6 id="Return_value_5">Return value</h6>

<p>A new <code>String</code> object that is a copy of the original string contents. Invalid encoded characters will be replaced by �(U+FFFD).</p>

<div class="note">
<h4 id="Here_is_a_method_to_read_malformed_it_attempts_to_do_readString_on_it_if_it_errors_then_it_tries_to_read_it_in_another_way_so_this_is_an_alternative_to_readStringReplaceMalformed_it_is_an_attempt_at_readingMalformed">Here is a method to read &quot;malformed&quot;, it attempts to do readString on it, if it errors then it tries to read it in another way, so this is an alternative to readStringReplaceMalformed, it is an attempt at readingMalformed</h4>

<pre class="brush: js">function readAsChar8ThenAsChar16(stringPtr, known_len, jschar) {
    // when reading as jschar it assumes max length of 500

    // stringPtr is either char or jschar, if you know its jschar for sure, pass 2nd arg as true
    // if known_len is passed, then assumption is not made, at the known_len position in array we will see a null char
    // i tried getting known_len from stringPtr but its not possible, it has be known, i tried this:
        //&quot;stringPtr.contents.toString()&quot; &quot;95&quot;
        //&quot;stringPtr.toString()&quot; &quot;ctypes.unsigned_char.ptr(ctypes.UInt64(&quot;0x7f73d5c87650&quot;))&quot;
        // so as we see neither of these is 77, this is for the example of &quot;_scratchpad/EnTeHandle.js at master · Noitidart/_scratchpad - Mozilla Firefox&quot;

    // tries to do read string on stringPtr, if it fails then it falls to read as jschar

    var readJSCharString = function() {
        var assumption_max_len = known_len ? known_len : 500;
        var ptrAsArr = ctypes.cast(stringPtr, ctypes.unsigned_char.array(assumption_max_len).ptr).contents; // MUST cast to unsigned char (not ctypes.jschar, or ctypes.char) as otherwise i dont get foreign characters, as they are got as negative values, and i should read till i find a 0 which is null terminator which will have unsigned_char code of 0 // can test this by reading a string like this: &quot;_scratchpad/EnTeHandle.js at master · Noitidart/_scratchpad - Mozilla Firefox&quot; at js array position 36 (so 37 if count from 1), we see 183, and at 77 we see char code of 0 IF casted to unsigned_char, if casted to char we see -73 at pos 36 but pos 77 still 0, if casted to jschar we see chineese characters in all spots expect spaces even null terminator is a chineese character
        console.info(&apos;ptrAsArr.length:&apos;, ptrAsArr.length);
        //console.log(&apos;debug-msg :: dataCasted:&apos;, dataCasted, uneval(dataCasted), dataCasted.toString());
        var charCode = [];
        var fromCharCode = []
        for (var i=0; i&lt;ptrAsArr.length; i++) { //if known_len is correct, then will not hit null terminator so like in example of &quot;_scratchpad/EnTeHandle.js at master · Noitidart/_scratchpad - Mozilla Firefox&quot; if you pass length of 77, then null term will not get hit by this loop as null term is at pos 77 and we go till `&lt; known_len`
            var thisUnsignedCharCode = ptrAsArr.addressOfElement(i).contents;
            if (thisUnsignedCharCode == 0) {
                // reached null terminator, break
                console.log(&apos;reached null terminator, at pos: &apos;, i);
                break;
            }
            charCode.push(thisUnsignedCharCode);
            fromCharCode.push(String.fromCharCode(thisUnsignedCharCode));
        }
        console.info(&apos;charCode:&apos;, charCode);
        console.info(&apos;fromCharCode:&apos;, fromCharCode);
        var char16_val = fromCharCode.join(&apos;&apos;);
        console.info(&apos;char16_val:&apos;, char16_val);
        return char16_val;
    }

    if (!jschar) {
        try {
            var char8_val = stringPtr.readString();
            console.info(&apos;stringPtr.readString():&apos;, char8_val);
            return char8_val;
        } catch (ex if ex.message.indexOf(&apos;malformed UTF-8 character sequence at offset &apos;) == 0) {
            console.warn(&apos;ex of offset utf8 read error when trying to do readString so using alternative method, ex:&apos;, ex);
            return readJSCharString();
        }
    } else {
        return readJSCharString();
    }
}</pre>
</div>

<h2 id="See_also">See also</h2>

<ul>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_data" title="Working with data">Working with data</a></li>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ArrayType" title="ArrayType represents C arrays"><code>ArrayType</code></a></li>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/FunctionType" title="The documentation about this has not yet been written; please consider contributing!"><code>FunctionType</code></a></li>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/PointerType" title="Returns a new CType object describing a new pointer data type."><code>PointerType</code></a></li>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/StructType" title="Returns a CType object describing a new structure data type. This data type provides the ability to define and manipulate values of the C struct type."><code>StructType</code></a></li>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Type_conversion">Type conversion</a></li>
</ul>
