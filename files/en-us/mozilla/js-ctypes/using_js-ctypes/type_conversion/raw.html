<section class="Quick_links" id="Quick_Links">
 <ol>
  <li><a href="/en-US/docs/Mozilla/js-ctypes"><strong><em>js-ctypes</em></strong></a></li>
  <li class="toggle">
      <details open>
        <summary>Introduction</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Debugging_Tips" title="Editorial review completed.">Debugging Tips</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_calling_functions" title="Functions are declared using the Library object's declare() method. Once declared, functions can be called using standard function syntax.">Declaring and Calling Functions</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_Using_Callbacks" title="C functions occasionally take function pointers as arguments, which are generally used as callbacks. In these cases, js-ctypes allows you to pass a regular JavaScript function as the callback. This is very powerful, since it allows native code to transparently call into JavaScript.">Declaring and Using Callbacks</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_types" title="The ctypes object offers a number of constructor methods that let you declare types. Every type is represented by a CType object, which, in turn, provides a constructor method you can call to define values of those types. Each type you declare using js-ctypes corresponds to a compatible C declaration.">Declaring types</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Memory_Management" title="If JS code creates a structure or an array, that memory will be valid as long as the JS object stays alive. Pointers to that memory must be carefully managed to make sure the underlying memory is still referenced.">Memory Management</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Standard_OS_Libraries" title="This article gives the names of standard libraries that can be accessed with js-ctypes. These libraries are what enable js-ctypes to work. The alternative to standard libraries is creating your own DLL (for Windows) or SO (for Linux) file with C functions that can be called from your add-on with js-ctypes. The DLL/SO/etc file you make must be shipped with your add-on. Standard libraries offer the advantage of not having to ship anything. They are already available on the operating system for you. You just need to supply the path to appropriate files and set up the proper types of values/arguments in the js-ctypes code. This article allows you to find out what types to give to values/arguments by supplying links to the documentation of the OS libraries.">Standard OS Libraries</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Type_conversion" title="In js-ctypes, data could be converted implicitly when passing to or returning from a FunctionType call, or setting pointer content, an array element or a struct field.">Type conversion</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_ArrayBuffers" title="An ArrayBuffer is a simply byte array. The js-ctypes equivalent is a ctypes.uint8_t.array(###) (ctypes.unsigned_char are also ctypes.uint8_t).">Working with ArrayBuffers</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_data" title="Data types for use with js-ctypes are represented by CType objects. These are JavaScript constructors; as such, they're callable functions that you can use to create new CData objects of that type. There are several ways you can go about creating new CData objects.">Working with data</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/ctypes.open" title="At the heart of js-ctypes is the ctypes.open() function. This must be called before any work can commence. There are two options:">ctypes.open</a></li></ol>
      </details>
  </li>
  <li class="toggle">
      <details>
        <summary>References</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ABI" title="This article describes the calling conventions with respect to js-ctypes while programming x86 and x86-64/x64/AMD64 architectures. A calling convention is an implementation-level (low-level) scheme regarding how subroutines receive parameters from their caller and how they revert."><code>ABI</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ArrayType" title="ArrayType represents C arrays"><code>ArrayType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CData" title="A CData object represents a C value or function located in memory."><code>CData</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CType" title="All data types declared using the js-ctypes API are represented by CType objects. These objects have assorted methods and properties that let you create objects of these types, find out information about them, and so forth. The specific properties and methods on each object vary depending on the data type represented."><code>CType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/FunctionType" title=""><code>FunctionType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Int64" title="Because JavaScript doesn't currently include standard support for 64-bit integer values, js-ctypes offers the Int64 and UInt64 objects to let you work with C functions and data that need (or may need) values represented using a 64-bit data type."><code>Int64</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Library" title="The Library object represents a native library loaded by the ctypes open() method. Its methods let you declare symbols exported by the library, and to manage the library."><code>Library</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/PointerType" title="Returns a new CType object describing a new pointer data type."><code>PointerType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/StructType" title="Returns a CType object describing a new structure data type. This data type provides the ability to define and manipulate values of the C struct type."><code>StructType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/UInt64" title="As JavaScript doesn't currently include standard support for 64-bit integer values, js-ctypes offers the Int64 and UInt64 objects to let you work with C functions and data that need (or may need) to use data represented using a 64-bit data type."><code>UInt64</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ctypes" title="The ctypes object contains methods and predefined data types used to create and manage a library."><code>ctypes</code></a></li></ol>
      </details>
  </li>
  <li class="toggle">
      <details>
        <summary>Examples</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Add_to_iPhoto" title="This extension for Mac OS X serves as a demonstration of how to use js-ctypes to call Mac OS X Carbon, Core Foundation, and other system frameworks from an extension written entirely in JavaScript.">Add to iPhoto</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_C_structs_and_pointers" title="In this example, we show how to use C structs and pointers with js-ctypes.">Using C struct and pointers</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_COM_from_js-ctypes" title="The Windows API mostly concerns itself with the interaction between the operating system and an application. For communication between the different Windows applications among themselves, Microsoft has developed a series of technologies alongside the main Windows API. This started out with Dynamic Data Exchange (DDE), which was superseded by Object Linking and Embedding (OLE) and later by the Component Object Model (COM), Automation Objects, ActiveX controls, and the .NET Framework.">Using COM from js-ctypes</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes" title="Objective-C has its own syntax, it cannot be written directly with js-ctypes. This guide explains how to convert Objective-C code into js-ctypes code.">Using Objective-C from js-ctypes</a></li></ol>
      </details>
  </li>
 </ol>
</section>

<h2 id="Implicit_convert">Implicit convert</h2>

<p>In js-ctypes, data could be converted implicitly when passing to or returning from a FunctionType call, or setting pointer content, an array element or a struct field.</p>

<pre class="brush: js">var buffer = ctypes.char.array(10)();

var someCFunction = library.declare("someCFunction", ctypes.default_abi, ctypes.void_t, ctypes.char.ptr);

someCFunction(buffer); // here ctypes.char.array(10)() is converted to ctypes.char.ptr type
</pre>

<p>Implicit conversion can be tested in the following way:</p>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.bool }
])();
myStruct.v = 1;
console.log(myStruct.v.toString()); // 'true'
</pre>

<h3 id="Boolean_type">Boolean type</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td rowspan="2"><code>ctypes.bool</code></td>
   <td>JS boolean</td>
   <td><code>src</code></td>
  </tr>
  <tr>
   <td>JS number<br>
    (<code>0</code> or <code>1</code>)</td>
   <td><code>if src == 0: false</code><br>
    <code>if src == 1: true</code></td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.bool }
])();

myStruct.v = true;
console.log(myStruct.v.toString()); // 'true'
myStruct.v = false;
console.log(myStruct.v.toString()); // 'false'
myStruct.v = 1;
console.log(myStruct.v.toString()); // 'true'
myStruct.v = 0;
console.log(myStruct.v.toString()); // 'false'

myStruct.v = 10;         // throws Error
myStruct.v = "a";        // throws Error
</pre>

<h3 id="Integer_types">Integer types</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td><code>ctypes.char16_t</code></td>
   <td>JS string<br>
    (only if its length == 1)</td>
   <td><code>src.charCodeAt(0)</code></td>
  </tr>
  <tr>
   <td rowspan="2">any integer types</td>
   <td>JS number<br>
    (only if fits to the size)</td>
   <td><code>src</code></td>
  </tr>
  <tr>
   <td>JS boolean</td>
   <td><code>if src == true: 1</code><br>
    <code>if src == false: 0</code></td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.char16_t }
])();

myStruct.v = 0x41;
console.log(myStruct.v.toString()); // "A"
myStruct.v = true;
console.log(myStruct.v.toString()); // "\x01"
myStruct.v = "X";
console.log(myStruct.v.toString()); // "X"

myStruct.v = "XX";                  // throws Error
</pre>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.int16_t }
])();

myStruct.v = 0x41;
console.log(myStruct.v.toString()); // 65
myStruct.v = true;
console.log(myStruct.v.toString()); // 1

myStruct.v = "X";                   // throws Error
</pre>

<p>Integer/float types are implicitly convertible if any data of source type could be representable in the target type.</p>

<p>Note that the following table does not contain environment dependent types (<code>ctypes.long</code>, etc.).</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source Type</th>
  </tr>
  <tr>
   <td rowspan="3"><code>ctypes.int16_t</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.short</code></td>
  </tr>
  <tr>
   <td rowspan="2"><code>ctypes.uint16_t</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td rowspan="3"><code>ctypes.short</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t</code></td>
  </tr>
  <tr>
   <td rowspan="2"><code>ctypes.unsigned_short</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td rowspan="7"><code>ctypes.int32_t</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int</code></td>
  </tr>
  <tr>
   <td rowspan="4"><code>ctypes.uint32_t</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_int</code></td>
  </tr>
  <tr>
   <td rowspan="7"><code>ctypes.int</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int32_t</code></td>
  </tr>
  <tr>
   <td rowspan="4"><code>ctypes.unsigned_int</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t</code></td>
  </tr>
  <tr>
   <td rowspan="11"><code>ctypes.int64_t</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.long_long</code></td>
  </tr>
  <tr>
   <td rowspan="6"><code>ctypes.uint64_t</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_long_long</code></td>
  </tr>
  <tr>
   <td rowspan="11"><code>ctypes.long_long</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int64_t</code></td>
  </tr>
  <tr>
   <td rowspan="6"><code>ctypes.unsigned_long_long</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint64_t</code></td>
  </tr>
  <tr>
   <td rowspan="6"><code>ctypes.float32_t</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td rowspan="11"><code>ctypes.float64_t</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_int</code></td>
  </tr>
  <tr>
   <td><code>ctypes.float32_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.char</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.signed_char</code></td>
   <td><code>ctypes.int8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_char</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td rowspan="3"><code>ctypes.char16_t</code></td>
   <td><code>ctypes.uint8_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_short</code></td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.int16_t }
])();

myStruct.v = ctypes.int8_t(10);
console.log(myStruct.v.toString()); // 10

myStruct.v = ctypes.int32_t(10);    // throws Error
</pre>

<h3 id="Float_types">Float types</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td>any float types</td>
   <td>JS number<br>
    (only if fits to the size)</td>
   <td><code>src</code></td>
  </tr>
 </tbody>
</table>

<h3 id="Pointer_types">Pointer types</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td>any pointer types</td>
   <td><code>null</code></td>
   <td><code>nullptr</code></td>
  </tr>
  <tr>
   <td rowspan="2"><code>ctypes.voidptr_t</code></td>
   <td>any pointer types</td>
   <td><code>src</code></td>
  </tr>
  <tr>
   <td>any array types</td>
   <td><code>src.addressOfElement(0)</code></td>
  </tr>
  <tr>
   <td rowspan="2"><code>ctypes.PointerType(T)</code></td>
   <td><code>ctypes.ArrayType(T)</code></td>
   <td><code>src.addressOfElement(0)</code></td>
  </tr>
  <tr>
   <td><code>ctypes.ArrayType(T, N)</code></td>
   <td><code>src.addressOfElement(0)</code></td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.int16_t.ptr }
])();

myStruct.v = ctypes.int16_t.array(10)();
console.log(myStruct.v.toString());      // 'ctypes.int16_t.ptr(ctypes.UInt64("0x11d6ff400"))'
myStruct.v = null;
console.log(myStruct.v.toString());      // 'ctypes.int16_t.ptr(ctypes.UInt64("0x0"))'

myStruct.v = ctypes.int32_t.array(10)(); // throws Error
</pre>

<p>Only in <code>FunctionType</code> argument, the following rules are also applied:</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td><code>ctypes.char.ptr</code></td>
   <td rowspan="3">JS string</td>
   <td rowspan="3">pointer to temporary allocated null-terminated UTF8 string</td>
  </tr>
  <tr>
   <td><code>ctypes.signed_char.ptr</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_char.ptr</code></td>
  </tr>
  <tr>
   <td><code>ctypes.char16.ptr</code></td>
   <td>JS string</td>
   <td>pointer to temporary allocated null-terminated UTF16 string</td>
  </tr>
  <tr>
   <td>any pointer types</td>
   <td>any ArrayBuffer object</td>
   <td>pointer to the ArrayBuffer</td>
  </tr>
  <tr>
   <td><code>ctypes.voidptr_t</code></td>
   <td rowspan="2">any TypedArray/DataView object</td>
   <td rowspan="2">pointer to the TypedArray/DataView</td>
  </tr>
  <tr>
   <td><code>ctypes.char.ptr</code></td>
  </tr>
  <tr>
   <td><code>ctypes.int8_t.ptr</code></td>
   <td>Int8Array</td>
   <td>pointer to the Int8Array</td>
  </tr>
  <tr>
   <td rowspan="2"><code>ctypes.uint8_t.ptr</code></td>
   <td>UInt8Array</td>
   <td>pointer to the UInt8Array</td>
  </tr>
  <tr>
   <td>UIntClamped8Array</td>
   <td>pointer to the UIntClamped8Array</td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t.ptr</code></td>
   <td>Int16Array</td>
   <td>pointer to the Int16Array</td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t.ptr</code></td>
   <td>UInt16Array</td>
   <td>pointer to the UInt16Array</td>
  </tr>
  <tr>
   <td><code>ctypes.int32_t.ptr</code></td>
   <td>Int32Array</td>
   <td>pointer to the Int32Array</td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t.ptr</code></td>
   <td>UInt32Array</td>
   <td>pointer to the UInt32Array</td>
  </tr>
  <tr>
   <td><code>ctypes.float32_t.ptr</code></td>
   <td>Float32Array</td>
   <td>pointer to the Float32Array</td>
  </tr>
  <tr>
   <td><code>ctypes.float64_t.ptr</code></td>
   <td>Float64Array</td>
   <td>pointer to the Float64Array</td>
  </tr>
 </tbody>
</table>

<p><a id="AnchorFor_WorkingWithArrayBuffers_JumpToExample" name="AnchorFor_WorkingWithArrayBuffers_JumpToExample"></a></p>

<pre class="brush: js">var myFuncType = ctypes.FunctionType(ctypes.default_abi, ctypes.void_t, [ctypes.int16_t.ptr]);
var myFunc = myFuncType.ptr(function(v) { console.log(v.toString()); });

myFunc(Int16Array([1, 2, 3])); // 'ctypes.int16_t.ptr(ctypes.UInt64("0x103b7fe60"))'
myFunc(Int32Array([1, 2, 3])); // throws Error
</pre>

<pre class="brush: js">var myFuncType = ctypes.FunctionType(ctypes.default_abi, ctypes.void_t, [ctypes.char.ptr]);
var myFunc = myFuncType.ptr(function(v) { console.log(v.toString()); });

myFunc("abcde");               // 'ctypes.char.ptr(ctypes.UInt64("0x101d1d680"))'
myFunc(Int32Array([1, 2, 3])); // 'ctypes.char.ptr(ctypes.UInt64("0x103b7ffe0"))'
</pre>

<h3 id="Array_types">Array types</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td><code>ctypes.char.array(N)</code></td>
   <td rowspan="3">JS string<br>
    (only if UTF8 representation fits to the array)</td>
   <td rowspan="3">null-terminated UTF8 string</td>
  </tr>
  <tr>
   <td><code>ctypes.signed_char.array(N)</code></td>
  </tr>
  <tr>
   <td><code>ctypes.unsigned_char.array(N)</code></td>
  </tr>
  <tr>
   <td><code>ctypes.char16_t.array(N)</code></td>
   <td>JS string<br>
    (only if fits to the array)</td>
   <td>null-terminated UTF16 string</td>
  </tr>
  <tr>
   <td>any array types</td>
   <td>JS array<br>
    (only if array length is same)</td>
   <td>convert each element implicitly</td>
  </tr>
  <tr>
   <td>any array types</td>
   <td>any ArrayBuffer object<br>
    (only if array length is same in bytes)</td>
   <td rowspan="12">copy data</td>
  </tr>
  <tr>
   <td><code>ctypes.int8_t.array(N)</code></td>
   <td>Int8Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td rowspan="2"><code>ctypes.uint8_t.array(N)</code></td>
   <td>UInt8Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td>UIntClamped8Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td><code>ctypes.int16_t.array(N)</code></td>
   <td>Int16Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td><code>ctypes.uint16_t.array(N)</code></td>
   <td>UInt16Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td><code>ctypes.int32_t.array(N)</code></td>
   <td>Int32Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td><code>ctypes.uint32_t.array(N)</code></td>
   <td>UInt32Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td><code>ctypes.float32_t.array(N)</code></td>
   <td>Float32Array<br>
    (only if array length is same in bytes)</td>
  </tr>
  <tr>
   <td><code>ctypes.float64_t.array(N)</code></td>
   <td>Float64Array<br>
    (only if array length is same in bytes)</td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.int16_t.array(5) }
])();

myStruct.v = [1, 2, 3, 4, 5];
console.log(myStruct.v.toString()); // 'ctypes.int16_t.array(5)([0, 0, 0, 0, 0])'
myStruct.v = Int16Array([1, 2, 3, 4, 5]);
console.log(myStruct.v.toString()); // 'ctypes.int16_t.array(5)([1, 2, 3, 4, 5])'

myStruct.v = [1, 2, 3, 4];          // throws Error
</pre>

<pre class="brush: js">var myStruct = ctypes.StructType("myStructType", [
  { "v": ctypes.char.array(5) }
])();

myStruct.v = "abcde";
console.log(myStruct.v.toString()); // 'ctypes.char.array(5)([97, 98, 99, 100, 101])'
myStruct.v = "abc";
console.log(myStruct.v.toString()); // 'ctypes.char.array(5)([97, 98, 99, 0, 0])'

myStruct.v = myStruct.v = "abcdef"; // throws Error
</pre>

<h3 id="Struct_types">Struct types</h3>

<p>JS object can be converted into struct type:</p>

<pre class="brush: js">var POINT = ctypes.StructType("POINT", [
  { x: ctypes.int32_t },
  { y: ctypes.int32_t },
]);

var myStruct = ctypes.StructType("myStructType", [
  { "v": POINT }
])();

myStruct.v = {
  x: 10,
  y: 20
};
console.log(myStruct.v.toString()); // 'POINT(10, 20)'

myStruct.v = {
  x: 10
};                                  // throws Error

myStruct.v = {
  x: 10,
  y: 20,
  z: 30
};                                  // throws Error

myStruct.v = {
  x: 10,
  z: 10
};                                  // throws Error
</pre>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td>any struct types</td>
   <td>JS object<br>
    (Only if the object has properties for all fields and no other properties)</td>
   <td>implicitly convert each enumerable property to corresponding field</td>
  </tr>
 </tbody>
</table>

<h2 id="Explicit_convert">Explicit convert</h2>

<p>In js-ctypes, data could be converted explicitly, when passing to CData constructor:</p>

<pre class="brush: js">ctypes.int32_t("123"); // string "123" is parsed as 10-base string
</pre>

<p>Explicit convert tries implicit convert first, and if it fails, the following rules are applied:</p>

<h3 id="Boolean_type_2">Boolean type</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td rowspan="2"><code>ctype.bool</code></td>
   <td>JS value</td>
   <td><code>ToBoolean(src)</code></td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">console.log(ctypes.bool("123").toString()); // 'ctypes.bool(true)'
console.log(ctypes.bool("").toString());    // 'ctypes.bool(false)'
</pre>

<h3 id="Integer_types_2">Integer types</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td rowspan="8">any integer types</td>
   <td>JS number except <code>-Infinity</code>, <code>Infinity</code>, <code>NaN</code></td>
   <td>C-style cast</td>
  </tr>
  <tr>
   <td><code>-Infinity</code></td>
   <td rowspan="3"><code>0</code></td>
  </tr>
  <tr>
   <td><code>Infinity</code></td>
  </tr>
  <tr>
   <td><code>NaN</code></td>
  </tr>
  <tr>
   <td><code>ctypes.Int64</code></td>
   <td rowspan="2">C-style cast</td>
  </tr>
  <tr>
   <td><code>ctypes.UInt64</code></td>
  </tr>
  <tr>
   <td>JS string with base-10 or base-16 string<br>
    (only if fits to the size)</td>
   <td>parse <code>src</code> as base-10 or base-16 string</td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">console.log(ctypes.int32_t(Infinity).toString());         // 'ctypes.int32_t(0)'
console.log(ctypes.int32_t("0xff").toString()));          // 'ctypes.int32_t(255)'
console.log(ctypes.int32_t(ctypes.Int64(10)).toString()); // 'ctypes.int32_t(10)'
</pre>

<h3 id="Pointer_types_2">Pointer types</h3>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Target Type</th>
   <th>Source</th>
   <th>Converted value</th>
  </tr>
  <tr>
   <td rowspan="2">any pointer types</td>
   <td>JS number<br>
    (only if fits to the pointer size)</td>
   <td>C-style cast</td>
  </tr>
  <tr>
   <td><code>ctypes.Int64</code><br>
    (only if fits to the pointer size)</td>
   <td>C-style cast</td>
  </tr>
 </tbody>
</table>

<pre class="brush: js">console.log(ctypes.int32_t.ptr(0xfffffffff).toString()); // 'ctypes.int32_t.ptr(ctypes.UInt64("0xfffffffff"))'
</pre>

<h2 id="See_Also">See Also</h2>

<ul>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_ArrayBuffers">Working with ArrayBuffers</a></li>
</ul>