<section class="Quick_links" id="Quick_Links">
 <ol>
  <li><a href="/en-US/docs/Mozilla/js-ctypes"><strong><em>js-ctypes</em></strong></a></li>
  <li class="toggle">
      <details open>
        <summary>Introduction</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Debugging_Tips" title="Editorial review completed.">Debugging Tips</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_calling_functions" title="Functions are declared using the Library object's declare() method. Once declared, functions can be called using standard function syntax.">Declaring and Calling Functions</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_Using_Callbacks" title="C functions occasionally take function pointers as arguments, which are generally used as callbacks. In these cases, js-ctypes allows you to pass a regular JavaScript function as the callback. This is very powerful, since it allows native code to transparently call into JavaScript.">Declaring and Using Callbacks</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_types" title="The ctypes object offers a number of constructor methods that let you declare types. Every type is represented by a CType object, which, in turn, provides a constructor method you can call to define values of those types. Each type you declare using js-ctypes corresponds to a compatible C declaration.">Declaring types</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Memory_Management" title="If JS code creates a structure or an array, that memory will be valid as long as the JS object stays alive. Pointers to that memory must be carefully managed to make sure the underlying memory is still referenced.">Memory Management</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Standard_OS_Libraries" title="This article gives the names of standard libraries that can be accessed with js-ctypes. These libraries are what enable js-ctypes to work. The alternative to standard libraries is creating your own DLL (for Windows) or SO (for Linux) file with C functions that can be called from your add-on with js-ctypes. The DLL/SO/etc file you make must be shipped with your add-on. Standard libraries offer the advantage of not having to ship anything. They are already available on the operating system for you. You just need to supply the path to appropriate files and set up the proper types of values/arguments in the js-ctypes code. This article allows you to find out what types to give to values/arguments by supplying links to the documentation of the OS libraries.">Standard OS Libraries</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Type_conversion" title="In js-ctypes, data could be converted implicitly when passing to or returning from a FunctionType call, or setting pointer content, an array element or a struct field.">Type conversion</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_ArrayBuffers" title="An ArrayBuffer is a simply byte array. The js-ctypes equivalent is a ctypes.uint8_t.array(###) (ctypes.unsigned_char are also ctypes.uint8_t).">Working with ArrayBuffers</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Working_with_data" title="Data types for use with js-ctypes are represented by CType objects. These are JavaScript constructors; as such, they're callable functions that you can use to create new CData objects of that type. There are several ways you can go about creating new CData objects.">Working with data</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/ctypes.open" title="At the heart of js-ctypes is the ctypes.open() function. This must be called before any work can commence. There are two options:">ctypes.open</a></li></ol>
      </details>
  </li>
  <li class="toggle">
      <details>
        <summary>References</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ABI" title="This article describes the calling conventions with respect to js-ctypes while programming x86 and x86-64/x64/AMD64 architectures. A calling convention is an implementation-level (low-level) scheme regarding how subroutines receive parameters from their caller and how they revert."><code>ABI</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ArrayType" title="ArrayType represents C arrays"><code>ArrayType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CData" title="A CData object represents a C value or function located in memory."><code>CData</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/CType" title="All data types declared using the js-ctypes API are represented by CType objects. These objects have assorted methods and properties that let you create objects of these types, find out information about them, and so forth. The specific properties and methods on each object vary depending on the data type represented."><code>CType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/FunctionType" title=""><code>FunctionType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Int64" title="Because JavaScript doesn't currently include standard support for 64-bit integer values, js-ctypes offers the Int64 and UInt64 objects to let you work with C functions and data that need (or may need) values represented using a 64-bit data type."><code>Int64</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/Library" title="The Library object represents a native library loaded by the ctypes open() method. Its methods let you declare symbols exported by the library, and to manage the library."><code>Library</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/PointerType" title="Returns a new CType object describing a new pointer data type."><code>PointerType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/StructType" title="Returns a CType object describing a new structure data type. This data type provides the ability to define and manipulate values of the C struct type."><code>StructType</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/UInt64" title="As JavaScript doesn't currently include standard support for 64-bit integer values, js-ctypes offers the Int64 and UInt64 objects to let you work with C functions and data that need (or may need) to use data represented using a 64-bit data type."><code>UInt64</code></a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/js-ctypes_reference/ctypes" title="The ctypes object contains methods and predefined data types used to create and manage a library."><code>ctypes</code></a></li></ol>
      </details>
  </li>
  <li class="toggle">
      <details>
        <summary>Examples</summary>
        <ol><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Add_to_iPhoto" title="This extension for Mac OS X serves as a demonstration of how to use js-ctypes to call Mac OS X Carbon, Core Foundation, and other system frameworks from an extension written entirely in JavaScript.">Add to iPhoto</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_C_structs_and_pointers" title="In this example, we show how to use C structs and pointers with js-ctypes.">Using C struct and pointers</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_COM_from_js-ctypes" title="The Windows API mostly concerns itself with the interaction between the operating system and an application. For communication between the different Windows applications among themselves, Microsoft has developed a series of technologies alongside the main Windows API. This started out with Dynamic Data Exchange (DDE), which was superseded by Object Linking and Embedding (OLE) and later by the Component Object Model (COM), Automation Objects, ActiveX controls, and the .NET Framework.">Using COM from js-ctypes</a></li><li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes" title="Objective-C has its own syntax, it cannot be written directly with js-ctypes. This guide explains how to convert Objective-C code into js-ctypes code.">Using Objective-C from js-ctypes</a></li></ol>
      </details>
  </li>
 </ol>
</section>

<p>This article gives the names of standard libraries that can be accessed with js-ctypes. These libraries are what enable js-ctypes to work. The alternative to standard libraries is creating your own DLL (for Windows) or SO (for Linux) file with C functions that can be called from your add-on with js-ctypes. The DLL/SO/etc file you make must be shipped with your add-on. Standard libraries offer the advantage of not having to ship anything. They are already available on the operating system for you. You just need to supply the path to appropriate files and set up the proper types of values/arguments in the js-ctypes code. This article allows you to find out what types to give to values/arguments by supplying links to the documentation of the OS libraries.</p>

<h2 id="Windows">Windows</h2>

<p>Windows has many Standard OS Libraries. The most common, found on all Windows OS version, is "WinAPI". Windows also has the "WinAPILists" and ".NET Framework" (I'm not sure if it can be accessed JSCtypes but probably). A complete list of Windows APIs can be found at the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh920508%28vs.85%29.aspx">MSDN API Index</a>.</p>

<h3 id="WinAPI">WinAPI</h3>

<p>This is the one that is most commonly used by js-ctypes. This comes shipped by default with all installations of Windows operating systems since Win98. It's also known as WinAPI32 or just WinAPI. A list of all the functions available through this API can be found at the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516%28v=vs.85%29.aspx">MSDN WinAPI Index</a>. For finding out the values and types of arguments and returns of the functions you want to use from this API, you must visit the functions page on this linked MSDN site; it will give you all that information.</p>

<h4 id="Example_GetCursorPos">Example: GetCursorPos</h4>

<p>I wanted to get the mouse cursor position without using a MouseMove listener, as this is a high overhead event listener. So I went to the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516%28v=vs.85%29.aspx">MSDN WinAPI Index</a> page and then went to the "Cursors" category and came across GetCursorPos. I then searched it on MSDN and saw that it needed the user32.dll. (<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms648390%28v=vs.85%29.aspx" title="http://msdn.microsoft.com/en-us/library/windows/desktop/ms648390%28v=vs.85%29.aspx">MSDN - GetCursorPos</a>)</p>

<p>This example was created on Windows XP SP2. It is a full working example; just copy &amp; paste it to try it out.</p>

<pre class="brush: cpp">Components.utils.import("resource://gre/modules/ctypes.jsm");
var lib = ctypes.open("user32.dll");

/* note: if you go to GetCursorPos page on MSDN, it says first argument is of structure POINT, so lets create that structure,
 * the link here shows that that x and y are type Long which is ctypes.long
 */
// https://msdn.microsoft.com/en-us/library/windows/desktop/dd162805%28v=vs.85%29.aspx
var POINT = new ctypes.StructType("tagPOINT", [
  { "x": ctypes.long },
  { "y": ctypes.long }
]);

/* Declare the signature of the function we are going to call */
var GetCursorPos = lib.declare('GetCursorPos',
    ctypes.winapi_abi,
    ctypes.bool,
    POINT.ptr
);

/* Use it like this */
var point = POINT();
var ret = GetCursorPos(point.address());

Components.utils.reportError(ret);
Components.utils.reportError(point);

lib.close();
</pre>

<h4 id="Resources_for_WinAPI">Resources for WinAPI</h4>

<ul>
 <li><a href="https://gist.github.com/search?q=winapi+%40noitidart">GitHubGISTS :: Noitidart / Search · winapi</a> - WinAPI js-ctypes snippets that can be copied and pasted to scratchpad</li>
</ul>

<h3 id="COM">COM</h3>

<div class="note">
<p>See <a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_COM_from_js-ctypes">Using COM from js-ctypes</a>.</p>
</div>

<h2 id="UNIX">UNIX</h2>

<p>Unix based operating systems are Linux, *BSD, Solaris, etc. There is a star/asterik ("*") before "BSD" because this means the BSD family such as FreeBSD, OpenBSD (who by the way made ssh), NetBSD, etc.</p>

<p>GTK+ and Qt are graphic frameworks, the graphic stack under Unix is Xorg (X11/X). GTK+ builds over X11. Xorg is being re-written at the moment, it is known as Wayland. Wayland is not considered stable, but it's supposed to replace Xorg in the long term. GTK+ and Qt have begun porting their code to Wayland. As Wayland is not out yet in the wild this article does not focus on Wayland, it will focus on GTK+ and Xorg(X11/X).</p>

<p>GDK is a stack under GTK+. GTK+ is the toolkit to build apps, GDK is more low-level.</p>

<p>To be precise, X is "just" like a display machine. On top of which everybody uses "Window Managers" (known as "WM"s) such as fluxbox, i3, awesome, openbox, Mutter (used by Gnome 3), plasma (used by KDE) etc. Gnome and KDE are "Desktop Environments" (known as "DE"s). WMs on Ubuntu work a little differently but we'll revisit this topic later in this article (Did you know they have a *special* Firefox build for Ubuntu?). So DEs are a stack over WMs.</p>

<p>There is also a layer known as shell, GnomeShell is the shell used in Gnome 3, it is the outter shell.</p>

<p>GTK+ is the framework used under Firefox (and other Mozilla applications like Thunderbird). The other framework used in Unix systems is Qt. Firefox is officially supported only for GTK+ at the moment, therefore GTK+ is required for Firefox to run. Attempting to install Firefox on a a non-GTK+ based Linux build such as KaOSx, which is Qt based (details on KaOSx at the time of this writing: <span class="comment-copy">KDELibs version 4.1.4.3, Qt version 4.8.6, 64bit</span>) would install GTK+ libraries along with it in order to enable Firefox to work on the Qt system. There are rumors of a Firefox Qt that is in the works.</p>

<p>On Linux, libraries will be typically found as .so files. One library that Linux uses, and that can be used through js-ctypes, is X11.</p>

<h3 id="GDK">GDK</h3>

<p>As mentioned, all Firefox's are a GTK+ app, which means it has to have GDK, as GDK is underlying level of GTK+. Therefore all the GDK library functions are available for use. GDK has version 2 and 3, typically version 2 is referred to as just GDK and version 3 is referred to as GDK3. Examples for both are found below. Documentation for GDK functions are found here: <a href="https://developer.gnome.org/gdk2/stable/">GNOME Developer :: GDK 2 Reference Manual</a>. For GDK3 documentation is found here: <a href="https://developer.gnome.org/gdk3/stable/">GNOME Developer :: GDK 3 Reference Manual</a>. Because GNOME is in the name of the websites don't get confused and think this only works on GNOME. It is true though that GDK was developed by the GNOME team.</p>

<h4 id="Example_gdk_window_get_pointer">Example: gdk_window_get_pointer</h4>

<p>This example is fot the GDK 2.0 library. In GDK 3.0 the <code>gdk_window_get_device_position</code> function was deprecated, see below for GDK 3.0 example.</p>

<pre class="brush: js">Components.utils.import('resource://gre/modules/ctypes.jsm');

var gdk = ctypes.open('libgdk-x11-2.0.so.0');

// types
var gint = ctypes.int;
var GdkDevice = ctypes.StructType('GdkDevice');
var GdkModifierType = ctypes.int;
var GdkWindow = ctypes.StructType('GdkWindow');
var VOID = ctypes.void_t;

// https://developer.gnome.org/gdk3/stable/gdk3-Windows.html#gdk-get-default-root-window
var gdk_get_default_root_window = gdk.declare('gdk_get_default_root_window', ctypes.default_abi,
    GdkWindow.ptr    // return - the root window, which is top most parent of all windows
);

// in GDK2 we have to use gdk_window_get_pointer, but in GDK3 it was deprecated and have to use gdk_window_get_device_position
https://developer.gnome.org/gdk3/stable/gdk3-Windows.html#gdk-window-get-pointer
var gdk_window_get_pointer = gdk.declare('gdk_window_get_pointer', ctypes.default_abi,
    GdkWindow.ptr,        // return - the window containing the pointer (as with gdk_window_at_pointer()), or NULL if the window containing the pointer isn’t known to GDK.
    GdkWindow.ptr,        // window
    gint.ptr,            // x
    gint.ptr,            // y
    GdkModifierType.ptr    // mask
);

var winRoot_GdkWindowPtr = gdk_get_default_root_window();
console.info('winRoot_GdkWindowPtr:', winRoot_GdkWindowPtr, winRoot_GdkWindowPtr.toString());

// gdk2
var x = gint();
var y = gint();
var mask = GdkModifierType();
var win_underMouse = gdk_window_get_pointer(
    winRoot_GdkWindowPtr,
    x.address(),
    y.address(),
    mask.address()
);
console.info('win_underMouse:', win_underMouse, win_underMouse.toString());
console.info('x:', x, x.toString());
console.info('y:', y, y.toString());
console.info('mask:', mask, mask.toString());


gdk.close();</pre>

<h4 id="Example_gdk_window_get_device_position">Example: gdk_window_get_device_position</h4>

<p>This example works only for GDK3, as the function <code>gdk_window_get_device_position</code> was not available in GDK2, for GDK2 equivalent see above</p>

<div class="warning">
<p><em><strong>WARNING THIS EXAMPLE DOES NOT WORK YET IT NEEDS SOME BUG FIXING</strong></em></p>
</div>

<pre class="brush: js">Components.utils.import('resource://gre/modules/ctypes.jsm');
var gdk = ctypes.open('libgdk-x11-2.0.so.0');
var gdk3 = ctypes.open('libgdk-3.so.0');

// types
var gint = ctypes.int;
var GdkDevice = ctypes.StructType('GdkDevice');
var GdkDeviceManager = ctypes.StructType('GdkDeviceManager');
var GdkDisplay = ctypes.StructType('GdkDisplay');
var GdkModifierType = ctypes.int;
var GdkWindow = ctypes.StructType('GdkWindow');

// https://developer.gnome.org/gdk3/stable/gdk3-Windows.html#gdk-get-default-root-window
var gdk_get_default_root_window = gdk.declare('gdk_get_default_root_window', ctypes.default_abi,
    GdkWindow.ptr    // return - the root window, which is top most parent of all windows
);

// in GDK2 we have to use gdk_window_get_pointer, but in GDK3 it was deprecated and have to use gdk_window_get_device_position
// https://developer.gnome.org/gdk3/stable/gdk3-Windows.html#gdk-window-get-device-position
var gdk_window_get_device_position = gdk3.declare('gdk_window_get_device_position', ctypes.default_abi,
    GdkWindow.ptr,        // return - The window underneath device or NULL if the window is not known to GDK
    GdkWindow.ptr,        // window
    GdkDevice.ptr,        // device
    gint.ptr,            // x
    gint.ptr,            // y
    GdkModifierType.ptr    // mask
);

// https://developer.gnome.org/gdk3/stable/gdk3-Windows.html#gdk-window-get-display
var gdk_window_get_display = gdk.declare('gdk_window_get_display', ctypes.default_abi,
    GdkDisplay.ptr,    // return
    GdkWindow.ptr    // *window
);

// https://developer.gnome.org/gdk3/stable/GdkDisplay.html#gdk-display-get-device-manager
var gdk_display_get_device_manager = gdk3.declare('gdk_display_get_device_manager', ctypes.default_abi,
    GdkDeviceManager.ptr,    // return
    GdkDisplay.ptr    // *display
);

// https://developer.gnome.org/gdk3/stable/GdkDeviceManager.html#gdk-device-manager-get-client-pointer
var gdk_device_manager_get_client_pointer = gdk3.declare('gdk_device_manager_get_client_pointer', ctypes.default_abi,
    GdkDevice.ptr,    // return
    GdkDeviceManager.ptr    // *device_manager
);

var winRoot_GdkWindowPtr = gdk_get_default_root_window();
var displayPtr = gdk_window_get_display(winRoot_GdkWindowPtr);
var device_managerPtr = gdk_display_get_device_manager(displayPtr);
var devicePtr = gdk_device_manager_get_client_pointer(device_managerPtr);

var x = gint();
var y = gint();
var mask = GdkModifierType();
var win_underMouse = gdk_window_get_device_position(
    winRoot_GdkWindowPtr,
    devicePtr,
    x.address(),
    y.address(),
    mask.address()
);
console.info('win_underMouse:', win_underMouse, win_underMouse.toString());
console.info('x:', x, x.toString());
console.info('y:', y, y.toString());
console.info('mask:', mask, mask.toString());

gdk.close();
gdk3.close();</pre>

<h3 id="GTK">GTK+</h3>

<p>The GTK+ toolkit can also be used. The list of the exposed symbols/functions can be found here: <a href="https://developer.gnome.org/gtk3/2.90/">GNOME Developer :: GTK+ Reference Manual</a>.</p>

<h4 id="Example_...">Example: ...</h4>

<pre class="brush: js">// placeholder - example soon to come</pre>

<h3 id="X11">X11</h3>

<p>X11 runs primarily on UNIX® and UNIX-like operating systems like Linux, all of the BSD variants, Sun Solaris both native 32 and 64 bit support, Solaris x86, Mac OS X (via Darwin) as well as other platforms like OS/2 and Cygwin. There are updates that happen to X11; at the time of this writing, the latest version is 4.4.0. Information on all releases can be found on its official page <a href="http://www.xfree86.org/sos/resources.html">X11 Resources</a>. Syntax and variable types are found on the documentation pages linked from this page. For example the documentation for v4.4.0 is seen here: <a href="http://www.xfree86.org/4.4.0/manindex3.html">X11 Manual pages: Section 3</a>.</p>

<h4 id="Example_XQueryPointer">Example: XQueryPointer</h4>

<p>Get mouse cursor position and some extra information. Documentation on this function is found at <a href="http://www.xfree86.org/4.4.0/XQueryPointer.3.html">XFree86 :: XQueryPointer(3X11) Manual Page</a>.</p>

<pre class="brush: cpp">Components.utils.import("resource://gre/modules/ctypes.jsm");
let X11 = ctypes.open("libX11.so.6");
let Display_ptr = ctypes.voidptr_t;
let XOpenDisplay = X11.declare("XOpenDisplay",
    ctypes.default_abi,
    Display_ptr,
    ctypes.char.ptr
);
let Window = ctypes.int;
let XRootWindow = X11.declare("XRootWindow",
    ctypes.default_abi,
    Window,
    Display_ptr,
    ctypes.int
);
let XQueryPointer = X11.declare("XQueryPointer",
    ctypes.default_abi,
    ctypes.bool,
    Display_ptr,
    Window,
    Window.ptr,
    Window.ptr,
    ctypes.int.ptr,
    ctypes.int.ptr,
    ctypes.int.ptr,
    ctypes.int.ptr,
    ctypes.unsigned_int.ptr
);
let XCloseDisplay = X11.declare("XCloseDisplay",
    ctypes.default_abi,
    ctypes.int,
    Display_ptr
);

let display = XOpenDisplay(null);
let rootWindow = XRootWindow(display, 0);

let root = new Window();
let child = new Window();
let rootX = new ctypes.int();
let rootY = new ctypes.int();
let windowX = new ctypes.int();
let windowY = new ctypes.int();
let mask = new ctypes.unsigned_int();

XQueryPointer(display,
    rootWindow,
    root.address(),
    child.address(),
    rootX.address(),
    rootY.address(),
    windowX.address(),
    windowY.address(),
    mask.address()
);

XCloseDisplay(display);

Components.utils.reportError(rootX.value + "," + rootY.value);

X11.close();
</pre>

<h4 id="Resources_for_X11">Resources for X11</h4>

<ul>
 <li><a href="http://standards.freedesktop.org/wm-spec/wm-spec-latest.html">Extended Window Manager Hints</a></li>
 <li><a href="https://gist.github.com/search?q=x11+%40noitidart">GitHubGISTS :: Noitidart / Search · x11</a> - X11 js-ctypes snippets that can be copied and pasted to scratchpad</li>
</ul>

<h3 id="XCB">XCB</h3>

<p>All the above methods, GDK, GTK, and X11/Xlib are meant to be used on the main thread. If you would like to do stuff off of the main thread, in ChromeWorker's, then you should use XCB. XCB is thread safe.</p>

<h4 id="Resources_for_XCB">Resources for XCB</h4>

<ul>
 <li> <a href="https://github.com/Noitidart/ostypes/blob/master/ostypes_x11.jsm#L2233">GitHub :: Noitidart - ostypes / ostypes_x11.jsm</a> - Some method and type signatures</li>
 <li><a href="https://xcb.freedesktop.org/manual/xproto_8h_source.html#l06177">XCB Freedesktop :: xproto.h</a></li>
</ul>

<h2 id="Mac_OS_X">Mac OS X</h2>

<p>Mac OS X has two categories of C-based API (Carbon, Core Foundation) and Objective-C based API (Cocoa).</p>

<div class="note">
<p><strong>Note:</strong> You cannot use Carbon routines from your add-on; Firefox is a 64-bit application, and you cannot use Carbon from 64-bit code.</p>
</div>

<h3 id="Core_Foundation">Core Foundation</h3>

<p>To learn about all the Mac OS X APIs and which library file you will need to call, go to the Mac Developer Library website and find the function, then scroll down to "Declared In" section, and find which Framework contains the header file.</p>

<p>The CoreGraphics framework is based on CoreFoundation framework, including CoreGraphics etc. The release, string, etc. comes from CoreFoundation.</p>

<h4 id="Example_CGEventGetLocation">Example: CGEventGetLocation</h4>

<p>For example, <code>CGEventGetLocation</code> function is declared in <code>CGEvent.h</code> header file, which is contained in <code>CoreGraphics.framework</code>. So <code>/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics</code> is the library path to pass to <code>ctypes.open</code> function call.</p>

<pre class="brush: cpp">Components.utils.import("resource://gre/modules/ctypes.jsm");
let CoreGraphics = ctypes.open("/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics");
let CoreFoundation = ctypes.open("/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation");

let CGEventRef = ctypes.voidptr_t;
let CGEventSourceRef = ctypes.voidptr_t;
let CGEventCreate = CoreGraphics.declare("CGEventCreate",
                                         ctypes.default_abi,
                                         CGEventRef,
                                         CGEventSourceRef);
let CGFloat = ctypes.voidptr_t.size == 4 ? ctypes.float : ctypes.double;  // 64bit its double, in 32bit its float
let CGPoint = new ctypes.StructType("CGPoint",
                                     [ { "x" : CGFloat },
                                       { "y" : CGFloat } ]);
let CGEventGetLocation = CoreGraphics.declare("CGEventGetLocation",
                                              ctypes.default_abi,
                                              CGPoint,
                                              CGEventRef);
let CFTypeRef = ctypes.voidptr_t;
let CFRelease = CoreFoundation.declare("CFRelease",
                                       ctypes.default_abi,
                                       ctypes.void_t,
                                       CGEventRef);

let event = CGEventCreate(null);
let cursor = CGEventGetLocation(event);

CFRelease(event);

Components.utils.reportError(cursor);

CoreGraphics.close();
CoreFoundation.close();
</pre>

<h4 id="Resources_for_Core_Foundation">Resources for Core Foundation</h4>

<ul>
 <li> <a href="https://github.com/philikon/osxtypes/">GitHub :: philikon - osxtypes</a> - JavaScript modules are auto-generated from the OS X header files</li>
 <li><a href="https://gist.github.com/search?q=coreFoundation+%40noitidart">GitHubGISTS :: Noitidart / Search · CoreFoundation</a> - CoreFoundation js-ctypes snippets that can be copied and pasted to scratchpad</li>
</ul>

<h3 id="Cocoa">Cocoa</h3>

<div class="note">
<p>See <a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes">Using Objective-C from js-ctypes</a> for more info.</p>
</div>

<p>To call Objective-C based API from ctypes, use the following functions in <code>libobjc.dylib</code>:</p>

<ul>
 <li><code>objc_getClass</code> to get Class</li>
 <li><code>sel_registerName</code> to register selector name</li>
 <li><code>objc_msgSend</code> and some variants to send message to class and instance</li>
</ul>

<p>Objective-C code can be translated into C code by the following rule:</p>

<pre class="brush: cpp">// Objective-C code
NSEvent loc = [NSEvent mouseLocation];

// pseudo C code
NSEvent loc = (NSPoint)objc_msgSend(objc_getClass("NSEvent"),
                                    sel_registerName("mouseLocation"));
</pre>

<h4 id="Example_NSEvent_mouseLocation">Example: [NSEvent mouseLocation]</h4>

<pre class="brush: cpp">Components.utils.import("resource://gre/modules/ctypes.jsm");
let objc = ctypes.open(ctypes.libraryName("objc"));

let id = ctypes.StructType("objc_object").ptr;
let SEL = ctypes.StructType("objc_selector").ptr;
let objc_getClass = objc.declare("objc_getClass",
                                 ctypes.default_abi,
                                 id,
                                 ctypes.char.ptr);
let sel_registerName = objc.declare("sel_registerName",
                                    ctypes.default_abi,
                                    SEL,
                                    ctypes.char.ptr);
let objc_msgSend = objc.declare("objc_msgSend",
                                ctypes.default_abi,
                                id,
                                id,
                                SEL,
                                "...");
let CGFloat = ctypes.voidptr_t.size == 4 ? ctypes.float : ctypes.double;  // 64bit its double, in 32bit its float
let NSPoint = new ctypes.StructType("NSPoint",
                                    [ { "x" : CGFloat },
                                      { "y" : CGFloat } ]);
// note: [NSEvent mouseLocation] returns NSPoint struct,
// which is small enough to return in register,
// so we don't need to use objc_msgSend_stret.
let objc_msgSend_NSPoint = objc.declare("objc_msgSend",
                                        ctypes.default_abi,
                                        NSPoint,
                                        id,
                                        SEL,
                                        "...");

// loc = [NSEvent mouseLocation]
let NSEvent = objc_getClass("NSEvent");
let mouseLocation = sel_registerName("mouseLocation");
let loc = objc_msgSend_NSPoint(NSEvent, mouseLocation);

Components.utils.reportError(loc);

objc.close();
</pre>

<h4 id="Resources_for_Cocoa">Resources for Cocoa</h4>

<ul>
 <li> <a href="https://code.google.com/p/js-macosx/">GoogleCode :: js-macosx</a> - Lightweight bridge for calling Cocoa frameworks from Mozilla JavaScript</li>
 <li><a href="http://unmht.blogspot.jp/search/label/js-ctypes">UnMHT Blog :: js-ctypes and ObjC</a> - Blog entries on using Objective-C from js-ctypes</li>
 <li><a href="https://gist.github.com/search?q=objc+%40noitidart">GitHubGISTS :: Noitidart / Search · objc</a> - Objective-C js-ctypes snippets that can be copied and pasted to scratchpad</li>
</ul>

<h2 id="Android">Android</h2>

<p>Android runs on Java and can be used by js-ctypes through the JNI libraries. Thankfully all the js-ctypes was abstracted away into JNI.jsm. Undrestanding js-ctypes is important as arrays and other features used in JNI.jsm will require us to create arrays from the types available to the ctypes.jsm module.</p>

<p>Although JNI is done completely through js-ctypes, a JSM was created to abstract away the js-ctypes so developers can focus on the JNI aspect. Therefore elaboration on this technique is not done in the js-ctypes section but it is done in the <a href="/en-US/docs/Mozilla/JavaScript_code_modules/JNI.jsm">JNI.jsm article</a>. This article links to a fully funcitonal demo that can be copied and pasted into scratchpad, as a quick reference here is the link to that demo: <a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_JNI_from_js-ctypes">Following the Android Toasts Tutorial from a JNI Prespective</a>.</p>

<h2 id="See_Also">See Also</h2>

<ul>
 <li><a href="/en-US/Add-ons/Code_snippets/Finding_Window_Handles">Finding window handles - OS Specific Examples </a> - How to get the a window and pass it to js-ctypes</li>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_COM_from_js-ctypes">Using COM from js-ctypes</a> Example</li>
 <li><a href="/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes">Using Objective-C from js-ctypes</a> Example</li>
</ul>