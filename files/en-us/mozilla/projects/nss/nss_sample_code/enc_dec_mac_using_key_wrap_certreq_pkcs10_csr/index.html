---
title: Enc Dec MAC Using Key Wrap CertReq PKCS10 CSR
slug: >-
  Mozilla/Projects/NSS/NSS_Sample_Code/Enc_Dec_MAC_Using_Key_Wrap_CertReq_PKCS10_CSR
---
<h2 id="NSS_Sample_Code_6_EncryptionDecryption_and_MAC_and_output_Public_as_a_PKCS_11_CSR.">NSS Sample Code 6: Encryption/Decryption and MAC and output Public as a PKCS 11 CSR.</h2>

<p class="summary">Generates encryption/mac keys and outputs public key as pkcs11 certificate signing request</p>

<pre class="brush: cpp"> /* This Source Code Form is subject to the terms of the Mozilla Public
 &nbsp;* License, v. 2.0. If a copy of the MPL was not distributed with this
 &nbsp;* file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* NSPR Headers */
 #include &lt;prthread.h&gt;
 #include &lt;plgetopt.h&gt;
 #include &lt;prerror.h&gt;
 #include &lt;prinit.h&gt;
 #include &lt;prlog.h&gt;
 #include &lt;prtypes.h&gt;
 #include &lt;plstr.h&gt;

/* NSS headers */
 #include &lt;keyhi.h&gt;
 #include &lt;pk11priv.h&gt;

/* our samples utilities */
 #include "util.h"

/* Constants */
 #define BLOCKSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32
 #define MODBLOCKSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128
 #define DEFAULT_KEY_BITS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024

/* Header file Constants */
 #define ENCKEY_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN WRAPPED ENCKEY-----"
 #define ENCKEY_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END WRAPPED ENCKEY-----"
 #define MACKEY_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN WRAPPED MACKEY-----"
 #define MACKEY_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END WRAPPED MACKEY-----"
 #define IV_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN IV-----"
 #define IV_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END IV-----"
 #define MAC_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN MAC-----"
 #define MAC_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END MAC-----"
 #define PAD_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN PAD-----"
 #define PAD_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END PAD-----"
 #define LAB_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN KEY LABEL-----"
 #define LAB_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END KEY LABEL-----"
 #define PUBKEY_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN PUB KEY -----"
 #define PUBKEY_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END PUB KEY -----"
 #define NS_CERTREQ_HEADER&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN NEW CERTIFICATE REQUEST-----"
 #define NS_CERTREQ_TRAILER&nbsp;&nbsp;&nbsp; "-----END NEW CERTIFICATE REQUEST-----"
 #define NS_CERT_ENC_HEADER&nbsp;&nbsp;&nbsp; "-----BEGIN CERTIFICATE FOR ENCRYPTION-----"
 #define NS_CERT_ENC_TRAILER&nbsp;&nbsp; "-----END CERTIFICATE FOR ENCRYPTION-----"
 #define NS_CERT_VFY_HEADER&nbsp;&nbsp;&nbsp; "-----BEGIN CERTIFICATE FOR SIGNATURE VERIFICATION-----"
 #define NS_CERT_VFY_TRAILER&nbsp;&nbsp; "-----END CERTIFICATE FOR SIGNATURE VERIFICATION-----"
 #define NS_SIG_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN SIGNATURE-----"
 #define NS_SIG_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END SIGNATURE-----"
 #define NS_CERT_HEADER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----BEGIN CERTIFICATE-----"
 #define NS_CERT_TRAILER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-----END CERTIFICATE-----"

/* sample 6 commands */
 typedef enum {
 &nbsp;&nbsp;&nbsp; GENERATE_CSR,
 &nbsp;&nbsp;&nbsp; ADD_CERT_TO_DB,
 &nbsp;&nbsp;&nbsp; SAVE_CERT_TO_HEADER,
 &nbsp;&nbsp;&nbsp; ENCRYPT,
 &nbsp;&nbsp;&nbsp; DECRYPT,
 &nbsp;&nbsp;&nbsp; SIGN,
 &nbsp;&nbsp;&nbsp; VERIFY,
 &nbsp;&nbsp;&nbsp; UNKNOWN
 } CommandType;

typedef enum {
 &nbsp;&nbsp; SYMKEY = 0,
 &nbsp;&nbsp; MACKEY = 1,
 &nbsp;&nbsp; IV&nbsp;&nbsp;&nbsp;&nbsp; = 2,
 &nbsp;&nbsp; MAC&nbsp;&nbsp;&nbsp; = 3,
 &nbsp;&nbsp; PAD&nbsp;&nbsp;&nbsp; = 4,
 &nbsp;&nbsp; PUBKEY = 5,
 &nbsp;&nbsp; LAB&nbsp;&nbsp;&nbsp; = 6,
 &nbsp;&nbsp; CERTENC= 7,
 &nbsp;&nbsp; CERTVFY= 8,
 &nbsp;&nbsp; SIG&nbsp;&nbsp;&nbsp; = 9
 } HeaderType;


 /*
 &nbsp;* Print usage message and exit
 &nbsp;*/
 static void
 Usage(const char *progName)
 {
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s %s %s %s %s %s %s %s %s\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " -&lt;G|A|H|E|DS|V&gt; -d &lt;dbdirpath&gt; ",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "[-p &lt;dbpwd&gt; | -f &lt;dbpwdfile&gt;] [-z &lt;noisefilename&gt;] [-a &lt;\"\"&gt;]",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-s &lt;subject&gt; -r &lt;csr&gt; | ",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-n &lt;nickName&gt; -t &lt;trust&gt; -c &lt;cert&gt; [ -r &lt;csr&gt; -u &lt;issuerNickname&gt; [-x &lt;\"\"&gt;] -m &lt;serialNumber&gt; ] | ",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-n &lt;nickName&gt; -b &lt;headerfilename&gt; | ",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-b &lt;headerfilename&gt; -i &lt;ipfilename&gt; -e &lt;encryptfilename&gt; | ",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-b &lt;headerfilename&gt; -i &lt;ipfilename&gt; | ",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-b &lt;headerfilename&gt; -i &lt;ipfilename&gt; | ",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-b &lt;headerfilename&gt; -e &lt;encryptfilename&gt; -o &lt;opfilename&gt; \n");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "commands:\n\n");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%s %s\n --for generating cert request (for CA also)\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, "-G -s &lt;subject&gt; -r &lt;csr&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%s %s\n --to input and store cert (for CA also)\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, "-A -n &lt;nickName&gt; -t &lt;trust&gt; -c &lt;cert&gt; [ -r &lt;csr&gt; -u &lt;issuerNickname&gt; [-x &lt;\"\"&gt;] -m &lt;serialNumber&gt; ]");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%s %s\n --to put cert in header\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, "-H -n &lt;nickname&gt; -b &lt;headerfilename&gt; [-v &lt;\"\"&gt;]");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%s %s\n --to find public key from cert in header and encrypt\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, "-E -b &lt;headerfilename&gt; -i &lt;ipfilename&gt; -e &lt;encryptfilename&gt; ");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%s %s\n --decrypt using corresponding private key \n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, "-D -b &lt;headerfilename&gt; -e &lt;encryptfilename&gt; -o &lt;opfilename&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%s %s\n --Sign using private key \n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, "-S -b &lt;headerfilename&gt; -i &lt;infilename&gt; ");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%s %s\n --Verify using public key \n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, "-V -b &lt;headerfilename&gt; -i &lt;ipfilename&gt; ");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "options:\n\n");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - db directory path\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-d &lt;dbdirpath&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - db password [optional]\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-p &lt;dbpwd&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - db password file [optional]\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-f &lt;dbpwdfile&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - noise file name [optional]\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-z &lt;noisefilename&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - input file name\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-i &lt;ipfilename&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - header file name\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-b &lt;headerfilename&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - encrypt file name\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-e &lt;encryptfilename&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - output file name\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-o &lt;opfilename&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - certificate serial number\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-m &lt;serialNumber&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - certificate nickname\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-n &lt;nickname&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - certificate trust\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-t &lt;trustargs&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - certificate issuer nickname\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-u &lt;issuerNickname&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - certificate signing request \n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-r &lt;csr&gt;");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - generate a self-signed cert [optional]\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-x");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - to enable ascii [optional]\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-a");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "%-30s - to save certificate to header file as sig verification [optional]\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-v");
 &nbsp;&nbsp;&nbsp; exit(-1);
 }

/*
 &nbsp;* Validate the options used for Generate CSR command
 &nbsp;*/
 static void
 ValidateGenerateCSRCommand(const char *progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dbdir,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTName&nbsp;&nbsp; *subject,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *subjectStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *certReqFileName)
 {
 &nbsp;&nbsp;&nbsp; PRBool validationFailed = PR_FALSE;
 &nbsp;&nbsp;&nbsp; if (!subject) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -G -d %s -s: improperly formatted name: \"%s\"\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, subjectStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!certReqFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -G -d %s -s %s -r: certificate request file name not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, subjectStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (validationFailed) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-G -d &lt;dbdirpath&gt; -s &lt;subject&gt; -r &lt;csr&gt; \n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* Validate the options used for Add Cert to DB command
 &nbsp;*/
 static void
 ValidateAddCertToDBCommand(const char *progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dbdir,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *trustStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *certFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *certReqFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *issuerNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *serialNumberStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selfsign)
 {
 &nbsp;&nbsp;&nbsp; PRBool validationFailed = PR_FALSE;
 &nbsp;&nbsp;&nbsp; if (!nickNameStr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -A -d %s -n : nick name is missing\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!trustStr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -A -d %s -n %s -t: trust flag is missing\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!certFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -A -d %s -n %s -t %s -c: certificate file name not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr, trustStr, serialNumberStr, certReqFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (PR_Access(certFileName, PR_ACCESS_EXISTS) == PR_FAILURE) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!certReqFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -A -d %s -n %s -t %s -c %s -r: certificate file or certificate request file is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr, trustStr, certFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!selfsign &amp;&amp; !issuerNameStr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -A -d %s -n %s -t %s -c %s -r %s -u : issuer name is missing\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr, trustStr, certFileName, certReqFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!serialNumberStr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -A -d %s -n %s -t %s -c %s -r %s -u %s -m : serial number is missing\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr, trustStr, certFileName, certReqFileName, issuerNameStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (validationFailed) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " -A -d &lt;dbdirpath&gt; -n &lt;nickName&gt; -t &lt;trust&gt; -c &lt;cert&gt; \n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "&nbsp;&nbsp;&nbsp;&nbsp; OR\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-A -d &lt;dbdirpath&gt; -n &lt;nickName&gt; -t &lt;trust&gt; -c &lt;cert&gt; -r &lt;csr&gt; -u &lt;issuerNickname&gt; -m &lt;serialNumber&gt; [-x &lt;\"\"&gt;] \n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* Validate the options used for Save Cert To Header command
 &nbsp;*/
 static void
 ValidateSaveCertToHeaderCommand(const char *progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dbdir,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName)
 {
 &nbsp;&nbsp;&nbsp; PRBool validationFailed = PR_FALSE;
 &nbsp;&nbsp;&nbsp; if (!nickNameStr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -S -d %s -n : nick name is missing\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!headerFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -S -d %s -n %s -b : header file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (validationFailed) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-S -d &lt;dbdirpath&gt; -n &lt;nickname&gt; -b &lt;headerfilename&gt; [-v &lt;\"\"&gt;]\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* Validate the options used for Encrypt command
 &nbsp;*/
 static void
 ValidateEncryptCommand(const char *progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dbdir,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *inFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *encryptedFileName)
 {
 &nbsp;&nbsp;&nbsp; PRBool validationFailed = PR_FALSE;
 &nbsp;&nbsp;&nbsp; if (!nickNameStr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -E -d %s -n : nick name is missing\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!headerFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -E -d %s -n %s -b : header file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!inFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -E -d %s -n %s -b %s -i : input file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr, headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!encryptedFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -E -d %s -n %s -b %s -i %s -e : encrypt file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr, headerFileName, inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (validationFailed) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-E -d &lt;dbdirpath&gt; -b &lt;headerfilename&gt; -i &lt;ipfilename&gt; -e &lt;encryptfilename&gt; -n &lt;nickname&gt; \n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* Validate the options used for Sign command
 &nbsp;*/
 static void
 ValidateSignCommand(const char *progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dbdir,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *inFileName)
 {
 &nbsp;&nbsp;&nbsp; PRBool validationFailed = PR_FALSE;
 &nbsp;&nbsp;&nbsp; if (!nickNameStr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -I -d %s -n : nick name is missing\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!headerFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -I -d %s -n %s -b : header file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!inFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -I -d %s -n %s -b %s -i : input file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, nickNameStr, headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (validationFailed) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-I -d &lt;dbdirpath&gt; -b &lt;headerfilename&gt; -i &lt;ipfilename&gt; -n &lt;nickname&gt; \n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* Validate the options used for verify command
 &nbsp;*/
 static void
 ValidateVerifyCommand(const char *progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dbdir,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *inFileName)
 {
 &nbsp;&nbsp;&nbsp; PRBool validationFailed = PR_FALSE;
 &nbsp;&nbsp;&nbsp; if (!headerFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -V -d %s -b : header file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!inFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -I -d %s -b %s -i : input file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (validationFailed) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-I -d &lt;dbdirpath&gt; -b &lt;headerfilename&gt; -i &lt;ipfilename&gt; \n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* Validate the options used for Decrypt command
 &nbsp;*/
 static void
 ValidateDecryptCommand(const char *progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dbdir,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *encryptedFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *outFileName)
 {
 &nbsp;&nbsp;&nbsp; PRBool validationFailed = PR_FALSE;
 &nbsp;&nbsp;&nbsp; if (!headerFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -D -d %s -b : header file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!encryptedFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -D -d %s -b %s -e : encrypt file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (!outFileName) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s -D -d %s -b %s -e %s -o : output file name is not found\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; progName, dbdir, headerFileName, encryptedFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationFailed = PR_TRUE;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (validationFailed) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nUsage:&nbsp; %s %s \n\n", progName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-D -d &lt;dbdirpath&gt; -b &lt;headerfilename&gt; -e &lt;encryptfilename&gt; -o &lt;opfilename&gt;\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(-1);
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* Sign the contents of input file using private key and
 &nbsp;* return result as SECItem
 &nbsp;*/
 SECStatus
 SignData(const char *inFileName, SECKEYPrivateKey *pk, SECItem *res)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp; rv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SECFailure;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp; nb;
 &nbsp;&nbsp;&nbsp; unsigned char ibuf[4096];
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp; *inFile&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SGNContext&nbsp;&nbsp; *sgn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; /*&nbsp; Open the input file for reading */
 &nbsp;&nbsp;&nbsp; inFile = PR_Open(inFileName, PR_RDONLY, 0);
 &nbsp;&nbsp;&nbsp; if (!inFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for reading.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Sign using private key */

&nbsp;&nbsp;&nbsp; sgn = SGN_NewContext(SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION, pk);
 &nbsp;&nbsp;&nbsp; if (!sgn) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to create context for signing\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; rv = SGN_Begin(sgn);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "problem while SGN_Begin\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; while ((nb = PR_Read(inFile, ibuf, sizeof(ibuf))) &gt; 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SGN_Update(sgn, ibuf, nb);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "problem while SGN_Update\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = SGN_End(sgn, res);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "problem while SGN_End\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; if (inFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(inFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (sgn) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SGN_DestroyContext(sgn, PR_TRUE);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Verify the signature using public key
 &nbsp;*/
 SECStatus
 VerifyData(const char *inFileName, SECKEYPublicKey *pk,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECItem *sigItem, secuPWData *pwdata)
 {
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp; nb;
 &nbsp;&nbsp;&nbsp; unsigned char ibuf[4096];
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp; rv&nbsp;&nbsp;&nbsp;&nbsp; = SECFailure;
 &nbsp;&nbsp;&nbsp; VFYContext&nbsp;&nbsp; *vfy&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp; *inFile = NULL;

&nbsp;&nbsp;&nbsp; /*&nbsp; Open the input file for reading */
 &nbsp;&nbsp;&nbsp; inFile = PR_Open(inFileName, PR_RDONLY, 0);
 &nbsp;&nbsp;&nbsp; if (!inFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for reading.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; vfy = VFY_CreateContext(pk,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigItem,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwdata);
 &nbsp;&nbsp;&nbsp; if (!vfy) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to create context for verifying signature\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = VFY_Begin(vfy);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "problem while VFY_Begin\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; while ((nb = PR_Read(inFile, ibuf, sizeof(ibuf))) &gt; 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = VFY_Update(vfy, ibuf, nb);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "problem while VFY_Update\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = VFY_End(vfy);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "problem while VFY_End\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

cleanup:
 &nbsp;&nbsp;&nbsp; if (inFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(inFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (vfy) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VFY_DestroyContext(vfy, PR_TRUE);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Write Cryptographic parameters to header file
 &nbsp;*/
 SECStatus
 WriteToHeaderFile(const char *buf, unsigned int len, HeaderType type,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRFileDesc *outFile)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp; *header;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp; *trailer;

&nbsp;&nbsp;&nbsp; switch (type) {
 &nbsp;&nbsp;&nbsp; case SYMKEY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = ENCKEY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = ENCKEY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case MACKEY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header =&nbsp; MACKEY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = MACKEY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case IV:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = IV_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = IV_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case MAC:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = MAC_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = MAC_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case PAD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = PAD_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = PAD_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case PUBKEY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = PUBKEY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = PUBKEY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case CERTENC:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header&nbsp; = NS_CERT_ENC_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = NS_CERT_ENC_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case CERTVFY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header&nbsp; = NS_CERT_VFY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = NS_CERT_VFY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case SIG:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header&nbsp; = NS_SIG_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = NS_SIG_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case LAB:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = LAB_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = LAB_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "%s\n", header);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "%s\n", buf);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "%s\n\n", trailer);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SECSuccess;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SECFailure;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "%s\n", header);
 &nbsp;&nbsp;&nbsp; PrintAsHex(outFile, buf, len);
 &nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "%s\n\n", trailer);
 &nbsp;&nbsp;&nbsp; return SECSuccess;
 }

/*
 &nbsp;* Read cryptographic parameters from the header file
 &nbsp;*/
 SECStatus
 ReadFromHeaderFile(const char *fileName, HeaderType type,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECItem *item, PRBool isHexData)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECSuccess;
 &nbsp;&nbsp;&nbsp; PRFileDesc*&nbsp;&nbsp;&nbsp; file = NULL;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filedata;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outbuf;
 &nbsp;&nbsp;&nbsp; unsigned char *nonbody;
 &nbsp;&nbsp;&nbsp; unsigned char *body;
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *header;
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *trailer;

&nbsp;&nbsp;&nbsp; outbuf.type = siBuffer;
 &nbsp;&nbsp;&nbsp; file = PR_Open(fileName, PR_RDONLY, 0);
 &nbsp;&nbsp;&nbsp; if (!file) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Failed to open %s\n", fileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; switch (type) {
 &nbsp;&nbsp;&nbsp; case PUBKEY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = PUBKEY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = PUBKEY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case SYMKEY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = ENCKEY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = ENCKEY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case MACKEY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = MACKEY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = MACKEY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case IV:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = IV_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = IV_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case MAC:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = MAC_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = MAC_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case PAD:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = PAD_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = PAD_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case LAB:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = LAB_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = LAB_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case CERTENC:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header&nbsp; = NS_CERT_ENC_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = NS_CERT_ENC_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case CERTVFY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header&nbsp; = NS_CERT_VFY_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = NS_CERT_VFY_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case SIG:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header&nbsp; = NS_SIG_HEADER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trailer = NS_SIG_TRAILER;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; rv = FileToItem(&amp;filedata, file);
 &nbsp;&nbsp;&nbsp; nonbody = (char *)filedata.data;
 &nbsp;&nbsp;&nbsp; if (!nonbody) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to read data from input file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* check for headers and trailers and remove them */
 &nbsp;&nbsp;&nbsp; if ((body = strstr(nonbody, header)) != NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *trail = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nonbody = body;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body = PORT_Strchr(body, '\n');
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!body)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body = PORT_Strchr(nonbody, '\r'); /* maybe this is a MAC file */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (body)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trail = strstr(++body, trailer);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trail != NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *trail = '\0';
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,&nbsp; "input has header but no trailer\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_Free(filedata.data);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* headers didn't exist */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *trail = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body = nonbody;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (body) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trail = strstr(++body, trailer);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trail != NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,&nbsp; "input has no header but has trailer\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_Free(filedata.data);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; HexToBuf(body, item, isHexData);
 cleanup:
 &nbsp;&nbsp;&nbsp; if (file) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(file);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Generate the private key&nbsp; &nbsp;
 &nbsp;*/
 SECKEYPrivateKey *
 GeneratePrivateKey(KeyType keytype, PK11SlotInfo *slot, int size,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int publicExponent, const char *noise,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEYPublicKey **pubkeyp, const char *pqgFile,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secuPWData *pwdata)
 {
 &nbsp;&nbsp;&nbsp; CK_MECHANISM_TYPE&nbsp; mechanism;
 &nbsp;&nbsp;&nbsp; SECOidTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algtag;
 &nbsp;&nbsp;&nbsp; PK11RSAGenParams&nbsp;&nbsp; rsaparams;
 &nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *params;
 &nbsp;&nbsp;&nbsp; SECKEYPrivateKey&nbsp; *privKey&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv;
 &nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; randbuf[BLOCKSIZE + 1];

&nbsp;&nbsp;&nbsp; rv = GenerateRandom(randbuf, BLOCKSIZE);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Error while generating the random numbers : %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; PK11_RandomUpdate(randbuf, BLOCKSIZE);
 &nbsp;&nbsp;&nbsp; switch (keytype) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case rsaKey:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsaparams.keySizeInBits = size;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsaparams.pe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = publicExponent;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mechanism&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = CKM_RSA_PKCS_KEY_PAIR_GEN;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algtag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = &amp;rsaparams;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "\n\n");
 &nbsp;&nbsp;&nbsp; fprintf(stderr, "Generating key.&nbsp; This may take a few moments...\n\n");
 &nbsp;&nbsp;&nbsp; privKey = PK11_GenerateKeyPair(slot, mechanism, params, pubkeyp,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_TRUE /*isPerm*/, PR_TRUE /*isSensitive*/,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwdata);
 cleanup:
 &nbsp;&nbsp;&nbsp; return privKey;
 }

/*
 &nbsp;* Get the certificate request from CSR
 &nbsp;*/
 static CERTCertificateRequest *
 GetCertRequest(char *inFileName, PRBool ascii)
 {
 &nbsp;&nbsp;&nbsp; CERTSignedData signedData;
 &nbsp;&nbsp;&nbsp; SECItem reqDER;
 &nbsp;&nbsp;&nbsp; CERTCertificateRequest *certReq = NULL;
 &nbsp;&nbsp;&nbsp; SECStatus rv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SECSuccess;
 &nbsp;&nbsp;&nbsp; PRArenaPool *arena&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; reqDER.data = NULL;
 &nbsp;&nbsp;&nbsp; arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
 &nbsp;&nbsp;&nbsp; if (arena == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; rv = ReadDERFromFile(&amp;reqDER, inFileName, ascii);
 &nbsp;&nbsp;&nbsp; if (rv) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; certReq = (CERTCertificateRequest*) PORT_ArenaZAlloc
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (arena, sizeof(CERTCertificateRequest));
 &nbsp;&nbsp;&nbsp; if (!certReq) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; certReq-&gt;arena = arena;

&nbsp;&nbsp;&nbsp; /* Since cert request is a signed data, must decode to get the inner data */
 &nbsp;&nbsp;&nbsp; PORT_Memset(&amp;signedData, 0, sizeof(signedData));
 &nbsp;&nbsp;&nbsp; rv = SEC_ASN1DecodeItem(arena, &amp;signedData,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEC_ASN1_GET(CERT_SignedDataTemplate), &amp;reqDER);
 &nbsp;&nbsp;&nbsp; if (rv) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = SEC_ASN1DecodeItem(arena, certReq,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEC_ASN1_GET(CERT_CertificateRequestTemplate), &amp;signedData.data);
 &nbsp;&nbsp;&nbsp; if (rv) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = CERT_VerifySignedDataWithPublicKeyInfo(&amp;signedData,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;certReq-&gt;subjectPublicKeyInfo, NULL /* wincx */);
 &nbsp;&nbsp;&nbsp; if (reqDER.data) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECITEM_FreeItem(&amp;reqDER, PR_FALSE);
 &nbsp;&nbsp;&nbsp; }

cleanup:
 &nbsp;&nbsp;&nbsp; if (rv) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "bad certificate request\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (arena) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_FreeArena(arena, PR_FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReq = NULL;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return certReq;
 }

/*
 &nbsp;* Sign Cert
 &nbsp;*/
 static SECItem *
 SignCert(CERTCertDBHandle *handle, CERTCertificate *cert,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool selfsign, SECOidTag hashAlgTag,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEYPrivateKey *privKey, char *issuerNickName, void *pwarg)
 {
 &nbsp;&nbsp;&nbsp; SECItem der;
 &nbsp;&nbsp;&nbsp; SECStatus rv;
 &nbsp;&nbsp;&nbsp; SECOidTag algID;
 &nbsp;&nbsp;&nbsp; void *dummy;
 &nbsp;&nbsp;&nbsp; PRArenaPool *arena&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECItem *result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECKEYPrivateKey *caPrivateKey = NULL;

&nbsp;&nbsp;&nbsp; if (!selfsign) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTCertificate *issuer = PK11_FindCertFromNickname(issuerNickName, pwarg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((CERTCertificate *)NULL == issuer) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to find issuer with nickname %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerNickName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; privKey = caPrivateKey = PK11_FindKeyByAnyCert(issuer, pwarg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate(issuer);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (caPrivateKey == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to retrieve key&nbsp; %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerNickName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; arena = cert-&gt;arena;
 &nbsp;&nbsp;&nbsp; algID = SEC_GetSignatureAlgorithmOidTag(privKey-&gt;keyType, hashAlgTag);
 &nbsp;&nbsp;&nbsp; if (algID == SEC_OID_UNKNOWN) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unknown key or hash type for issuer.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = SECOID_SetAlgorithmID(arena, &amp;cert-&gt;signature, algID, 0);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not set signature algorithm id.\n%s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* we only deal with cert v3 here */
 &nbsp;&nbsp;&nbsp; *(cert-&gt;version.data) = 2;
 &nbsp;&nbsp;&nbsp; cert-&gt;version.len = 1;

&nbsp;&nbsp;&nbsp; der.len = 0;
 &nbsp;&nbsp;&nbsp; der.data = NULL;
 &nbsp;&nbsp;&nbsp; dummy = SEC_ASN1EncodeItem (arena, &amp;der, cert,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEC_ASN1_GET(CERT_CertificateTemplate));
 &nbsp;&nbsp;&nbsp; if (!dummy) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not encode certificate.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; result = (SECItem *) PORT_ArenaZAlloc (arena, sizeof (SECItem));
 &nbsp;&nbsp;&nbsp; if (result == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not allocate item for certificate data.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; rv = SEC_DerSignData(arena, result, der.data, der.len, privKey, algID);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not sign encoded certificate data : %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* result allocated out of the arena, it will be freed
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * when the arena is freed */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = NULL;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; cert-&gt;derCert = *result;
 cleanup:
 &nbsp;&nbsp;&nbsp; if (caPrivateKey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPrivateKey(caPrivateKey);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return result;
 }

/*
 &nbsp;* MakeV1Cert
 &nbsp;*/
 static CERTCertificate *
 MakeV1Cert(CERTCertDBHandle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *handle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTCertificateRequest *req,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerNickName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selfsign,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serialNumber,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; warpmonths,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validityMonths)
 {
 &nbsp;&nbsp;&nbsp; PRExplodedTime&nbsp; printableTime;
 &nbsp;&nbsp;&nbsp; PRTime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now;
 &nbsp;&nbsp;&nbsp; PRTime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; after;
 &nbsp;&nbsp;&nbsp; CERTValidity&nbsp;&nbsp;&nbsp; *validity&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificate *issuerCert = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificate *cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; if ( !selfsign ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerCert = CERT_FindCertByNicknameOrEmailAddr(handle, issuerNickName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!issuerCert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not find certificate named %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerNickName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; now = PR_Now();
 &nbsp;&nbsp;&nbsp; PR_ExplodeTime (now, PR_GMTParameters, &amp;printableTime);
 &nbsp;&nbsp;&nbsp; if ( warpmonths ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printableTime.tm_month += warpmonths;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now = PR_ImplodeTime (&amp;printableTime);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_ExplodeTime (now, PR_GMTParameters, &amp;printableTime);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; printableTime.tm_month += validityMonths;
 &nbsp;&nbsp;&nbsp; after = PR_ImplodeTime (&amp;printableTime);

&nbsp;&nbsp;&nbsp; /* note that the time is now in micro-second unit */
 &nbsp;&nbsp;&nbsp; validity = CERT_CreateValidity (now, after);
 &nbsp;&nbsp;&nbsp; if (validity) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cert = CERT_CreateCertificate(serialNumber,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (selfsign ? &amp;req-&gt;subject : &amp;issuerCert-&gt;subject),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validity, req);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyValidity(validity);
 &nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; if ( issuerCert ) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate (issuerCert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return cert;
 }

/*
 &nbsp;* Add a certificate to the nss database
 &nbsp;*/
 SECStatus
 AddCert(PK11SlotInfo *slot, CERTCertDBHandle *handle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *name, char *trusts, char *inFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool ascii, PRBool emailcert, void *pwdata)
 {
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certDER;
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv;
 &nbsp;&nbsp;&nbsp; CERTCertTrust&nbsp;&nbsp; *trust = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificate *cert = NULL;

&nbsp;&nbsp;&nbsp; certDER.data = NULL;

&nbsp;&nbsp;&nbsp; /* Read in the entire file specified with the -i argument */
 &nbsp;&nbsp;&nbsp; rv = ReadDERFromFile(&amp;certDER, inFileName, ascii);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to read input file %s : %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFileName, PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Read in an ASCII cert and return a CERTCertificate */
 &nbsp;&nbsp;&nbsp; cert = CERT_DecodeCertFromPackage((char *)certDER.data, certDER.len);
 &nbsp;&nbsp;&nbsp; if (!cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not obtain certificate from file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Create a cert trust */
 &nbsp;&nbsp;&nbsp; trust = (CERTCertTrust *)PORT_ZAlloc(sizeof(CERTCertTrust));
 &nbsp;&nbsp;&nbsp; if (!trust) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to allocate cert trust\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; rv = CERT_DecodeTrustString(trust, trusts);
 &nbsp;&nbsp;&nbsp; if (rv) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to decode trust string\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; rv =&nbsp; PK11_ImportCert(slot, cert, CK_INVALID_HANDLE, name, PR_FALSE);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* sigh, PK11_Import Cert and CERT_ChangeCertTrust should have
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * been coded to take a password arg. */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PORT_GetError() == SEC_ERROR_TOKEN_NOT_LOGGED_IN) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = PK11_Authenticate(slot, PR_TRUE, pwdata);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not authenticate to token&nbsp; %s : %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PK11_GetTokenName(slot), PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = PK11_ImportCert(slot, cert, CK_INVALID_HANDLE,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name, PR_FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "could not add certificate to token or database : %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = CERT_ChangeCertTrust(handle, cert, trust);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PORT_GetError() == SEC_ERROR_TOKEN_NOT_LOGGED_IN) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = PK11_Authenticate(slot, PR_TRUE, pwdata);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not authenticate to token&nbsp; %s : %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PK11_GetTokenName(slot), PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = CERT_ChangeCertTrust(handle, cert, trust);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not change trust on certificate : %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; if (emailcert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_SaveSMimeProfile(cert, NULL, pwdata);
 &nbsp;&nbsp;&nbsp; }

cleanup:
 &nbsp;&nbsp;&nbsp; if (cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate (cert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (trust) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_Free(trust);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (certDER.data) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_Free(certDER.data);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Create a certificate
 &nbsp;*/
 static SECStatus
 CreateCert(
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTCertDBHandle *handle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PK11SlotInfo *slot,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp; issuerNickName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *inFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *outFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEYPrivateKey **selfsignprivkey,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; *pwarg,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECOidTag hashAlgTag,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int serialNumber,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; warpmonths,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; validityMonths,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dnsNames,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool&nbsp; ascii,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool&nbsp; selfsign)
 {
 &nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *extHandle;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reqDER;
 &nbsp;&nbsp;&nbsp; CERTCertExtension&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **CRexts;
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SECSuccess;
 &nbsp;&nbsp;&nbsp; CERTCertificate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *subjectCert&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificateRequest *certReq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *outFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *certDER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; reqDER.data = NULL;
 &nbsp;&nbsp;&nbsp; outFile = PR_Open(outFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_RDWR | PR_CREATE_FILE | PR_TRUNCATE, 00660);

&nbsp;&nbsp;&nbsp; /* Create a cert request object from the input cert request der */
 &nbsp;&nbsp;&nbsp; certReq = GetCertRequest(inFileName, ascii);
 &nbsp;&nbsp;&nbsp; if (certReq == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; subjectCert = MakeV1Cert(handle, certReq, issuerNickName, selfsign,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serialNumber, warpmonths, validityMonths);
 &nbsp;&nbsp;&nbsp; if (subjectCert == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; extHandle = CERT_StartCertExtensions (subjectCert);
 &nbsp;&nbsp;&nbsp; if (extHandle == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; if (certReq-&gt;attributes != NULL &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReq-&gt;attributes[0] != NULL &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReq-&gt;attributes[0]-&gt;attrType.data != NULL &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReq-&gt;attributes[0]-&gt;attrType.len&nbsp;&nbsp; &gt; 0&nbsp;&nbsp;&nbsp; &amp;&amp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECOID_FindOIDTag(&amp;certReq-&gt;attributes[0]-&gt;attrType)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; == SEC_OID_PKCS9_EXTENSION_REQUEST) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = CERT_GetCertificateRequestExtensions(certReq, &amp;CRexts);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s\n", PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = CERT_MergeExtensions(extHandle, CRexts);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "%s\n", PORT_ErrorToString(rv));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; CERT_FinishExtensions(extHandle);

&nbsp;&nbsp;&nbsp; /* self-signing a cert request, find the private key */
 &nbsp;&nbsp;&nbsp; if (*selfsignprivkey == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *selfsignprivkey = PK11_FindKeyByDERCert(slot, subjectCert, pwarg);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!*selfsignprivkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Failed to locate private key.\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; certDER = SignCert(handle, subjectCert, selfsign, hashAlgTag,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *selfsignprivkey, issuerNickName,pwarg);
 &nbsp;&nbsp;&nbsp; if (certDER) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ascii) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "%s\n%s\n%s\n", NS_CERT_HEADER,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BTOA_DataToAscii(certDER-&gt;data, certDER-&gt;len),
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_CERT_TRAILER);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Write(outFile, certDER-&gt;data, certDER-&gt;len);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRErrorCode&nbsp; perr = PR_GetError();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to create cert %s\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perr);
 &nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; if (outFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(outFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (*selfsignprivkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPrivateKey(*selfsignprivkey);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (certReq) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificateRequest(certReq);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (subjectCert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate(subjectCert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;*&nbsp; Generate the certificate request with subject
 &nbsp;*/
 static SECStatus
 CertReq(SECKEYPrivateKey *privk, SECKEYPublicKey *pubk, KeyType keyType,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECOidTag hashAlgTag, CERTName *subject, PRBool ascii,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *certReqFileName)
 {
 &nbsp;&nbsp;&nbsp; SECOidTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signAlgTag;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result;
 &nbsp;&nbsp;&nbsp; PRInt32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numBytes;
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SECSuccess;
 &nbsp;&nbsp;&nbsp; PRArenaPool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *arena&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *extHandle&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *outFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTSubjectPublicKeyInfo *spki&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificateRequest&nbsp;&nbsp; *cr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *encoding&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; /* If the certificate request file already exists, delete it */
 &nbsp;&nbsp;&nbsp; if (PR_Access(certReqFileName, PR_ACCESS_EXISTS) == PR_SUCCESS) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Delete(certReqFileName);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; /*&nbsp; Open the certificate request file to write */
 &nbsp;&nbsp;&nbsp; outFile = PR_Open(certReqFileName, PR_CREATE_FILE | PR_RDWR | PR_TRUNCATE, 00660);
 &nbsp;&nbsp;&nbsp; if (!outFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "unable to open \"%s\" for writing (%ld, %ld).\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReqFileName, PR_GetError(), PR_GetOSError());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; /* Create info about public key */
 &nbsp;&nbsp;&nbsp; spki = SECKEY_CreateSubjectPublicKeyInfo(pubk);
 &nbsp;&nbsp;&nbsp; if (!spki) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to create subject public key\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Generate certificate request */
 &nbsp;&nbsp;&nbsp; cr = CERT_CreateCertificateRequest(subject, spki, NULL);
 &nbsp;&nbsp;&nbsp; if (!cr) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to make certificate request\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
 &nbsp;&nbsp;&nbsp; if (!arena) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "out of memory");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; extHandle = CERT_StartCertificateRequestAttributes(cr);
 &nbsp;&nbsp;&nbsp; if (extHandle == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_FreeArena (arena, PR_FALSE);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; CERT_FinishExtensions(extHandle);
 &nbsp;&nbsp;&nbsp; CERT_FinishCertificateRequestAttributes(cr);
 &nbsp;&nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; /* Der encode the request */
 &nbsp;&nbsp;&nbsp; encoding = SEC_ASN1EncodeItem(arena, NULL, cr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEC_ASN1_GET(CERT_CertificateRequestTemplate));
 &nbsp;&nbsp;&nbsp; if (encoding == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "der encoding of request failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Sign the request */
 &nbsp;&nbsp;&nbsp; signAlgTag = SEC_GetSignatureAlgorithmOidTag(keyType, hashAlgTag);
 &nbsp;&nbsp;&nbsp; if (signAlgTag == SEC_OID_UNKNOWN) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unknown Key or Hash type\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = SEC_DerSignData(arena, &amp;result, encoding-&gt;data, encoding-&gt;len,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; privk, signAlgTag);
 &nbsp;&nbsp;&nbsp; if (rv) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "signing of data failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Encode request in specified format */
 &nbsp;&nbsp;&nbsp; if (ascii) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *obuf;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *name, *email, *org, *state, *country;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECItem *it;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int total;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it = &amp;result;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obuf = BTOA_ConvertItemToAscii(it);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total = PL_strlen(obuf);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = CERT_GetCommonName(subject);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!name) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = strdup("(not specified)");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; email = CERT_GetCertEmailAddress(subject);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!email)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; email = strdup("(not specified)");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; org = CERT_GetOrgName(subject);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!org)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; org = strdup("(not specified)");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = CERT_GetStateName(subject);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!state)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = strdup("(not specified)");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; country = CERT_GetCountryName(subject);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!country)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; country = strdup("(not specified)");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\nCertificate request generated by Netscape certutil\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "Common Name: %s\n", name);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "Email: %s\n", email);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "Organization: %s\n", org);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "State: %s\n", state);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "Country: %s\n\n", country);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "%s\n", NS_CERTREQ_HEADER);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numBytes = PR_Write(outFile, obuf, total);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (numBytes != total) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "write error\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(outFile, "\n%s\n", NS_CERTREQ_TRAILER);
 &nbsp;&nbsp;&nbsp; } else {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numBytes = PR_Write(outFile, result.data, result.len);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (numBytes != (int)result.len) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "write error\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; if (outFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(outFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (privk) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPrivateKey(privk);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (pubk) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPublicKey(pubk);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Create certificate request with subject
 &nbsp;*/
 SECStatus CreateCertRequest(PK11SlotInfo *slot,
 &nbsp;&nbsp;&nbsp; secuPWData&nbsp;&nbsp; *pwdata,
 &nbsp;&nbsp;&nbsp; CERTName&nbsp;&nbsp;&nbsp;&nbsp; *subject,
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; *certReqFileName,
 &nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ascii)
 {
 &nbsp;&nbsp;&nbsp; SECStatus rv;
 &nbsp;&nbsp;&nbsp; SECKEYPrivateKey&nbsp;&nbsp;&nbsp; *privkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECKEYPublicKey&nbsp;&nbsp;&nbsp;&nbsp; *pubkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; KeyType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keytype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = rsaKey;
 &nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keysize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DEFAULT_KEY_BITS;
 &nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; publicExponent&nbsp;&nbsp; = 0x010001;
 &nbsp;&nbsp;&nbsp; SECOidTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hashAlgTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SEC_OID_UNKNOWN;

&nbsp;&nbsp;&nbsp; privkey = GeneratePrivateKey(keytype, slot, keysize,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; publicExponent, NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pubkey, NULL, pwdata);
 &nbsp;&nbsp;&nbsp; if (privkey == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "unable to generate key(s)\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; privkey-&gt;wincx = pwdata;
 &nbsp;&nbsp;&nbsp; PORT_Assert(pubkey != NULL);
 &nbsp;&nbsp;&nbsp; rv = CertReq(privkey, pubkey, keytype, hashAlgTag, subject,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ascii, certReqFileName);
 &nbsp;&nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Failed to create Certificate Request\n");
 &nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Creates the certificate using CSR and adds the certificate to DB
 &nbsp;*/
 SECStatus AddCertificateToDB(PK11SlotInfo&nbsp;&nbsp;&nbsp;&nbsp; *slot,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secuPWData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pwdata,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *certReqFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *certFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *issuerNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTCertDBHandle *certHandle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *trustStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp; serialNumber,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selfsign,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ascii)
 {
 &nbsp;&nbsp;&nbsp; SECStatus rv;
 &nbsp;&nbsp;&nbsp; SECKEYPrivateKey&nbsp;&nbsp;&nbsp; *privkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECKEYPublicKey&nbsp;&nbsp;&nbsp;&nbsp; *pubkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECOidTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hashAlgTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SEC_OID_UNKNOWN;

&nbsp;&nbsp;&nbsp; if (PR_Access(certFileName, PR_ACCESS_EXISTS) == PR_FAILURE) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = CreateCert(certHandle, slot, issuerNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReqFileName, certFileName, &amp;privkey, &amp;pwdata, hashAlgTag,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serialNumber, 0, 3, NULL, ascii, selfsign);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Failed to create Certificate\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; rv = AddCert(slot, certHandle, nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trustStr, certFileName, ascii, 0, &amp;pwdata);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Failed to add Certificate\n");
 &nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Finds the certificate using nickname and saves it to the header file
 &nbsp;*/
 SECStatus AddCertificateToHeader(PK11SlotInfo&nbsp;&nbsp;&nbsp;&nbsp; *slot,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secuPWData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pwdata,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTCertDBHandle *certHandle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigVerify)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SECSuccess;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *headerFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificate&nbsp;&nbsp;&nbsp;&nbsp; *cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; HeaderType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = CERTENC;

&nbsp;&nbsp;&nbsp; /* If the intermediate header file already exists, delete it */
 &nbsp;&nbsp;&nbsp; if (PR_Access(headerFileName, PR_ACCESS_EXISTS) == PR_SUCCESS) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Delete(headerFileName);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; headerFile = PR_Open(headerFileName, PR_CREATE_FILE | PR_RDWR | PR_TRUNCATE, 00660);
 &nbsp;&nbsp;&nbsp; if (!headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "unable to open \"%s\" for writing (%ld, %ld).\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headerFileName, PR_GetError(), PR_GetOSError());
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickNameStr);
 &nbsp;&nbsp;&nbsp; if (!cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not obtain certificate from file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (sigVerify) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hType = CERTVFY;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; WriteToHeaderFile(cert-&gt;derCert.data, cert-&gt;derCert.len, hType, headerFile);
 cleanup:
 &nbsp;&nbsp;&nbsp; if (headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(headerFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate(cert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Finds the public key from the certificate saved in the header file
 &nbsp;* and encrypts with it the contents of inFileName to encryptedFileName.
 &nbsp;*/
 SECStatus FindKeyAndEncrypt(PK11SlotInfo *slot,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secuPWData *pwdata,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *encryptedFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *inFileName)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *headerFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *encFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *inFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificate&nbsp;&nbsp;&nbsp;&nbsp; *cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data;
 &nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptext[MODBLOCKSIZE];
 &nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encBuf[MODBLOCKSIZE];
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptextLen;
 &nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nWritten;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pad[1];
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padItem;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddingLength&nbsp;&nbsp;&nbsp; = 0;
 &nbsp;&nbsp;&nbsp; SECKEYPublicKey&nbsp;&nbsp;&nbsp;&nbsp; *pubkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; /* If the intermediate encrypted file already exists, delete it*/
 &nbsp;&nbsp;&nbsp; if (PR_Access(encryptedFileName, PR_ACCESS_EXISTS) == PR_SUCCESS) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Delete(encryptedFileName);
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Read certificate from header file */
 &nbsp;&nbsp;&nbsp; rv = ReadFromHeaderFile(headerFileName, CERTENC, &amp;data, PR_TRUE);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not read certificate from header file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; /* Read in an ASCII cert and return a CERTCertificate */
 &nbsp;&nbsp;&nbsp; cert = CERT_DecodeCertFromPackage((char *)data.data, data.len);
 &nbsp;&nbsp;&nbsp; if (!cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not obtain certificate from file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; /* Extract the public key from certificate */
 &nbsp;&nbsp;&nbsp; pubkey = CERT_ExtractPublicKey(cert);
 &nbsp;&nbsp;&nbsp; if (!pubkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not get key from certificate\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*&nbsp; Open the encrypted file for writing */
 &nbsp;&nbsp;&nbsp; encFile = PR_Open(encryptedFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_CREATE_FILE | PR_TRUNCATE | PR_RDWR, 00660);
 &nbsp;&nbsp;&nbsp; if (!encFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Unable to open \"%s\" for writing.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encryptedFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*&nbsp; Open the input file for reading */
 &nbsp;&nbsp;&nbsp; inFile = PR_Open(inFileName, PR_RDONLY, 0);
 &nbsp;&nbsp;&nbsp; if (!inFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for reading.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /*&nbsp; Open the header file to write padding */
 &nbsp;&nbsp;&nbsp; headerFile = PR_Open(headerFileName, PR_CREATE_FILE | PR_RDWR | PR_APPEND, 00660);
 &nbsp;&nbsp;&nbsp; if (!headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for writing.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; /* Read input file&nbsp; */
 &nbsp;&nbsp;&nbsp; while ((ptextLen = PR_Read(inFile, ptext, sizeof(ptext))) &gt; 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ptextLen != MODBLOCKSIZE) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddingLength = MODBLOCKSIZE - ptextLen;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( index=0; index &lt; paddingLength; index++) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptext[ptextLen+index] = (unsigned char)paddingLength;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptextLen = MODBLOCKSIZE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = PK11_PubEncryptRaw(pubkey, encBuf, ptext, ptextLen, NULL);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nWritten = PR_Write(encFile, encBuf, ptextLen);
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Write the padding to header file */
 &nbsp;&nbsp;&nbsp; pad[0] = paddingLength;
 &nbsp;&nbsp;&nbsp; padItem.type = siBuffer;
 &nbsp;&nbsp;&nbsp; padItem.data = (unsigned char *)pad;
 &nbsp;&nbsp;&nbsp; padItem.len&nbsp; = sizeof(pad[0]);
 &nbsp;&nbsp;&nbsp; WriteToHeaderFile(padItem.data, padItem.len, PAD, headerFile);

cleanup:
 &nbsp;&nbsp;&nbsp; if (headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(headerFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (encFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(encFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (inFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(inFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (pubkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPublicKey(pubkey);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate(cert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Finds the private key from db and signs the contents
 &nbsp;* of inFileName and writes to signatureFileName
 &nbsp;*/
 SECStatus FindKeyAndSign(PK11SlotInfo *slot,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTCertDBHandle* certHandle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secuPWData *pwdata,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *inFileName)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *headerFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *inFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificate&nbsp;&nbsp;&nbsp;&nbsp; *cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signatureLen&nbsp;&nbsp;&nbsp;&nbsp; = 0;
 &nbsp;&nbsp;&nbsp; SECKEYPrivateKey&nbsp;&nbsp;&nbsp; *privkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigItem;
 &nbsp;&nbsp;&nbsp; SECOidTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hashOIDTag;
 &nbsp;&nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; /*&nbsp; Open the header file to write padding */
 &nbsp;&nbsp;&nbsp; headerFile = PR_Open(headerFileName, PR_CREATE_FILE | PR_RDWR | PR_APPEND, 00660);
 &nbsp;&nbsp;&nbsp; if (!headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for writing.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Get the certificate by nick name&nbsp; and write to header file */
 &nbsp;&nbsp;&nbsp; cert = CERT_FindCertByNicknameOrEmailAddr(certHandle, nickNameStr);
 &nbsp;&nbsp;&nbsp; if (!cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not obtain certificate by name - %s\n", nickNameStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; WriteToHeaderFile(cert-&gt;derCert.data, cert-&gt;derCert.len, CERTVFY, headerFile);


 &nbsp;&nbsp;&nbsp; /* Find private key from certificate&nbsp; */
 &nbsp;&nbsp;&nbsp; privkey = PK11_FindKeyByAnyCert(cert, NULL);
 &nbsp;&nbsp;&nbsp; if (privkey == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Couldn't find private key for cert\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; /* Sign the contents of the input file */
 &nbsp;&nbsp;&nbsp; rv = SignData(inFileName, privkey, &amp;sigItem);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not sign the contents from file - %s \n", inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* write signature to header file */
 &nbsp;&nbsp;&nbsp; WriteToHeaderFile(sigItem.data, sigItem.len, SIG, headerFile);

cleanup:
 &nbsp;&nbsp;&nbsp; if (headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(headerFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (privkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPrivateKey(privkey);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate(cert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Finds the public key from certificate and verifies signature
 &nbsp;*/
 SECStatus FindKeyAndVerify(PK11SlotInfo *slot,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERTCertDBHandle* certHandle,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secuPWData *pwdata,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *inFileName)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SECFailure;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *headerFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *inFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertificate&nbsp;&nbsp;&nbsp;&nbsp; *cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECKEYPublicKey&nbsp;&nbsp;&nbsp;&nbsp; *pubkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigItem;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certData;
 &nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; /* Open the input file&nbsp; */
 &nbsp;&nbsp;&nbsp; inFile = PR_Open(inFileName, PR_RDONLY, 0);
 &nbsp;&nbsp;&nbsp; if (!inFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Unable to open \"%s\" for reading.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Open the header file to read the certificate and signature */
 &nbsp;&nbsp;&nbsp; headerFile = PR_Open(headerFileName, PR_RDONLY, 0);
 &nbsp;&nbsp;&nbsp; if (!headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for writing.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Read certificate from header file */
 &nbsp;&nbsp;&nbsp; rv = ReadFromHeaderFile(headerFileName, CERTVFY, &amp;certData, PR_TRUE);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not read certificate from header file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Read in an ASCII cert and return a CERTCertificate */
 &nbsp;&nbsp;&nbsp; cert = CERT_DecodeCertFromPackage((char *)certData.data, certData.len);
 &nbsp;&nbsp;&nbsp; if (!cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not obtain certificate from file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Extract the public key from certificate */
 &nbsp;&nbsp;&nbsp; pubkey = CERT_ExtractPublicKey(cert);
 &nbsp;&nbsp;&nbsp; if (!pubkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not get key from certificate\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Read signature from header file */
 &nbsp;&nbsp;&nbsp; rv = ReadFromHeaderFile(headerFileName, SIG, &amp;sigItem, PR_TRUE);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not read signature from header file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; /* Verify with the public key */
 &nbsp;&nbsp;&nbsp; rv = VerifyData(inFileName, pubkey, &amp;sigItem, pwdata);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Couldn't verify the signature for file - %s\n", inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

cleanup:
 &nbsp;&nbsp;&nbsp; if (headerFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(headerFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (pubkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPublicKey(pubkey);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate(cert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/*
 &nbsp;* Finds the private key corresponding to the certificate saved in the header file
 &nbsp;* and decrypts with it the contents of encryptedFileName to outFileName.
 &nbsp;*/
 SECStatus FindKeyAndDecrypt(PK11SlotInfo *slot,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secuPWData *pwdata,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *headerFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *encryptedFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *outFileName)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *encFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRFileDesc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *outFile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; SECKEYPrivateKey&nbsp;&nbsp;&nbsp; *pvtkey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFileLength&nbsp;&nbsp;&nbsp; = 0;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paddingLength&nbsp;&nbsp; = 0;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;
 &nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctext[MODBLOCKSIZE];
 &nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decBuf[MODBLOCKSIZE];
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctextLen;
 &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decBufLen;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; padItem;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data;
 &nbsp;&nbsp;&nbsp; SECItem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signature;
 &nbsp;&nbsp;&nbsp; CERTCertificate&nbsp;&nbsp;&nbsp;&nbsp; *cert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; /* Read certificate from header file */
 &nbsp;&nbsp;&nbsp; rv = ReadFromHeaderFile(headerFileName, CERTENC, &amp;data, PR_TRUE);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not read certificate from header file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Read padding from header file */
 &nbsp;&nbsp;&nbsp; rv = ReadFromHeaderFile(headerFileName, PAD, &amp;padItem, PR_TRUE);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Could not retrieve PAD detail from header file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; paddingLength = (unsigned int)padItem.data[0];
 &nbsp;&nbsp;&nbsp; inFileLength = FileSize(encryptedFileName);

&nbsp;&nbsp;&nbsp; /* Read in an ASCII cert and return a CERTCertificate */
 &nbsp;&nbsp;&nbsp; cert = CERT_DecodeCertFromPackage((char *)data.data, data.len);
 &nbsp;&nbsp;&nbsp; if (!cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "could not obtain certificate from file\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Find private key from certificate&nbsp; */
 &nbsp;&nbsp;&nbsp; pvtkey = PK11_FindKeyByAnyCert(cert, NULL);
 &nbsp;&nbsp;&nbsp; if (pvtkey == NULL) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Couldn't find private key for cert\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; /* Open the out file to write */
 &nbsp;&nbsp;&nbsp; outFile = PR_Open(outFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_CREATE_FILE | PR_TRUNCATE | PR_RDWR, 00660);
 &nbsp;&nbsp;&nbsp; if (!outFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for writing.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; /* Open the encrypted file for reading */
 &nbsp;&nbsp;&nbsp; encFile = PR_Open(encryptedFileName, PR_RDONLY, 0);
 &nbsp;&nbsp;&nbsp; if (!encFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Unable to open \"%s\" for reading.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encryptedFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; /* Read the encrypt file, decrypt and write to out file */
 &nbsp;&nbsp;&nbsp; while ((ctextLen = PR_Read(encFile, ctext, sizeof(ctext))) &gt; 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += ctextLen;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = PK11_PubDecryptRaw(pvtkey, decBuf, &amp;decBufLen, sizeof(decBuf), ctext, ctextLen);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, "Couldn't decrypt\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (decBufLen == 0) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (count == inFileLength) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decBufLen = decBufLen - paddingLength;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write the plain text to out file */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp = PR_Write(outFile, decBuf, decBufLen);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (temp != decBufLen) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "write error\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; if (encFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(encFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (outFile) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Close(outFile);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (pvtkey) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECKEY_DestroyPrivateKey(pvtkey);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (cert) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CERT_DestroyCertificate(cert);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }

/* Map option letter to command */
 static CommandType option2Command(char c)
 {
 &nbsp;&nbsp;&nbsp; switch (c) {
 &nbsp;&nbsp;&nbsp; case 'G': return GENERATE_CSR;
 &nbsp;&nbsp;&nbsp; case 'A': return ADD_CERT_TO_DB;
 &nbsp;&nbsp;&nbsp; case 'H': return SAVE_CERT_TO_HEADER;
 &nbsp;&nbsp;&nbsp; case 'E': return ENCRYPT;
 &nbsp;&nbsp;&nbsp; case 'D': return DECRYPT;
 &nbsp;&nbsp;&nbsp; case 'S': return SIGN;
 &nbsp;&nbsp;&nbsp; case 'V': return VERIFY;
 &nbsp;&nbsp;&nbsp; default:&nbsp; return UNKNOWN;
 &nbsp;&nbsp;&nbsp; }
 }

/*
 &nbsp;* This example illustrates basic encryption/decryption and MACing
 &nbsp;* Generates the RSA key pair as token object and outputs public key as cert request.
 &nbsp;* Reads cert request file and stores certificate in DB.
 &nbsp;* Input, store and trust CA certificate.
 &nbsp;* Write certificate to intermediate header file
 &nbsp;* Extract public key from certificate, encrypts the input file and write to external file.
 &nbsp;* Finds the matching private key, decrypts and write to external file
 &nbsp;*
 &nbsp;* How this sample is different from sample 5 ?
 &nbsp;*
 &nbsp;* 1. As in sample 5, output is a PKCS#10 CSR
 &nbsp;* 2. Input and store a cert in cert DB and also used to input, store and trust CA cert.
 &nbsp;* 3. Like sample 5, but puts cert in header
 &nbsp;* 4. Like sample 5, but finds key matching cert in header
 */
 int
 main(int argc, char **argv)
 {
 &nbsp;&nbsp;&nbsp; SECStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv;
 &nbsp;&nbsp;&nbsp; PLOptState&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *optstate;
 &nbsp;&nbsp;&nbsp; PLOptStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status;
 &nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initialized&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = PR_FALSE;

&nbsp;&nbsp;&nbsp; CommandType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = UNKNOWN;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *dbdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; secuPWData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwdata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = { PW_NONE, 0 };

&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *subjectStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *subject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;

&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serialNumber&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *serialNumberStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *trustStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; CERTCertDBHandle&nbsp;&nbsp;&nbsp; *certHandle;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *nickNameStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *issuerNameStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selfsign&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = PR_FALSE;
 &nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ascii&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = PR_FALSE;
 &nbsp;&nbsp;&nbsp; PRBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigVerify&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = PR_FALSE;
 &nbsp;&nbsp; &nbsp;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *headerFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *encryptedFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *inFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *outFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *certReqFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *certFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; const char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *noiseFileName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;
 &nbsp;&nbsp;&nbsp; PK11SlotInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *slot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;

&nbsp;&nbsp;&nbsp; char * progName = strrchr(argv[0], '/');
 &nbsp;&nbsp;&nbsp; progName = progName ? progName + 1 : argv[0];

&nbsp;&nbsp;&nbsp; /* Parse command line arguments */
 &nbsp;&nbsp;&nbsp; optstate = PL_CreateOptState(argc, argv, "GAHEDSVad:i:o:f:p:z:s:r:n:x:m:t:c:u:e:b:v:");
 &nbsp;&nbsp;&nbsp; while ((status = PL_GetNextOpt(optstate)) == PL_OPT_OK) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (optstate-&gt;option) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'a':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ascii = PR_TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'G':&nbsp;&nbsp; /* Generate a CSR */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'A':&nbsp;&nbsp; /* Add cert to database */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'H':&nbsp;&nbsp; /* Save cert to the header file */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'E':&nbsp;&nbsp; /* Encrypt with public key from cert in header file */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'S':&nbsp;&nbsp; /* Sign with private key */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'D':&nbsp;&nbsp; /* Decrypt with the matching private key */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'V':&nbsp;&nbsp; /* Verify with the matching public key */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd = option2Command(optstate-&gt;option);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'd':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbdir = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'f':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwdata.source = PW_FROMFILE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwdata.data = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'p':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwdata.source = PW_PLAINTEXT;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pwdata.data = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'i':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inFileName = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'b':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headerFileName = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'e':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encryptedFileName = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'o':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outFileName = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'z':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noiseFileName = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 's':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subjectStr&nbsp; = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subject&nbsp;&nbsp;&nbsp;&nbsp; = CERT_AsciiToName(subjectStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'r':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReqFileName = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'c':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certFileName = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'u':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerNameStr = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'n':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nickNameStr = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'x':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selfsign = PR_TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'm':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serialNumberStr = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serialNumber&nbsp;&nbsp;&nbsp; = atoi(serialNumberStr);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 't':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trustStr = strdup(optstate-&gt;value);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'v':
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigVerify = PR_TRUE;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(progName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; PL_DestroyOptState(optstate);

&nbsp;&nbsp;&nbsp; if (cmd == UNKNOWN || !dbdir)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage(progName);

&nbsp;&nbsp;&nbsp; /* Open DB for read/write and authenticate to it */
 &nbsp;&nbsp;&nbsp; PR_Init(PR_USER_THREAD, PR_PRIORITY_NORMAL, 0);
 &nbsp;&nbsp;&nbsp; initialized = PR_TRUE;
 &nbsp;&nbsp;&nbsp; rv = NSS_InitReadWrite(dbdir);
 &nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "NSS_InitReadWrite Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; PK11_SetPasswordFunc(GetModulePassword);
 &nbsp;&nbsp;&nbsp; slot = PK11_GetInternalKeySlot();
 &nbsp;&nbsp;&nbsp; if (PK11_NeedLogin(slot)) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = PK11_Authenticate(slot, PR_TRUE, &amp;pwdata);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Could not authenticate to token %s.\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PK11_GetTokenName(slot));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; switch (cmd) {
 &nbsp;&nbsp;&nbsp; case GENERATE_CSR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateGenerateCSRCommand(progName, dbdir, subject, subjectStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReqFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Generate a CSR */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = CreateCertRequest(slot, &amp;pwdata, subject,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certReqFileName, ascii);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Create Certificate Request: Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case ADD_CERT_TO_DB:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateAddCertToDBCommand(progName, dbdir, nickNameStr, trustStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; certFileName, certReqFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerNameStr, serialNumberStr, selfsign);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Add cert to database */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = AddCertificateToDB(slot, &amp;pwdata, certReqFileName, certFileName,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerNameStr, certHandle, nickNameStr,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trustStr, serialNumber, selfsign, ascii);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Add Certificate to DB: Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case SAVE_CERT_TO_HEADER:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateSaveCertToHeaderCommand(progName, dbdir, nickNameStr, headerFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Save cert to the header file */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = AddCertificateToHeader(slot, &amp;pwdata, headerFileName, certHandle, nickNameStr, sigVerify);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Saving Certificate to header: Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case ENCRYPT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateEncryptCommand(progName, dbdir, nickNameStr, headerFileName, inFileName, encryptedFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Encrypt with public key from cert in header file */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = FindKeyAndEncrypt(slot, &amp;pwdata, headerFileName, encryptedFileName, inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Find public key and Encrypt : Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case SIGN:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateSignCommand(progName, dbdir, nickNameStr, headerFileName, inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Sign with private key */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = FindKeyAndSign(slot, certHandle, &amp;pwdata, nickNameStr, headerFileName, inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Find private key and sign : Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case DECRYPT:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateDecryptCommand(progName, dbdir, headerFileName, encryptedFileName, outFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Decrypt with the matching private key */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = FindKeyAndDecrypt(slot, &amp;pwdata, headerFileName, encryptedFileName, outFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Find private key and Decrypt : Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp; case VERIFY:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidateVerifyCommand(progName, dbdir, headerFileName, inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Verify with the matching public key */
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = FindKeyAndVerify(slot, certHandle, &amp;pwdata, headerFileName, inFileName);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rv != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Find public key and verify signature : Failed\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; }
 cleanup:
 &nbsp;&nbsp;&nbsp; if (slot) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PK11_FreeSlot(slot);
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; if (initialized) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECStatus rvShutdown = NSS_Shutdown();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rvShutdown != SECSuccess) {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_fprintf(PR_STDERR, "Failed : NSS_Shutdown() - %s",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PORT_ErrorToString(rvShutdown));
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = SECFailure;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR_Cleanup();
 &nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp; return rv;
 }
</pre>
