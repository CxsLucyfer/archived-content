<p class="summary"><span class="seoSummary">Firefox Developer Tools now has a <a href="/en-US/docs/Tools/Memory">built-in memory profiler</a>. This article details how to use an old profiler specifically designed for Firefox OS devices.</span></p>

<h2 id="Getting_the_Profiler_Add-on">Getting the Profiler Add-on</h2>

<p>The built-in memory profiler's interface is still under construction. It can be obtained by installing the <a href="https://github.com/profiler-tools/memprof-addon">Memory Profiler Add-on</a>. You may need to set the "xpinstall.signatures.required" pref to false in order to install it, since the XPI is not yet signed.</p>

<h2 id="Using_the_Add-on">Using the Add-on</h2>

<p>Open the devtools panel or WebIDE. Select the <code>MemoryProfiler</code> tab. To take a profile you can use the buttons in the profiler panel.</p>

<ul>
 <li>Start - start profiling</li>
 <li>Stop - stop profiling</li>
 <li>Reset - clear profile data when profiler is stopped</li>
</ul>

<div class="note">
<p>Profile data is accumulated and resumed after <strong>start</strong>. Use <strong>reset</strong> to start a new recording.</p>
</div>

<p><img alt="" src="https://mdn.mozillademos.org/files/11939/Screenshot%20from%202015-11-16%2018%3A42%3A54.png" style="width: 100%;"></p>

<h2 id="Understanding_the_Profiles">Understanding the Profiles</h2>

<p>Traditional memory analysis tools look at the data. They build the referring-to, namely retaining graphs. This is helpful in exploring the relationships among objects and identifying memory leaks. However, the information exposed in this way is usually a snapshot and the history of how memory has been used goes missing. Moreover, they usually don't keep tracks of how objects are allocated. Developers have to infer how an object might be allocated and freed by himself/herself.</p>

<p>Another common approach is to plot the allocations or the memory usages along the timeline. This gives some intuition of how and when a bulk of objects are allocated. However, it still relies on developers' wisdom, and sometimes chances, to dig out the problematical code snippet.</p>

<p>This memory profiler is designed to solve the inconveniences and limitations. The goal is to identify the memory eager codes directly.</p>

<p>The profiler is designed at the very beginning to support not only JavaScript but also native codes. Naturally, not only JavaScript objects but also native allocations are tracked. The profile while recording is stored in memory in a very compact format. It's supposed to profile a very long time period without problem.</p>

<h3 id="Timeline_view">Timeline view</h3>

<p>This view shows the allocation event across the period of time. It shows the overall memory usage history. Red is allocate and blue is deallocate.</p>

<p><img alt="" src="https://mdn.mozillademos.org/files/11935/Screenshot%20from%202015-11-16%2018%3A22%3A33.png" style="width: 100%;"></p>

<h3 id="Rank-list_view_and_tree_view">Rank-list view and tree view</h3>

<p>The rank-list view shows top functions that are most memory eager. The table could be sorted according to the 6 measurements: {retained, allocated, peak} x {self, inclusive}.</p>

<p>The tree view shows functions as call trees. Each alloctaion root could be expanded to leaf functions that actually allocates memory.</p>

<p><img alt="" src="https://mdn.mozillademos.org/files/11937/Screenshot%20from%202015-11-16%2018%3A24%3A38.png" style="width: 100%;"></p>

<h2 id="Contribute">Contribute</h2>

<p>The memory profiler project page is at <a href="https://wiki.mozilla.org/MemoryProfiler">https://wiki.mozilla.org/MemoryProfiler</a>.</p>