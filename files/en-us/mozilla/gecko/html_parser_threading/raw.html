<h2 id="HTML_Parser_Threading">HTML Parser Threading</h2>
<p>The HTML parser parses data received from the network off the main thread. (There's currently one parser thread serving all parser instances.) Data received from <code>document.write()</code> is parsed on the main thread.</p>
<h3 id="Main_Objects">Main Objects</h3>
<p><code>nsHtml5Parser</code> contains the code for dealing with data from <code>document.write()</code>. (For historical reasons, it also contains unrelated fragment parsing code that should be refactored into a separate class in due course.) <code>nsHtml5StreamParser</code> contains the code for dealing with data from the network. <code>nsHtml5Parser</code> owns <code>nsHtml5StreamParser</code>. Script-created parsers (i.e. parsers created using <code>document.open()</code>) don't have an <code>nsHtml5StreamParser</code> instance.</p>
<p><code>nsHtml5Parser</code> has one tokenizer/tree builder pair for parsing data from <code>document.write()</code>. It also has another lazily initialized tokenizer/tree builder for speculatively scanning the tail of <code>document.write()</code> data when the parser blocks without parsing the <code>document.write()</code> data to completion.</p>
<p><code>nsHtml5StreamParser</code> has one tokenizer/tree builder pair for parsing data from the network.</p>
<p>Additionally, each <code>nsHtml5Parser</code> has an associated <code>nsHtml5TreeOpExecutor</code> that turns the output (tree operations; discussed later) of the portable parser core into actions performed on the Gecko DOM.</p>
<h3 id="Initialization">Initialization</h3>
<p>An <code>nsHtml5Parser</code> is constructed without an <code>nsHtml5StreamParser</code> due to legacy code structure around parser creation. If the parser is not script-created, <code>nsHtml5Parser::MarkAsNotScriptCreated()</code> is called to create an <code>nsHtml5StreamParser</code> for the <code>nsHtml5Parser.</code></p>
<p>Due to legacy interface design oddities, an <code>nsHtml5Parser</code> is initialized by calling <code>nsHtml5Parser::Parse(nsIURI*, nsIRequestObserver*, void*, nsDTDMode)</code>. That method call doesn't yet cause anything to be parsed, though. Actual network data is passed to an <code>nsIStreamListener</code>. <code>nsHtml5StreamParser</code> is the <code>nsIStreamListener</code> implementation obtained by calling <code>nsIStreamListener* </code><code>nsHtml5Parser::GetStreamListener().</code></p>
<p>The <code>nsIStreamListener</code> methods (<code>OnStartRequest</code>, <code>OnDataAvailable</code> and <code>OnStopRequest</code>) are called on the main thread. <code>OnStartRequest</code> does all sorts of initialization on the main thread. At that point, nothing has happened on the parser thread yet and the <code>nsHtml5StreamParser</code> lives fully on the main thread.</p>
<h3 id="Passing_Data_to_the_Parser_Thread">Passing Data to the Parser Thread</h3>
<p><code>nsHtml5StreamParser</code> gets some of its methods called on the main thread and some called on the parser thread. The method implementations assert which thread they are supposed to be called on.</p>
<p><code>OnDataAvailable</code> and <code>OnStopRequest</code> on the main thread post runnables on to the parser thread. There runnables obtain <code>mTokenizerMutex</code> and call <code>DoDataAvailable</code> and <code>DoStopRequest</code>, repectively, on the parser thread. These two methods along with <code>TimerFlush</code> (discussed later) are the entry points from the parser thread event loop into <code>nsHtml5StreamParser.</code></p>
<p>The runnables hold <code>mTokenizerMutex</code> for the entire duration of the <code>DoDataAvailable</code> or <code>DoStopRequest</code> call. <code>mTokenizerMutex</code> protects most data structures on <code>nsHtml5StreamParser</code> from concurrent access.</p>
<p>The runnables need to keep the <code>nsHtml5StreamParser</code> instance alive, so they have to <code>AddRef</code> it. However, if they <code>Release</code>d on the parser thread, <code>nsHtml5StreamParser</code> could be <code>delete</code>d from the parser thread, which would lead to all sorts of badness, because <code>nsHtml5StreamParser</code> has fields that hold objects that aren't safe to <code>Release</code> except from the main thread. The runnables use <code>nsHtml5RefPtr&lt;nsHtml5StreamParser&gt;</code>. <code>nsHtml5RefPtr</code> sends runnables back to the main thread to call Release on <code>nsHtml5StreamParser</code> on the main thread.</p>
<h3 id="Normal_(Non-Speculative)_Parsing">Normal (Non-Speculative) Parsing</h3>
<p>Initially, <code>DoDataAvailable</code> performs character encoding sniffing on the data if an encoding wasn't declared on the enclosing protocol (HTTP) level. Once a Unicode decoder has been set up, <code>DoDataAvailable</code> passes the byte data to the decoder whose output is accumulated into a linked list of <code>nsHtml5OwningUTF16Buffer</code> objects.</p>
<p><code>nsHtml5OwningUTF16Buffer</code> objects are then passed to the tokenizer in sequence by the <code>ParseAvailableData()</code> method. The tokenizer calls into the tree builder which outputs <code>nsHtml5TreeOperation</code> objects (tree ops) into a queue. Each tree op represents a small operation, such as element creation or appending a node into another, that can later be performed on the main thread.</p>
<p>Note that <code>mTokenizerMutex</code> is being held by the parser thread for the entire time that the tokenizer runs. <code>ParseAvailableData()</code> checks for parser termination or interruption from time to time. The termination and interruption indicators are guarded by a more narrowly scoped <code>mTerminatedMutex</code>, so <code>ParseAvailableData()</code> has the opportunity to receive an order to terminate or interrupt even while the parser thread is holding <code>mTerminatedMutex</code>.</p>
<p>The tree op queue is flushed to the main thread from time to time. There's a timer that calls <code>TimerFlush()</code> (which takes <code>mTokenizerMutex</code>). Tree ops from the queue in the tree builder are moved to a tree op stage (<code>nsHtml5TreeOpStage)</code>. The staging queue is protected by a mutex. This way, the queues into which tree ops are produced and the queues from which they are consumed don't need to involve a mutex on each modification. It's more efficient to obtain a mutex only every once in a while when a whole bunch of tree ops is moved to or from the staging queue.</p>
<p>After some tree ops have been moved to the staging queue, the <code>nsIRunnable</code> held in <code>mExecutorFlusher</code> is dispatched to the main thread. (The same runnable is used repeatedly in order to avoid cross-thread refcounting issues.)</p>
<h3 id="Memory_Management_When_Crossing_the_Thread_Boundary">Memory Management When Crossing the Thread Boundary</h3>
<p>The tree ops hold various heap-allocated objects that end up crossing the thread boundary. These objects are memory managed as follows:</p>
<p>Attribute holders (<code>nsHtml5HtmlAttributes</code> objects) are allocated using <code>new</code> by the tokenizer. The tree builder either transfers an attribute holder to a tree op whose destructor explicitly <code>delete</code>s the attribute holder or if the tree builder ends up ignoring an attribute holder, the tree builder <code>delete</code>s the attribute holder explicitly.</p>
<p>Attribute values, public identifiers (in doctype) and system identifiers (in doctype) are heap-allocated <code>nsString</code> objects (i.e. pointed to by <code>nsString*</code>!). Attribute values <code>nsStrings</code> are deleted by the attribute holder when it gets deleted. Public identifiers and system identifiers are deleted by the tree op or by the portable parser core if they don't make it as far a tree op. The backing <code>nsStringBuffer</code>s are thread-safely refcounted appropriately when the <code>nsString</code> goes away. (Aside: It would make more sense to make the parser deal with <code>nsStringBuffer</code>s directly without having heap-allocated <code>nsString</code>s involved.)</p>
<p>Element names, attribute names and the doctype name are represented as <code>nsIAtom</code>s. Pre-interned attribute and element names hold atoms that are actually app-wide <code>nsStaticAtom</code>s. Since <code>nsStaticAtom</code>s are valid app-wide, these atoms work right app-wide on the main thread. For other atoms, the parser uses <code>nsHtml5Atom</code> objects that are atomic only within the scope of an <code>nsHtml5AtomTable</code>. There is one <code>nsHtml5AtomTable</code> per each <code>nsHtml5Parser</code> and one per each <code>nsHtml5StreamParser</code>. Thus, each tokenizer/tree builder pair sees atoms that are atomic (pointer-comparable) within the tokenizer/tree builder pair. However, when tree ops are executed, every atom has to be tested for being a static atom (using <code>IsStaticAtom()</code>). If the atom isn't static, a corresponding normal main-thread dynamically-allocated atom has to be obtained for the same string and used instead of the <code>nsHtml5Atom</code>. <code>nsHtml5Atom</code> objects are guaranteed to be immutable and to stay alive for the lifetime of the parser instance, so it's safe for the main thread to call their methods (as is necessary to find the corresponding normal atom).</p>
<p>References to DOM nodes in tree ops are of type <code>nsIContent**</code> and are called content handles. A handle points to memory allocated by the tree builder and guaranteed to stick around for the life time of the parser. The tree builder never dereferences a content handle. In fact, a content handle won't have an actual node behind it initially. Only when the tree op executor executes a node creation tree op, the <code>nsIContent*</code> that points to the node gets written to the memory location pointed to by the <code>nsIContent**</code>. For any given content handle, the node creation tree op is always the first tree op in queue that uses that handle, so subsequent non-creation tree ops can safely dereference the handle to obtain a real node. Nodes created by tree ops are owned by the parser for the lifetime of the parser, so for refcounting purposes, the parser owns each <code>nsIContent</code> object it creates by one reference no matter how many copies of the content handle for the node exist inside the parser. (This indeed means that removing parser-created nodes from the DOM during parsing doesn't release memory until the parser stops parsing, which is, in theory, a problem for long polling using HTML in an iframe e.g. for a chat app.)</p>
<p>Some tree ops hold <code>char</code> or <code>PRUnichar</code> arrays. Those arrays are allocated when creating the tree op and <code>delete[]</code>d by the destructor of <code>nsHtml5TreeOperation</code>. Hence, data gets copied to and from these arrays.</p>
<h3 id="Executing_Tree_Ops">Executing Tree Ops</h3>
<p>When the executor flushing runnable fires on the main thread, it calls <code>nsHtml5TreeOpExecutor::RunFlushLoop()</code>. This method returns immediately if another invocation of it is already on the call stack (nested event loop case). The method then enters a loop that has a bunch of return conditions (including parser termination).</p>
<p>The loop first flushes speculative loads (creation discussed later). If the executor is reading from a stage (i.e. the ops are coming from the parser thread), the executor moves the tree ops from the staging queue into its own queue. (Again, here we get to move a bunch of tree ops by obtaining a mutex once instead of having to synchronize thread on a per-tree op basis.) If the executor isn't reading from a stage, it calls <code>nsHtml5Parser::ParseUntilBlocked()</code> to parse potential <code>document.write()</code>-generated data into tree ops.</p>
<p>The outer loop then has an inner loop that iterates over the tree ops in the executor's queue and calls Perform on each one. Parser termination is checked before each tree op for an early return, because, unfortunately, Gecko expects parsers to be able to terminate immediately. After each tree op except the last one in the queue, the clock time is checked to see if <code>RunFlushLoop()</code> has spent too much time without returning to the event loop. If too much time has been spent, a runnable for calling <code>RunFlushLoop()</code> again is dispatched and an early return made before all tree ops have been executed. (Only the already executed ops are destructed and the rest are left in the queue.)</p>
<p>The last op in the queue may be an op for attempting to execute a script that may block the parser (ops for attempting to execute async and defer scripts are normal tree ops and don't need to be the last op in a queue). The parts of the parser that drive the tokenizer/tree builder pairs guarantee to flush tree ops immediately if a script execution tree op is generated. (The tree builder makes the tokenizer return immediately when such an op is generated.) Thus, a tree op that may cause the parser to block can only occur as the last op in a queue that <code>RunFlushLoop</code> sees.</p>
<h3 id="Preparing_the_Parser_Thread_for_Script_Execution">Preparing the Parser Thread for Script Execution</h3>
<p>When the parser thread sees that it has generated a tree op that attempts to execute a (non-async, non-defer) script, it starts speculating. It acquires <code>mSpeculationMutex</code> and while holding it, it creates a new speculation and adds it to the queue of speculations, flushes the tree ops to the main thread, marks the <code>nsHtml5StreamParser</code> as being in a speculating state and sets the newly created speculation object as the tree op sink (instead of the tree op stage described earlier) of the tree builder. The speculation object has a queue of tree ops (into which the tree builder will now flush ops to instead of the tree op stage), an owning reference to the <code>nsHtml5OwningUTF16Buffer</code> that contains the starting point of the speculation, an index into the <code>nsHtml5OwningUTF16Buffer</code> defining the exact starting point within the buffer, the line number of the tokenizer at that point and a snapshot of the tree op state. The line number and the snapshot are also added to the tree op that attempts to execute scripts (before flushing it).</p>
<p>The tree builder snapshot contains a copy of the tree builder stack, a copy of the list of open formatting elements and copies of various fields that define the tree builder state. It contains all the information that is necessary to load back into the tree builder to restore it into a behaviorally equivalent state.</p>
<p>The flush timer is disengaged, because it's not useful to make the tree builder flush ops into the queue of the speculation incrementally.</p>
<p>After the speculation has been started and <code>mSpeculationMutex</code> released, the parser thread will parse incoming data and the tree builder will produce tree ops so that they get flushed into the queue in the speculation object.</p>
<p>If another tree op that attempts to execute a script is generated while speculating, another speculation object is initialized as described above and placed in the queue of speculation objects after the previous one.</p>
<p>It is possible that the parser thread ends up parsing all remaining data into speculations before the main thread is ready to receive more tree ops.</p>
<h3 id="Attempting_to_Execute_a_Script">Attempting to Execute a Script</h3>
<p>On the main thread, when the tree op executor executes a tree op that attempts to execute a script, the tree op is first checked for a tree builder state snapshot. There will be a snapshot if the tree op came from the parser thread. There won't be one if the tree op came from <code>document.write()</code> on the main thread (discussed later). If there is a snapshot, the tokenizer used for parsing <code>document.write()</code>-originating data on the main thread is reset to the data state. There's no need to snapshot the tokenizer state, because the state of the tokenizer is always the same immediately after the tokenizer has emitted a script end tag. Then the tree builder that is used for parsing <code>document.write()</code>-originating data is initialized from the state snapshot. Now the tokenizer/tree builder pair used for parsing <code>document.write()</code> data is in the same state that the off-the-main-thread tokenizer/tree builder pair was immediately after processing the script end tag.</p>
<p>The tree op executor then attempts to execute the script. This operation either executes an inline script right away or tells the parser to block (for external scripts). If the parser is told to block, the script loader will unblock the parser before the external script executes. If the script was executed without blocking, the executor dispatches an event to reflush itself. (Remember that reflushing ends up calling <code>nsHtml5Parser::ParseUntilBlocked()</code>. That method is responsible for moving back to consuming tree ops from the parser thread via the staging area.)</p>
<h3 id="document.write()"><code><code>document.write()</code></code></h3>
<p>Calls to <code>document.write()</code> push data to the tokenizer/tree builder pair that exists on the main thread solely for parsing data from <code>document.write()</code>. If the parser isn't blocked, <code>document.write()</code> parses input into tree ops synchronously and flushes the tree ops synchronously by calling <code>nsHtml5TreeOpExecutor::FlushDocumentWrite()</code>. Unlike <code>nsHtml5TreeOpExecutor::RunFlushLoop()</code>, <code>nsHtml5TreeOpExecutor::FlushDocumentWrite()</code> does not sample the clock to return early.</p>
<p>Inline scripts that arrive from <code>document.write()</code> are executed synchronously (if the parser isn't already blocked). External scripts arriving from <code>document.write()</code> block the parser.</p>
<p>If there is data in <code>document.write()</code> input after a an external script (or any data at all if a previous <code>document.write()</code> call has contained an external script and blocked the parser), the data is left in a linked list of <code>nsHtml5OwningUTF16Buffer</code> objects. (How exactly data is inserted into the buffer list depends on parser keys when <code>document.write()</code> is invoked re-entrantly, but that's outside the scope of this document, since this document is about parser threading.)</p>
<p>Whenever the argument of <code>document.write()</code> isn't tokenized to completion synchronously, the part left unprocessed by the main <code>document.write()</code> tokenizer/tree builder is processed by the third tokenizer/tree builder pair. The tree ops from that processing are ignored and only speculative loads are used. (Speculative loads are discussed later.) The third tokenizer/tree builder pair is initialized from the state of the main <code>document.write()</code> tokenizer/tree builder pair but can get into an inconsistent state if <code>document.write()</code> is invoked re-entrantly. This is OK, because the tree ops aren't used and it's mostly harmless if the speculative loads are wrong.</p>
<p>After an external script finishes executing, it dispatches an event to reflush the tree op executor. The reflush causes a call to <code>nsHtml5Parser::ParseUntilBlocked()</code>. <code>ParseUntilBlocked()</code> parses data left by <code>document.write()</code> in the linked list of buffers, because the parser was blocked. This might cause more script execution tree ops to be generated and executed and <code>document.write()</code> to be called more times.</p>
<p>When <code>ParseUntilBlocked()</code> exhausts the data available to it, it calls <code>nsHtml5StreamParser::ContinueAfterScripts</code> to resume the consumption of data from the network.</p>
<h3 id="Continuing_to_Use_Network-Originating_Data_After_Scripts">Continuing to Use Network-Originating Data After Scripts</h3>
<p><code>nsHtml5StreamParser::ContinueAfterScripts</code> runs on the main thread. It acquires <code>mSpeculationMutex</code> in order to be able to touch the queue of speculations. The mutex acquisition only blocks if the parser thread happens to be setting up a new speculation object at the same moment.</p>
<p>The first speculation in the speculation queue is examined. If the last character seen by the <code>document.write()</code> tokenizer was not a carriage return, if the <code>document.write()</code> tokenizer is in the "data" state and if the tree builder state snapshot on the speculation matches the state of the <code>document.write()</code> tree builder, the speculation has succeeded. Otherwise it has failed.</p>
<p>If there is more than one speculation in the queue and if the speculation is successful, we can dequeue the first speculation while holding <code>mSpeculationMutex</code> without bothering the parser thread. In this case, the tree ops from the speculation are flushed into the tree op executor and <code>ContinueAfterScripts()</code> returns early. (<code>nsHtml5TreeOpExecutor::RunFlushLoop</code> is on the call stack already in this case and will loop around to start flushing the ops right away.)</p>
<p>If there's only one speculation or the speculation failed, it's necessary to bother the parser thread. In that case, the main thread raises an interruption flag on the <code>nsHtml5StreamParser</code> object to make the parser thread release <code>mTokenizerMutex</code> earlier. The main thread then attempts to acquire <code>mTokenizerMutex</code>.</p>
<p>If the single speculation is successful, the tree ops from the parser-thread tree builder are flushed straight to the tree op executor and the tree op stage is set as the tree op sink for the tree builder. The executor is told that it's reading from the stage again.</p>
<p>If the speculation failed, the first buffer corresponding to the starting point of the speculation gets its start index restored to the index stored on the speculation object. Subsequent buffers get their start index reset back to zero. The tokenizer gets its line number restored from the speculation object. This is equivalent to rewinding the input to where it was when speculation started.</p>
<p>All the speculations in the speculation queue are destroyed. Pending tree ops in the tree builder are cleared.</p>
<p>The tree op stage is set as the tree op sink for the tree builder. The executor is told that it's reading from the stage again.</p>
<p>The state of the main-thread tokenizer is copied to the parser-thread tokenizer. Likewise for the tree builders. The "last was carriage return" flag is copied over also.</p>
<p>A runnable is dispatched to the parser thread to call to mark the parser uninterrupted and to call <code>nsHtml5StreamParser::ParseAvailableData()</code> on the parser thread.</p>
<p><code>mTokenizerMutex</code> is released.</p>
<h3 id="Speculative_Loads">Speculative Loads</h3>
<p>When the tree builder on the parser thread encounters HTML <code>script</code>, stylesheet <code>link</code>, <code>video</code> (with a poster frame), <code>base</code> or <code>img</code> or SVG <code>script</code>, <code>style</code> or <code>image</code> elements, preload operations are appended to a speculative load queue. There speculative load operations are flushed to the main thread (via the staging area) whenever tree ops are flushed and also whenever <code>nsHtml5StreamParser::ParseAvailableData()</code> is about to stop working. That is, when the parser thread is parsing speculatively, speculative loads continue to be flushed to the main thread even though tree ops accumulate into the speculations.</p>
<p>On the main thread, the speculative tokenizer/tree builder pair used for parsing <code>document.write()</code> input that didn't get parsed by the main <code>document.write()</code> tokenizer/tree builder synchronously also sends speculative loads to the tree op executor.</p>
<p>The executor acts on the speculative load queue when the runnable dispatched by <code>nsHtml5StreamParser::ParseAvailableData()</code> fires and right before executing tree ops whenever tree ops are executed.</p>
<p>When the executor acts on speculative loads, it starts speculative HTTP fetches for images (including video poster frames), style sheets and scripts.</p>
<p>Additionally, the speculative load queue is used for transferring information from the parser thread to the main thread when the information needs to arrive before starting any speculative loads and when the information is known not to be speculative. There are two such pieces of information: the manifest URL for an App Cache manifest and the character encoding for the document.</p>