<p></p><section class="Quick_links" id="Quick_Links">

<ol>
 <li data-default-state="closed"><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS">Build and install</a>
  <ol>
   <li><strong><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS">Build and install overview</a></strong></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS/B2G_OS_build_process_summary">B2G OS build process summary</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/B2G_OS_build_prerequisites">Build prerequisites</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Preparing_for_your_first_B2G_build">Preparing for your first build</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building">Building B2G OS</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS/B2G_installer_add-on">B2G installer add-on</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS/Building_for_Flame_on_OS_X">Building B2G OS for Flame on Mac OS X</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Choosing_how_to_run_Gaia_or_B2G">Choosing how to run Gaia or B2G OS</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS/Compatible_Devices">Compatible Devices</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Installing_on_a_mobile_device">Installing B2G OS on a mobile device</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS/B2G_OS_update_packages">Creating and applying B2G OS update packages</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building/FOTA_community_builds">Building and installing FOTA community builds</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Building_and_installing_B2G_OS/B2G_Build_Variables_Reference_Sheet">B2G build variables reference sheet</a></li>
  </ol>
 </li>
 <li data-default-state="closed"><a href="/en-US/docs/Mozilla/B2G_OS/Porting_B2G_OS">Porting B2G OS</a>
  <ol>
   <li><strong><a href="/en-US/docs/Mozilla/B2G_OS/Porting_B2G_OS">Porting overview</a></strong></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Porting_B2G_OS/basics">Porting basics</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Porting_B2G_OS/Porting_on_CyanogenMod">Porting on CyanogenMod</a></li>
  </ol>
 </li>
 <li data-default-state="closed"><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia">Developing Gaia</a>
  <ol>
   <li><strong><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia">Developing Gaia overview</a></strong></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Running_the_Gaia_codebase">Running the Gaia codebase</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Mulet">Run Gaia on desktop using Mulet</a></li>

   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Understanding_the_Gaia_codebase">Understanding the Gaia codebase</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Making_Gaia_code_changes">Making Gaia code changes</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Testing_Gaia_code_changes">Testing Gaia code changes</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Submitting_a_Gaia_patch">Submitting a Gaia patch</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Build_System_Primer">Gaia build system primer</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Different_ways_to_run_Gaia">Different ways to run Gaia</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/make_options_reference">Make options reference</a></li>
   <li><a href="/en-US/docs/Mozilla/B2G_OS/Developing_Gaia/Gaia_tools_reference">Gaia tools reference</a></li>
  </ol>
 </li>
 <li><a href="/en-US/docs/Mozilla/B2G_OS/API">B2G OS APIs</a></li>
</ol>
</section><p></p><div class="summary">
<p><span class="seoSummary">This document covers running and writing integration tests for Gaia apps — written in JavaScript and run via Marionette — and provides a detailed explanation of how the integration tests are run.</span></p>
</div>

<h2 id="Running_tests">Running tests</h2>

<p>This section looks at setting up your environment correctly to run the existing integration test suite. The prerequisite is a working clone of the <a href="https://github.com/mozilla-b2g/gaia">gaia repository</a>. Note that tests live with the rest of the apps code (in <code>apps/my_app/test/marionette</code> for example) and test files always end in <code>_test.js</code>. Shared code for tests lives under <code>shared/test/integration</code>.</p>

<h3 id="Setup">Setup</h3>

<div class="note">
<p><strong>Shortcut</strong>: If you don't want to mess with your own environment, you can try <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox_OS/Automated_testing/MozITP">MozITP</a> — this toolset will automatically setup a pre-configured Ubuntu VM and Gaia Integration Test environment, allowing you can start testing on Mulet or a real device in one click.</p>
</div>

<p>As of late November 2015, to setup your environment for running tests on the master branch you need:</p>

<ul>
 <li>Node 4 (we recommend 4.2.2; the LTS branch for this to work predictably, see the <a href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager">detailed instructions on installing node on different platforms</a>.) You can also use tools like <a href="https://github.com/creationix/nvm/">nvm</a>, or even install the zip file and manage the symbolic links manually.) Fortunately this will install the correct version of npm as well.</li>
 <li>clang.</li>
</ul>

<h3 id="Running_all_the_tests">Running all the tests</h3>

<p>The following command runs all the integration tests for all the apps. It will also install the marionette-js-runner and associated Node.js modules if not already done.</p>

<pre class="brush: bash">make test-integration
</pre>

<div class="warning">
<p><strong>Important:</strong> If you get the error:</p>

<p><code>npm ERR! 404 'gaia-marionette' is not in the npm registry.</code></p>

<p>Make sure you really have npm 2.0.</p>
</div>

<p>You will get to watch the tests pop up on your screen and you will probably also get to hear various sounds as they run.  This can be distracting or possibly maddening. To run specific tests you can set the TEST_FILES environment variable. To do so in the bash shell (default on Mac OS X), use a command of the form:</p>

<pre class="brush: bash"><span class="nv">TEST_FILE</span><span class="o">S=</span>&lt;<span class="nb">test</span>&gt; make <span class="nb">test</span>-integration</pre>

<p>For example, you could run the <code>day_view_test.js</code> test in calendar app with the below command.</p>

<pre class="brush: bash">TEST_FILES=./apps/calendar/test/marionette/day_view_test.js make test-integration</pre>

<p>If you would like to run more than one test, use a space-separated list of files within the TEST_FILES variable:</p>

<pre class="brush: bash">TEST_FILES="./apps/calendar/test/marionette/day_view_test.js ./apps/calendar/test/marionette/today_test.js" make test-integration</pre>

<h3 id="Invoking_tests_for_a_specific_app">Invoking tests for a specific app</h3>

<p>To run just the tests for a specific app, you can use the following form:</p>

<div class="highlight highlight-sh">
<pre class="brush: bash">make <span class="nb">test</span>-integration <span class="nv">APP</span><span class="o">=</span>&lt;APP&gt;
</pre>
</div>

<p>For example, you could run all tests for the calendar app with</p>

<pre class="brush: bash">make test-integration APP=calendar</pre>

<h3 id="Running_the_tests_in_the_background_quietly">Running the tests in the background, quietly</h3>

<p>You might want to run the tests in the background, meaning that you won't have to see the tests run, worry about them stealing your focus, or risk impacting the running tests. One solution is to use Xvfb:</p>

<div class="highlight highlight-sh">
<pre class="brush: bash">xvfb-run make <span class="nb">test</span>-integration
</pre>
</div>

<p class="brush: bash">You can also run Xephyr:</p>

<pre class="brush: bash"><code># In one terminal
Xephyr :1 -screen 500x700

# in another terminal
DISPLAY=:1 make test-integration</code></pre>

<p>If you are using PulseAudio and want to keep the tests quiet, then you can specify <code><span class="nv">PULSE_SERVER</span><span class="o">=</span><span class="s2">":"</span></code> to force an invalid server so no sound is output:</p>

<pre class="brush: bash">PULSE_SERVER=":" make test-integration</pre>

<p>You can of course combine both:</p>

<pre class="brush: bash">PULSE_SERVER=":" xvfb-run make test-integration</pre>

<h3 id="Running_tests_without_building_a_profile">Running tests without building a profile</h3>

<p>If you would like to run tests without building a profile, use <code>make test-integration-test</code>:</p>

<pre class="brush: bash">PROFILE_FOLDER=profile-test make # generate profile directory in first time
make test-integration-test</pre>

<h3 id="Running_tests_with_a_custom_B2G_Desktop_build">Running tests with a custom B2G Desktop build</h3>

<p>By default, the test harness downloads a prebuilt version of B2G Desktop and runs the tests with that.</p>

<p>Sometimes, you want to run the tests with a custom build of B2G Desktop instead (for example, to test a local Gecko patch). To do this, first build B2G Desktop as described <a href="https://developer.mozilla.org/en-US/Firefox_OS/Building_the_B2G_desktop_client">here</a>, and then run:</p>

<pre class="brush: bash">RUNTIME=&lt;path to objdir of b2g desktop build&gt;/dist/bin/b2g make test-integration
</pre>

<p>On OS X, you need to run the B2G Desktop app from within its bundle, so run:</p>

<pre class="brush: bash">RUNTIME=&lt;path to objdir of b2g desktop build&gt;/dist/B2G.app/Contents/MacOS/b2g make test-integration
</pre>

<h3 id="Running_tests_on_device">Running tests on device</h3>

<p>You can run tests on device by plugging in your phone and adding the BUILDAPP=device to the <code>make</code> command:</p>

<pre class="brush: bash" style="font-size: 14px;">BUILDAPP=device make test-integration
</pre>

<div>
<h3 id="Skipping_a_test_file">Skipping a test file</h3>

<p>You can skip certain test files with the following command:</p>

<pre class="brush: bash">SKIP_TEST_FILES="/abs/path/to/skipped_test.js /abs/path/to/other/skipped_test.js" make integration
</pre>
</div>

<h3 id="Debugging_Tests">Debugging Tests</h3>

<p>To view gecko log output from a test, use the following:</p>

<pre class="brush: bash">HOST_LOG=stdout make test-integration  # Pipes logs from gecko process to your node process
VERBOSE=1 make test-integration        # Proxies console.* api calls to your node process
NODE_DEBUG=* make test-integration     # Enables debugging logs from the internal module called module</pre>

<h2 id="Troubleshooting">Troubleshooting</h2>

<p>This section goes over some problems you may encounter while trying to run the integration tests.</p>

<h3 id="Running_on_Linux">Running on Linux</h3>

<p>The test harness seems to assume that the "node" command resolves to the Node.js executable. On some Linux distributions, this is not the case, even when Node.js is installed. For example, on Debian Jessie, the "node" command is provided by the <a href="https://packages.debian.org/jessie/node">"Amateur Packet Radio Node program" package</a>, and Node.js is available under the "nodejs" command instead.</p>

<p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1136831">Bug 1136831</a> is on file for this problem. In the meantime, a workaround is to symlink "node" to point to "nodejs". On Debian you can install the package <code>nodejs-legacy</code> to fix this:</p>

<pre class="brush: bash"><code>apt-get install nodejs-legacy</code></pre>

<h3 id="If_Marionette-JS_Starts_To_Throw_Errors">If Marionette-JS Starts To Throw Errors</h3>

<p>There are times where your test runs may leave B2G in a state that causes errors to be thrown if you try to run tests. We basically need to get B2G back to a clean state.</p>

<pre class="brush: bash">make really-clean          # This will remove all downloaded parts of B2G
make reset-gaia            # This will reset the device and reinstall FXOS</pre>

<p>You may have to run this on the Aries to reset the device</p>

<pre class="brush: bash">adb root                   # Run root level commands on your device</pre>

<h3 id="Troubleshooting_Mac_OSX_El_Capitan">Troubleshooting  Mac OSX El Capitan</h3>

<p>If you already have Firefox Nightly installed on your system, the tests may not run. The tests now run with Firefox Nightly, and pointing them to a custom version of the B2G simulator as described in the sections above will fail. Instead, you'll need to run the tests pointing to your installation of Firefox Nightly on your Mac. Run the following command to execute the tests:</p>

<pre class="brush: bash">$ RUNTIME=/Applications/FirefoxNightly.app/Contents/MacOS/firefox make test-integration</pre>

<h2 id="Use_cases_and_design_patterns">Use cases and design patterns</h2>

<p>This section explores some use cases and design patterns that can help make the JavaScript Marionette tests we write more maintainable.</p>

<h3 id="What_are_common_things_for_ui_tests_to_do">What are common things for ui tests to do?</h3>

<div class="note">
<p>Marionette tests simulate users interacting with apps.</p>
</div>

<p>In the abstract, your marionette tests will test your app by interacting with it as a real user would. What do Firefox OS app users do? Here are some examples:</p>

<ul>
 <li>Launch an app</li>
 <li>Click or swipe inside of an app</li>
 <li>Read text in an area of an app</li>
 <li>Wait for the UI to update with some new content or a new view</li>
 <li>Type text into input fields</li>
 <li>Switch between apps</li>
 <li>Close apps</li>
</ul>

<p>Amazingly, you can simulate all of these user actions using Marionette! You can read <a href="http://mozilla-b2g.github.io/marionette-js-client/api-docs/">Marionette's detailed, code-level documentation</a> to get to grips with the basic tasks. For more advanced interactions, marionette JS has a rich collection of plugins including ones for <a href="https://github.com/mozilla-b2g/marionette-apps">app management</a>, <a href="https://github.com/mozilla-b2g/marionette-plugin-forms">form completion</a>, <a href="https://github.com/mozilla-b2g/marionette-content-script">injecting scripts</a>, <a href="https://github.com/mozilla-b2g/marionette-file-manager">reading and writing to device storage</a>, <a href="https://github.com/mozilla-b2g/marionette-settings-api">editing settings</a>, and <a href="https://github.com/mozilla-b2g/marionette-helper">anything else your heart desires</a>!</p>

<h3 id="Marionette_is_faster_than_my_application!">Marionette is faster than my application!</h3>

<p>An extremely common issue is that marionette performs UI actions much faster than the average user. Imagine, for instance, that we had an application with two simple views, each with a button to navigate to the other one. We might expect the following snippet of pseudocode to work:</p>

<div class="warning">
<p><strong>Important</strong>: This is an example of what <strong>not</strong> to do. Most marionette tests that fail intermittently exhibit the following behavior.</p>
</div>

<pre class="brush: js"><code class="brush: js">view1.navigateToOther();</code>
<code>view2.navigateToOther();</code>
<code>assert.ok(view1.isDisplayed());</code></pre>

<p>This simple test tries to navigate from one view to the other, navigate back, and then make sure that the original view is displayed. This test will fail intermittently since there's a race condition between the application code — which renders the two views — and the test code — which makes the implicit (and incorrect) assumption that the UI is responding synchronously. Instead, we need to program our test to behave like a user. Users don't try to click things or read things before they are actually visible in the UI. Users "poll" the UI by looking at it until the thing they're waiting for shows up. Here's a better version of our test:</p>

<pre class="brush: js"><code class="brush: js">client.waitFor(view1.isDisplayed.bind(view1));</code>
<code>view1.navigateToOther();</code>
<code>client.waitFor(view2.isDisplayed.bind(view2));</code>
<code>view2.navigateToOther();</code>
<code>client.waitFor(view1.isDisplayed.bind(view1));</code></pre>

<div class="note">
<p><strong>Note</strong>: <a href="http://mozilla-b2g.github.io/marionette-js-client/api-docs/classes/Marionette.Client.html#method_waitFor">Marionette.Client#waitFor</a> is a utility that blocks your test execution until the parameter function returns <code>true</code>.</p>
</div>

<h3 id="How_can_tests_switch_back_to_the_system_app">How can tests switch back to the system app?</h3>

<p>Sometimes, your tests will need to switch between interacting with another app and the system app. Examples include:</p>

<ul>
 <li>Selecting a webapp to fulfill a web activity</li>
 <li>Dismissing an alert box</li>
 <li>Interacting with the value selector</li>
</ul>

<p>Both<a href="http://mozilla-b2g.github.io/marionette-js-client/api-docs/classes/Marionette.Client.html#method_switchToFrame"> Client#switchToFrame</a> and <a href="https://github.com/mozilla-b2g/marionette-apps/blob/master/lib/switchtoapp.js">Apps#switchToApp</a> help us jump between different iframes.</p>

<div class="note">
<p><strong>Note</strong>: <a href="http://mozilla-b2g.github.io/marionette-js-client/api-docs/classes/Marionette.Client.html#method_switchToFrame">Marionette.Client#switchToFrame</a> will switch to the default (top-level) context when called with no arguments. This behavior is documented in the <a href="http://www.w3.org/TR/webdriver/#switching-frames">webdriver spec</a>.</p>
</div>

<h3 id="Regarding_all_of_the_many_windows_and_contexts">Regarding all of the many windows and contexts</h3>

<p>As you probably already know, Gecko makes a distinction between content and <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Chrome_Authority">chrome</a> JavaScript contexts. If you would like to jump into the chrome context to mock web APIs, access the dev tools, and any number of other things you can't do in content windows, you need <a href="http://mozilla-b2g.github.io/marionette-js-client/api-docs/classes/Marionette.Client.html#method_setContext">Marionette.Client#setContext</a>. If you want to expose methods or properties from chrome to code running in content, you need to use <a href="https://developer.mozilla.org/en-US/docs/Mozilla/XPConnect/XPConnect_wrappers#__exposedProps__">__exposedProps__</a> as we do <a href="https://raw.githubusercontent.com/mozilla-b2g/gaia/1f91f202578cfc36937e774fabd8055d768e0128/shared/test/integration/mock_navigator_mozalarms.js">in this Alarms example</a>. Another important thing to know is that to persist data in JavaScript between calls to <a href="http://mozilla-b2g.github.io/marionette-js-client/api-docs/classes/Marionette.Client.html#method_executeScript">Marionette.Client#executeScript</a>, you will need to put things on <a href="https://developer.mozilla.org/en-US/docs/wrappedJSObject">window.wrappedJSObject</a> like we do in <a href="https://raw.githubusercontent.com/mozilla-b2g/marionette-apps/36bff7ec841d760ff8adcc6777b84373b4be46e9/lib/scripts/objectcache.js">objectcache.js</a> inside marionette-apps.</p>

<h3 id="How_should_I_structure_my_UI_test_libraries">How should I structure my UI test libraries?</h3>

<p>Most of the test code you will write won't be general purpose enough to warrant abstracting into a general-purpose plugin. For app-specific code, we recommend having a separate file/class/module for each view. We demonstrate this pattern in gaia's <a href="https://github.com/mozilla-b2g/gaia/tree/bc5c83ad7e38cb588794f3e4692b3f0d63025c6a/apps/calendar/test/marionette">calendar test libraries</a>. The <a href="https://github.com/mozilla-b2g/gaia/tree/bc5c83ad7e38cb588794f3e4692b3f0d63025c6a/apps/calendar/test/marionette/lib/views">views folder</a> has a unique class for each Calendar app view. The general <a href="https://github.com/mozilla-b2g/gaia/tree/bc5c83ad7e38cb588794f3e4692b3f0d63025c6a/apps/calendar/test/marionette/lib/calendar.js">calendar object</a> has methods to navigate between the different views. In each of the views, we "scope" methods to search for elements in the DOM contained within the view's root element.</p>

<p>Often the views will contain getter methods to read an element or data from the view and setter methods to write data to an <code>&lt;input&gt;</code> or <code>&lt;select&gt;</code> element. A good example is <a href="https://github.com/mozilla-b2g/gaia/tree/bc5c83ad7e38cb588794f3e4692b3f0d63025c6a/apps/calendar/test/marionette/lib/calendar.js#L119">creating a calendar event</a>, which involves calling setter methods on the <a href="https://github.com/mozilla-b2g/gaia/tree/bc5c83ad7e38cb588794f3e4692b3f0d63025c6a/apps/calendar/test/marionette/lib/views/edit_event.js">edit event view</a> and saving. It's also idiomatic to abstract multiple UI actions that form a single "logical" action into view methods. For instance, <a href="https://github.com/mozilla-b2g/gaia/blob/master/apps/calendar/test/marionette/lib/views/edit_event.js#L47">setting a collection of reminders for a calendar event</a> involves tapping a select option for each reminder.</p>

<h2 id="How_the_test_runner_works">How the test runner works</h2>

<p>This section provides a detailed review of how the test runner works, for those that are interested.</p>

<div class="note">
<p><strong>Note</strong>: All of the various ways the Marionette JavaScript integration tests are run happens via the same make <code>test-integration</code> path.  Only parameters are changed.</p>
</div>

<h3 id="What_triggers_the_tests">What triggers the tests?</h3>

<p>On <a href="/en-US/docs/">travis</a>:</p>

<ul>
 <li>Travis gets told what to do in our <a href="https://github.com/mozilla-b2g/gaia/blob/master/.travis.yml">.travis.yml</a> file.</li>
 <li>This sets up an xvfb environment.</li>
 <li>All of our jobs are run through the <code>travisaction</code> helper script from our <a href="https://github.com/mozilla-b2g/travis-project-jobs">travis-project-jobs repo</a>.  The key things to know about this script are that it looks in a special directory for a subdirectory matching whatever <code>CI_ACTION</code> it is given.  The config file that controls this directory is <a href="https://github.com/mozilla-b2g/gaia/blob/master/travisaction.opts">gaia/travisaction.opts</a>, which points at <a href="https://github.com/mozilla-b2g/gaia/tree/master/tests/travis_ci">gaia/tests/travis_ci</a> for us.</li>
 <li>So for <code>CI_ACTION=marionette_js</code> we look for the scripts in <a href="https://github.com/mozilla-b2g/gaia/tree/master/tests/travis_ci/marionette_js">gaia/tests/travis_ci/marionette_js</a>.</li>
 <li>The current contents of <a href="https://github.com/mozilla-b2g/gaia/blob/master/tests/travis_ci/marionette_js/script">gaia/tests/travis_ci/marionette_js/script</a> are:
  <pre class="brush: python"><span class="nv">TEST_MANIFEST</span><span class="o">=</span>./shared/test/integration/travis-manifest.json
    <span class="nv">REPORTER</span><span class="o">=</span>spec make <span class="nb">test</span>-integration</pre>
 </li>
 <li><a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/travis-manifest.json">travis-manifest.json</a> is a JSON file containing a list of blacklisted tests.  There are also manifests in the <a href="https://github.com/mozilla-b2g/gaia/tree/master/shared/test/integration">gaia/shared/test/integration directory</a> for <a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/local-manifest.json">local</a> and <a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/tbpl-manifest.json">automation</a> runs.</li>
</ul>

<p>In automation:</p>

<ul>
 <li>The build automation runs the following:
  <pre class="brush: python">make test-integration NPM_REGISTRY=http://npm-mirror.pub.build.mozilla.org
REPORTER=mocha-tbpl-reporter TEST_MANIFEST=./shared/test/integration/tbpl-manifest.json</pre>
 </li>
 <li>The custom <code>NPM_REGISTRY</code> may or may not continue to exist; our <code>node_modules</code> are now sourced from our <a href="https://github.com/mozilla-b2g/gaia-node-modules">gaia-node-modules repo</a>.</li>
 <li>The custom reporter <a href="https://github.com/mozilla-b2g/mocha-tbpl-reporter">mocha-tbpl-reporter</a> just prints out <em>TEST-START / TEST-PASS / TEST-UNEXPECTED-FAIL / TEST-END</em> that the parsers consuming Buildbot output expect, instead of all of those cool checkmarks you get when using the (default) spec reporter we use locally and on Travis.  Note that the time-stamps from the Buildbot output are much more realistic than what the spec reporter claims for test durations.  Do not believe the spec reporter: it doesn't include your setup times!</li>
 <li>The <a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/tbpl-manifest.json">tbpl-manifest.json</a> manifest lists tests specifically blacklisted in automation</li>
</ul>

<p>Locally:</p>

<ul>
 <li>Whatever you want, you got it.</li>
</ul>

<h3 id="Okay_what_does_make_test-integration_actually_do">Okay, what does make test-integration actually do?</h3>

<ul>
 <li>The <a href="https://github.com/mozilla-b2g/gaia/blob/master/Makefile">Makefile</a> invokes <a href="https://github.com/mozilla-b2g/gaia/blob/master/bin/gaia-marionette">bin/gaia-marionette</a>, passing <code>MARIONETTE_RUNNER_HOST</code>, <code>TEST_MANIFEST</code>, and <code>REPORTER</code> as command-line arguments pulled out of the make environment.

  <ul>
   <li><code>MARIONETTE_RUNNER_HOST</code> defaults to <a href="https://github.com/mozilla-b2g/marionette-b2gdesktop-host">marionette-b2gdesktop-host</a> (run in B2G Desktop) if you don't explicitly specifying something else like <a href="https://github.com/mozilla-b2g/marionette-firefox-host">marionette-firefox-host</a> (run in Firefox) or <a href="https://github.com/mozilla-b2g/marionette-device-host">marionette-device-host</a> (run on a device, not expected to work yet).</li>
   <li><code>TEST_MANIFEST</code> defaults to <a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/local-manifest.json">shared/test/integration/local-manifest.json</a> and right now is just a list of blacklisted tests.  The logic for manifests lives in <a href="https://github.com/mozilla-b2g/marionette-js-runner">marionette-js-runner</a> / <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/applymanifest.js">lib/applymanifest.js</a>.</li>
   <li><code>REPORTER</code> defaults to spec which is a standard <a href="http://visionmedia.github.io/mocha/">mocha</a> reporter.  <a href="http://visionmedia.github.io/mocha/#spec-reporter">Check it out on the mocha docs page</a>.</li>
  </ul>
 </li>
 <li><a href="https://github.com/mozilla-b2g/gaia/blob/master/bin/gaia-marionette">bin/gaia-marionette</a> is a wrapper around <a href="https://github.com/mozilla-b2g/marionette-js-runner">marionette-js-runner</a>'s <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/bin/marionette-mocha">bin/marionette-mocha</a> and generally appears to be a place to add a few more defaults, duplicate a bunch of work already done in the Makefile, and generately be a place to cram stuff if you don't understand Makefiles / want to make things take longer to run by avoiding parallelization.  The good news is that because of all this you can invoke it directly.  The notable bits in here are:
  <ul>
   <li>It uses "find" to locate all potential tests.  If <code>APP</code> is in the environment, it only looks for tests under a given app.  It will find blacklisted test files, but these are filtered out by marionette-mocha.</li>
   <li><a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/setup.js">gaia/shared/test/integration/setup.js</a> is specified as the first script to run when we spin up the mocha runtime.  This currently is just a place to require and add plugins for use across all app tests.</li>
   <li><a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/profile.js">gaia/shared/test/integration/profile.js</a> is specified as the base configuration for all marionette integration tests' Gecko profiles.  Adding things to this file will cause all tests to have certain prefs set, settings set, and/or apps installed.  You almost certainly should not add things to this file.</li>
   <li><a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/profile_builder.js">gaia/shared/test/integration/profile_builder.js</a> is specified as the profile builder.  It uses the Gaia Makefile, <a href="https://github.com/mozilla-b2g/mozilla-profile-builder">mozilla-profile-builder</a> in conjunction with <a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/profile.js">profile.js</a> above and specific per-test-file settings you specify in your <code>marionette.client({ ... })</code> call to configure your profile.  We discuss the actual steps, when they actually happen at runtime, below.</li>
  </ul>
 </li>
 <li><a href="https://github.com/mozilla-b2g/marionette-js-runner">marionette-js-runner</a>'s <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/bin/marionette-mocha">bin/marionette-mocha</a> applies its own defaults that don't matter to us, applies the manifest rules in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/applymanifest.js">lib/applymanifest.js</a> to filter out blacklisted tests and spins up a <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/parentrunner.js">ParentRunner</a> instance.</li>
 <li>The <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/parentrunner.js">ParentRunner</a> instantiates a <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/childrunner.js">ChildRunner</a>.  The ParentRunner is boring and its name is somewhat misleading.  Both the ParentRunner and ChildRunner live entirely in the same "runner" process.  There is currently only ever one ChildRunner.</li>
</ul>

<p>Now things get somewhat complicated, so let's take a second to get an overview of all the processes that can be active and how they work:</p>

<ul>
 <li>The runner process. This is the <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/bin/marionette-mocha">bin/marionette-mocha</a> process with the <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/parentrunner.js">ParentRunner</a> and <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/childrunner.js">ChildRunner</a>.

  <ul>
   <li>It is a node.js environment.</li>
   <li>None of your test code runs in this process!</li>
   <li>It forks the <a href="https://github.com/visionmedia/mocha">mocha</a> / <a href="https://github.com/visionmedia/mocha/blob/master/bin/_mocha">bin/_mocha</a> node.js script to be the "mocha test" (sub-)process.
    <ul>
     <li>This is done using the node.js <a href="http://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options">child_process.fork</a> mechanism.  This allows the "runner" process to <a href="http://nodejs.org/api/child_process.html#child_process_child_send_message_sendhandle">send</a> messages to the child and receive <a href="http://nodejs.org/api/child_process.html#child_process_event_message">message</a> events in return.</li>
    </ul>
   </li>
   <li>It gets bossed around by the "mocha test" process.  Literally.  The messages get received and converted into lookups on the ChildRunner object with <code>apply()</code> then called and a callback generated that will marshal the result back down to the client.  This means that the runner process can and is told to:
    <ul>
     <li>Start/stop/restart "hosts".  Hosts are your B2G Desktop/Firefox/B2G devices.</li>
    </ul>
   </li>
  </ul>
 </li>
 <li>The mocha test process.  This is the <a href="https://github.com/visionmedia/mocha">mocha</a> / <a href="https://github.com/visionmedia/mocha/blob/master/bin/_mocha">bin/_mocha</a> node.js script.
  <ul>
   <li>It is a node.js environment and this is the stock mocha test runner.</li>
   <li>This is where your test code runs!</li>
   <li>The mocha runner gets told about the following files, in the following order:
    <ul>
     <li><a href="https://github.com/mozilla-b2g/marionette-js-runner">marionette-js-runner</a>'s <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime.js">lib/runtime.js</a>
      <ul>
       <li>This is where that "marionette" global comes from that you see in your tests!</li>
      </ul>
     </li>
     <li><a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/setup.js">gaia/shared/test/integration/setup.js</a>
      <ul>
       <li>This just loads and configures a bunch of marionette plugins to run during every step.</li>
      </ul>
     </li>
     <li>All of the test files that <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/bin/marionette-mocha">bin/marionette-mocha</a> was made aware of, that made it through the manifest's blacklists/whitelists.</li>
    </ul>
   </li>
   <li>See below for details on the execution model and how a test run actually works.</li>
  </ul>
 </li>
 <li>The "host" process(es).  These are B2G Desktop/Firefox/(magic adb control wrapper) instances.
  <ul>
   <li>These are Gecko processes, potentially a hierarchy of processes now that OOP is in play.</li>
   <li>They are communicated with via the Marionette protocol.</li>
  </ul>
 </li>
 <li>"server" processes: These are test/fake servers spun up by various tests.  These currently all seem to be spun up by the "mocha test" processes directly, but it's conceivable the "runner" process could also spin some up.  Some known examples:
  <ul>
   <li>A test web-server.  <a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/server.js">gaia/shared/test/integration/server.js</a> forks off a subprocess that runs <a href="https://github.com/mozilla-b2g/gaia/blob/master/shared/test/integration/server_child.js">gaia/shared/test/integration/server_child.js</a> and communicates via the same <code>child_process</code> message-passing mechanism that the "runner" and "mocha test" processes use.
    <ul>
     <li>there are duplicates of this implementation in <a href="https://github.com/mozilla-b2g/gaia/blob/master/apps/browser/test/marionette/lib/server.js">browser</a> and <a href="https://github.com/mozilla-b2g/gaia/blob/master/apps/homescreen/test/marionette/lib/server.js">homescreen</a> for some reason, likely historical.</li>
    </ul>
   </li>
   <li>The e-mail app has fake IMAP/POP3/SMTP servers that it shares with its back-end implementation.  These live in the <a href="https://github.com/mozilla-b2g/mail-fakeservers">mail-fakeservers repo</a>.  The fake-servers actually run in an XPCShell Gecko-style instance that initially communicates via a low-level IPC interface using <a href="https://github.com/lightsofapollo/json-wire-protocol/">json-wire-protocol</a> to bootstrap equivalence with the back-end tests' mechanism and then afterwards with a synchronous HTTP REST interface for all the e-mail domain work.  It's due for some cleanup.</li>
  </ul>
 </li>
</ul>

<h3 id="What_is_in_my_global_scope_in_my_test_file">What is in my global scope in my test file?</h3>

<ul>
 <li>Marionette: this comes from <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime.js">lib/runtime.js</a>.  It is a function that's a wrapper around mocha's TDD suite() method.  Source is in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime/marionette.js">lib/runtime/marionette.js</a>.  It has the following notable properties annotated onto it:

  <ul>
   <li>client(stuffToAddToTheProfile, driver that defaults to the synchronous Marionette API): Bound to HostManager.createHost from <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime/hostmanager.js">lib/runtime/hostmanager.js</a>.</li>
   <li>plugin(name, module): This is a bound function that invokes HostManager.addPlugin from <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime/hostmanager.js">lib/runtime/hostmanager.js</a>.  It adds the plugin for the duration of your test suite.</li>
  </ul>
 </li>
 <li>The <a href="https://github.com/visionmedia/mocha/blob/master/lib/interfaces/tdd.js">TDD interface</a> pokes setup/teardown/suiteSetup/suiteTeardown/suite/test into the global namespace.</li>
</ul>

<h3 id="What_are_marionette_plugins">What are marionette plugins?</h3>

<ul>
 <li>Marionette plugins are node.js modules which extend the native abilities of the js marionette client.</li>
 <li>They conform to the following simple plugin API:</li>
</ul>

<pre class="brush: python">MarionettePlugin = {
  /**
   * @param {Marionette.Client} client the marionette client to extend.
   * @param {Object} options plugin-specific configuration.
   * @return {MarionettePlugin} appropriately configured plugin.
   */
  setup: function(client, options) {}
};</pre>

<ul>
 <li>They get exposed through the client (i.e. client.apps).</li>
 <li>Existing plugins include
  <ul>
   <li><a href="https://github.com/mozilla-b2g/marionette-apps">marionette-apps</a> - utility to find, open, close, and switch between apps</li>
   <li><a href="https://github.com/mozilla-b2g/marionette-helper">marionette-helper</a> - miscellaneous helper functions for interacting with the DOM</li>
   <li><a href="https://github.com/mozilla-b2g/marionette-js-logger">marionette-js-logger</a> - proxies console.* calls from gecko to node.js (notably used internally by marionette-js-runner)</li>
   <li><a href="https://github.com/mozilla-b2g/marionette-plugin-forms">marionette-plugin-forms</a> - makes interacting with forms through marionette easier</li>
  </ul>
 </li>
</ul>

<h3 id="What_is_mocha's_TDD_execution_model">What is mocha's TDD execution model?</h3>

<ul>
 <li>The mocha runner <code>require()</code>s all of the files it is told about in sequence in <a href="https://github.com/visionmedia/mocha/blob/master/lib/mocha.js">Mocha.prototype.loadFiles</a>().  This consists of:

  <ul>
   <li>synchronously emitting a <code>pre-require</code> event.

    <ul>
     <li>The <a href="https://github.com/visionmedia/mocha/blob/master/lib/interfaces/tdd.js">TDD interface</a> setup/teardown/suiteSetup/suiteTeardown/suite/test into the global namespace.</li>
    </ul>
   </li>
   <li>synchronously requiring the file in question.
    <ul>
     <li>This means the top level of your file is executed.</li>
     <li>Any <code>marionette()</code> calls to define a suite (since Marionette is just a wrapper around <code>suite()</code>) will in turn have their defining function executed synchronously.</li>
     <li>The <code>test()</code> calls inside the <code>marionette()</code> calls are NOT executed.  Those don't happen until the test is actually run.</li>
     <li>This does mean you have to be very careful not to do anything foolish in the top-level of your file or the <code>marionette()</code> file.</li>
    </ul>
   </li>
   <li>synchronously emitting a 'require' event passing the module from the file in question.</li>
   <li>synchronously emitting a 'post-require' event.</li>
  </ul>
 </li>
 <li>The <a href="https://github.com/visionmedia/mocha/blob/master/lib/runner.js">Runner</a> runs the suites and tests in sequence.
  <ul>
   <li>emits <code>start</code>.</li>
   <li><code>runSuite</code> loops over all the suites, for each one:
    <ul>
     <li>emits <code>suite</code>.</li>
     <li>emits <code>beforeAll</code>, which is what <code>suiteSetup</code> maps to.</li>
     <li>calls <code>runTests</code> loops over all the tests, for each one:
      <ul>
       <li>emits <code>test</code>.</li>
       <li>emits <code>beforeEach</code>, which is what <code>setup</code> maps to.</li>
       <li>calls <code>runTest</code>, which runs your test function.</li>
       <li>emits <code>test end</code>.
        <ul>
         <li>This runs <code>checkGlobals()</code> to make sure you didn't clobber anything unexpected into the global state.  It fails your test if you did.</li>
        </ul>
       </li>
       <li>emits <code>afterEach</code>, which is what <code>teardown</code> maps to.</li>
      </ul>
     </li>
     <li>emits <code>afterAll</code>, which is what <code>suiteTeardown</code> maps to.</li>
     <li>emits <code>suite end</code>.</li>
    </ul>
   </li>
   <li>emits <code>end</code>.</li>
  </ul>
 </li>
</ul>

<h3 id="What_is_the_life-cycle_of_the_Gecko_processes">What is the life-cycle of the Gecko processes?</h3>

<p>For your test suite (aka each top-level <code>marionette('description', function() {...})</code> in your file), a new profile is created.</p>

<p>For each test (aka each <code>test('description', function() {...})</code> in your <code>marionette('description', ...)</code>), the host gets restarted after each <code>test()</code>.</p>

<p>The nitty gritty of this is that your call to <code>marionette.client()</code> invokes <code>HostManager.createHost()</code> in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime/hostmanager.js">lib/runtime/hostmanager.js</a>, which uses the mocha TDD infrastructure to decorate your suite with the following:</p>

<ul>
 <li><code>suiteSetup()</code>:

  <ul>
   <li><code>Host.create()</code> in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime/host.js">lib/runtime/host.js</a> gets called, which causes <code>createHost()</code> in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/childrunner.js">ChildRunner</a> to get invoked.

    <ul>
     <li>This builds a profile from scratch if it doesn't exist, otherwise the existing profile is reused but settings/etc. are clobbered to be how we want them.</li>
     <li>The "runner" process waits for the host to start-up.  It connects to the host with the async API and starts a session, then deletes it, and only generates the callback notification that will allow the "mocha test" process to know the host is ready.</li>
    </ul>
   </li>
  </ul>
 </li>
 <li><code>setup()</code>:
  <ul>
   <li>Causes the driver to connect to the host at startup.
    <ul>
     <li><code>driver.resetWithDriver()</code> gets called: this sounds scary, but it just resets internal state.  See <a href="https://github.com/mozilla-b2g/marionette-js-client">marionette-js-client</a>'s <a href="https://github.com/mozilla-b2g/marionette-js-client/blob/master/lib/marionette/client.js">lib/marionette/client.js</a>.</li>
     <li>All the plugins on record get registered with the client.</li>
     <li><code>client.startSession()</code> gets called, presumably doing something.</li>
    </ul>
   </li>
  </ul>
 </li>
 <li><code>teardown()</code> #1:
  <ul>
   <li><code>client.deleteSession()</code> gets called, presumably doing something.</li>
  </ul>
 </li>
 <li><code>teardown()</code> #2:
  <ul>
   <li><code>Host.restart()</code> in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime/host.js">lib/runtime/host.js</a> gets called, which causes <code>restartHost()</code> in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/childrunner.js">ChildRunner</a> to get invoked.
    <ul>
     <li>This calls <code>stopHost</code> under the hood and then reuses much of the <code>createHost()</code> logic except the existing <code>remotes</code> handle is reused in the call to <code>_buildRemote</code>.</li>
    </ul>
   </li>
  </ul>
 </li>
 <li><code>suiteTeardown()</code>:
  <ul>
   <li><code>Host.stop()</code> in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/runtime/host.js">lib/runtime/host.js</a> gets called, which causes <code>stopHost()</code> in <a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/lib/childrunner.js">ChildRunner</a> to get invoked.</li>
  </ul>
 </li>
</ul>

<h2 id="Writing_integration_tests">Writing integration tests</h2>

<p>marionette-js-runner <a href="https://github.com/mozilla-b2g/marionette-js-runner#marionetteclient-marionette-client-interface">has some simple overviews</a> that are worth checking out.  You can find js marionette client documentation <a href="http://mozilla-b2g.github.io/marionette-js-client/api-docs/">here</a>!</p>

<h3 id="File_naming"><strong>File naming</strong></h3>

<p>Integration tests are located in the <code>test/integration/</code> directory.</p>

<h2 id="See_also">See also</h2>

<ul>
 <li><a href="https://github.com/mozilla-b2g/gaia/#integration-tests">Gaia integration tests info on Github</a>.</li>
 <li><a href="/en-US/docs/Marionette/Marionette_JavaScript_Tools" title="/en-US/docs/Marionette/Marionette_JavaScript_Tools">Marionette Javascript Tools</a> for a high level overview.</li>
 <li><a href="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/README.md#exposed-apis-for-writing-marionette-tests" title="https://github.com/mozilla-b2g/marionette-js-runner/blob/master/README.md#exposed-apis-for-writing-marionette-tests">Code samples</a> on Github.</li>
 <li><a class="link-https" href="https://wiki.mozilla.org/Gaia/Hacking" title="https://wiki.mozilla.org/Gaia/Hacking">Hacking Gaia</a> for getting started with Gaia.</li>
 <li><a href="http://visionmedia.github.io/mocha/">mocha: which is wrapped by marionette-js-runner.</a></li>
 <li><a href="https://github.com/mozilla-b2g/marionette-js-runner">marionette-js-runner: for the test framework.</a></li>
 <li><a href="http://lightsofapollo.github.io/marionette_js_client/api-docs/classes/Marionette.Client.html">marionette-client: for anything to do with client.</a></li>
</ul>