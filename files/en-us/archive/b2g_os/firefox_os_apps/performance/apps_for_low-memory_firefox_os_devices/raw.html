<div class="summary">
 <p dir="ltr">Entry-level smartphones run on limited hardware, and are often used in environments featuring slow connectivity and coarse location acquisition. This guide outlines the various factors that impact app performance and stability that should be given critical consideration when performance testing for such devices, and the tools that can be used to investigate and optimize.</p>
</div>
<p dir="ltr">This guide targets app developers and reviewers who need to determine how well an app will run on a low-end Firefox OS device and which factors will prevent it from doing so. It's assumed that not everyone using this guide will have access to a low-end device.</p>
<div class="note">
 <p dir="ltr"><strong>Note</strong>: Guidelines help only if you check your apps often during development in your desktop browser, Firefox OS simulator and eventually on a device (see <a href="/en-US/Firefox_OS/Developing_Gaia/Different_ways_to_run_Gaia">Different ways to run Gaia</a>). You might need to switch tools when testing against different versions of Firefox OS. Pick the most powerful tool available for your version.</p>
</div>
<h2 id="Memory">Memory</h2>
<p>This section discusses how to debug and optimize for memory constraints.</p>
<h3 id="On_Device">On Device</h3>
<h4 id="Firefox_DevTools_WebIDE_Monitor_(2.1)">Firefox DevTools WebIDE Monitor (2.1+)</h4>
<p dir="ltr">The new <a href="https://developer.mozilla.org/en-US/docs/Tools/WebIDE/Monitor">WebIDE Monitor</a> displays live and interactive memory graphs for all processes running on a connected Firefox OS run time. The Monitor tool is under active development and currently only enabled in Nightly. It currently requires a Firefox OS device running 2.1 (it won't work with lower Firefox OS versions or a Firefox Simulator). To access it, go to WebIDE, plug in your Firefox OS 2.1 device, make sure it's successfully connected, and on the WebIDE main menu click <strong>Runtime</strong> then <strong>Monitor</strong>.</p>
<p dir="ltr">Watch for the average memory that your app uses, and unexpected spikes. You'll see the graph falling when garbage collection kicks in. Note that there is also some interaction between processes, as some memory is shared.</p>
<h4 id="Firewatch_(1.1)">Firewatch (1.1+)</h4>
<p dir="ltr"><a href="https://github.com/digitarald/firewatch">Firewatch</a> is the WebIDE Monitor tool's predecessor — a node-based command-line tool that can be used to view a live memory graph for connected Firefox OS devices (versions supported up to 1.4.) It can also capture <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler#Profiling_Boot_to_Gecko_%28with_a_real_device%29">performance profiles</a> and fetch <a href="https://wiki.mozilla.org/FirefoxOS/Performance/Debugging_OOMs#Step_2:_Collect_memory_reports">about:memory details</a>. Follow the instructions on <a href="https://github.com/digitarald/firewatch">the GitHub page</a> to get it installed and running.</p>
<p dir="ltr">Watching the memory is low-impact so keep the tool running as you test your app. You can use it in the same way as the WebIDE Monitor.</p>
<h4 id="On-device_Developer_HUD_(1.4)">On-device Developer HUD (1.4+)</h4>
<p dir="ltr">The <a href="https://developer.mozilla.org/en-US/Firefox_OS/Debugging/Developer_settings#Developer_HUD">Developer Hud</a> is an on-device developer tool that landed in Firefox OS 1.4. It shows various performance and platform details in real time, overlaid on the device display. Most importantly for our current use case, it can show current <a href="https://developer.mozilla.org/en-US/Firefox_OS/Debugging/Developer_settings#App_memory">App memory</a> use, split up into various categories: <em>JS objects</em>, <em>JS strings</em>, <em>JS other</em>, <em>DOM</em>, <em>Style</em> and <em>Other</em>.</p>
<p dir="ltr">Keep it running during testing to get a sense of overall memory use. Knowing the base memory, you'll be able to confirm when you have successfully reduced memory or regressed when applying optimizations. You'll be able to see instantly which interactions decrease or increase memory use.</p>
<h3 id="On_Desktop">On Desktop</h3>
<h4 id="aboutmemory">about:memory</h4>
<p dir="ltr">The most basic tool for obtaining a snapshot memory report is the URL <code>about:memory</code>, available on Desktop Firefox. A <a href="https://developer.mozilla.org/en-US/Firefox_OS/Debugging/Debugging_OOMs#Step_2.3A_Collect_memory_reports">command-line tool</a> enables the same report for Firefox OS.</p>
<h4 id="Chrome_Devtools">Chrome Devtools</h4>
<p dir="ltr">Until the Memory Inspector tool lands in Firefox devtools, you can use <a href="https://developer.chrome.com/devtools/docs/heap-profiling">Chrome’s Heap Profiler</a> to get memory use information on the desktop.</p>
<h2 id="Bandwidth">Bandwidth</h2>
<p>This section discusses the tools available for debugging high bandwidth use.</p>
<h3 id="Desktop">Desktop</h3>
<h4 id="Network_Monitor">Network Monitor</h4>
<p dir="ltr">Most developers track network requests with the <a href="https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor">Network Monitor</a>. It can also measure how well your server caches static data (primed cache) and how heavy the initial payload is for the user (Empty cache). Considering that low-end phones will often only have EDGE available (150 KB/s in practice) keep the total requests size as small as possible. 1.5 MB on empty cache and 500 KB on primed cache are the recommended limits, but the lighter your app is, the better the user experience.</p>
<h2 id="Device_Capabilities" dir="ltr">Device Capabilities</h2>
<p dir="ltr">This section details some known device capabilities/limits that you should be mindful of when debugging low memory devices, and how to deal with those.</p>
<h3 id="App_Storage">App Storage</h3>
<p dir="ltr">The internal storage limit for the Firefox profile, where the apps are stored, is around 80 Mb. To be considerate of that space, a general rule is to keep your <a href="https://developer.mozilla.org/en-US/Marketplace/Options/Packaged_apps">packaged application</a> size under 5 MB.</p>
<h3 id="Memory_2">Memory</h3>
<p dir="ltr">The lowest RAM hardware configuration for Firefox OS is 128 MB, codename <a href="https://developer.mozilla.org/en-US/Firefox_OS/Developer_phone_guide/Phone_specs#Device_specifications">Tarako</a>. Even on the more common 256 MB configuration, apps in the background are often cleaned up to recover memory. The Firefox OS <a href="https://developer.mozilla.org/en-US/Firefox_OS/Developer_phone_guide/Flame">Flame</a> reference device can be <a href="https://developer.mozilla.org/en-US/Firefox_OS/Developer_phone_guide/Flame#RAM_adjustment">configured</a> from 1 GB down to 256 MB, to allow testing against different memory profiles.</p>
<h3 id="Geolocation">Geolocation</h3>
<p dir="ltr">Low-end Firefox OS devices don’t have A-GPS and therefore can only provide coarse geolocation data using Wi-Fi positioning. If your app only expects city level accuracy it should be OK. If greater accuracy is desired alternative positioning options may need to be considered.</p>
<h3 id="Connectivity">Connectivity</h3>
<p dir="ltr">In markets where low-memory devices are common, erratic 2G connectivity is common making data services unreliable. Optimize your app to work offline by storing data, minimizing server round trips and payloads and nicely falling back when requests fail. If your app needs to contact your server on regular basis for updates, use Firefox’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/Simple_Push_API">push notifications</a> to schedule API requests as and when needed.</p>
<h2 id="Memory_use_best_practices" dir="ltr">Memory use best practices</h2>
<p dir="ltr">When memory on the phone gets low, apps in the background will be “cleaned up”. This task-killer system is called Low-Memory-Killer (LMK) and the memory threshold triggers differ between phone version, configuration and app priority. An app in the foreground has higher priority and is only killed when memory gets dangerously low. To show its severity, this task-killer is called Out-Of-Memory (OOM) and will look like a crash to the user.</p>
<div class="note">
 <p dir="ltr"><strong>Note</strong>: To find out more about how memory management is handled in Firefox OS, read <a href="/en-US/Firefox_OS/Platform/Out_of_memory_management_on_Firefox_OS">Out of memory management on Firefox OS</a>.</p>
</div>
<p dir="ltr">To avoid task-killers marking your app, be considerate of memory use. Only take what you need while releasing what you can. Here are some good practices to follow.</p>
<h3 id="DOM">DOM</h3>
<h4 id="Image_resampling">Image resampling</h4>
<p dir="ltr">Be responsive and get your images “tailored to fit”! Down sampling large images to fit will use excessive memory and should be avoided. Start with low-res images and serve higher resolutions when applicable.</p>
<h4 id="Image_sprites">Image sprites</h4>
<p dir="ltr">Combine icons and images in <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/CSS_Image_Sprites">CSS sprites</a> to minimize the amount of image instances stored in memory. This also reduces bandwidth as only one well-compressed file needs to be sent over the air.</p>
<h4 id="Images_in_&lt;img>_vs_CSS">Images in &lt;img&gt; vs CSS</h4>
<p dir="ltr">Minimize images defined in CSS to the ones needed for the layout and app design, as all images defined in CSS are loaded even when they are not used at the time. Use cases like emoticons in a messaging app are much easier on memory when using an <a href="/en-US/docs/Web/HTML/Element/img" title="The HTML &lt;img> element represents an image in the document."><code>&lt;img&gt;</code></a> element, which loads the image on demand and can be removed from memory when no longer needed.</p>
<h4 id="Icon_fonts">Icon fonts</h4>
<p dir="ltr">Fonts are the preferred way for implementing application icons and even emoticons. Other options are CSS sprites and SVG, which all will use more memory and are less performant. Consider using font generators to customize the icon set to only contain what you actually use: downloading more font glyphs than you actually need is a waste of memory and bandwidth.</p>
<h4 id="Discard_or_re-use_elements">Discard or re-use elements</h4>
<p dir="ltr">It is a common technique to keep elements in the DOM or memory for later use. Some sites keep the previous view of one-page apps stored somewhere, to be reuses when the user navigates back. Another memory hog is endless lists where a button in the end of a list allows you to load more elements that are appended to the existing ones. Hidden DOM elements often constitute the biggest memory usage on a page, especially when containing a lot of images.</p>
<p dir="ltr">Even though keeping pages in memory can make browsing faster, there needs to be a balance between gained performance and memory overhead. A good alternative to endless scrolling is simply pagination, replacing the old elements with a new list. Another more elaborate solution is to pool the list elements, e.g. recycling the old entries when loading new ones.</p>
<h3 id="Storage">Storage</h3>
<h4 id="Storage_vs_memory_cache">Storage vs memory cache</h4>
<p dir="ltr">A common performance technique is loading data from client side databases like IndexedDB and then keeping it in memory so it can be rendered faster later on. This not only includes structured data but also templates, or localizations. Depending on the amount and complexity of the data this can take up substantial memory.</p>
<p dir="ltr">If memory is a concern, load the data when you need it and take the performance hit.</p>
<h3 id="Audio">Audio</h3>
<p dir="ltr">The <a href="/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a> is the recommended and more memory efficient way for implementing audio playback, especially for games. It allows you to manage the buffers you have loaded and added to the queue, giving fine-grained control over memory. The HTML5 <a href="/en-US/docs/Web/HTML/Element/audio" title="The HTML &lt;audio> element is used to embed sound content in documents. It may contain one or more audio sources, represented using the src attribute or the &lt;source> element: the browser will choose the most suitable one. It can also be the destination for streamed media, using a MediaStream."><code>&lt;audio&gt;</code></a> element still has its use cases: streaming for example. Both specs can be combined to get the best of both worlds.</p>