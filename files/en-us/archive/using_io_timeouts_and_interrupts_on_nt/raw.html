<p>This technical memo is a cautionary note on using NetScape Portable Runtime's (NSPR) IO timeout and interrupt on Windows NT 3.51 and 4.0. Due to a limitation of the present implementation of NSPR IO on NT, programs must follow the following guideline:
</p><p>If a thread calls an NSPR IO function on a file descriptor and the IO function fails with &lt;tt&gt;PR_IO_TIMEOUT_ERROR&lt;/tt&gt; or &lt;tt&gt;PR_PENDING_INTERRUPT_ERROR&lt;/tt&gt;, the file descriptor must be closed before the thread exits.
</p><p>In this memo we explain the problem this guideline is trying to work around and discuss its limitations.
</p>
<h2 id="NSPR_IO_on_NT"> NSPR IO on NT </h2>
<p>The IO model of NSPR 2.0 is synchronous and blocking. A thread calling an IO function is blocked until the IO operation finishes, either due to a successful IO completion or an error. If the IO operation cannot complete before the specified timeout, the IO function returns with &lt;tt&gt;PR_IO_TIMEOUT_ERROR&lt;/tt&gt;. If the thread gets interrupted by another thread's &lt;tt&gt;PR_Interrupt()&lt;/tt&gt; call, the IO function returns with &lt;tt&gt;PR_PENDING_INTERRUPT_ERROR&lt;/tt&gt;.
</p><p>On Windows NT, NSPR IO is implemented using NT's <em>overlapped</em> (also called <em>asynchronous</em>) <em>IO</em>. When a thread calls an IO function, the thread issues an overlapped IO request using the overlapped buffer in its &lt;tt&gt;PRThread&lt;/tt&gt; structure. Then the thread is put to sleep. In the meantime, there are dedicated internal threads (called the <em>idle threads</em>) monitoring the IO completion port for completed IO requests. If a completed IO request appears at the IO completion port, an idle thread fetches it and wakes up the thread that issued the IO request earlier. This is the normal way the thread is awakened.
</p>
<h2 id="IO_Timeout_and_Interrupt"> IO Timeout and Interrupt </h2>
<p>However, NSPR may wake up the thread in two other situations:
</p>
<ul><li> if the overlapped IO request is not completed before the specified timeout. (Note that we can't specify timeout on overlapped IO requests, so the timeouts are all handled at the NSPR level.) In this case, the error is &lt;tt&gt;PR_IO_TIMEOUT_ERROR&lt;/tt&gt;.
</li><li> if the thread gets interrupted by another thread's &lt;tt&gt;PR_Interrupt()&lt;/tt&gt; call. In this case, the error is &lt;tt&gt;PR_PENDING_INTERRUPT_ERROR&lt;/tt&gt;.
</li></ul>
<p>These two errors are generated by the NSPR layer, so the OS is oblivious of what is going on and the overlapped IO request is still in progress. The OS still has a pointer to the overlapped buffer in the thread's &lt;tt&gt;PRThread&lt;/tt&gt; structure. If the thread subsequently exists and its &lt;tt&gt;PRThread&lt;/tt&gt; structure gets deleted, the pointer to the overlapped buffer will be pointing to freed memory. This is problematic.
</p>
<h2 id="Canceling_Overlapped_IO_by_Closing_the_File_Descriptor"> Canceling Overlapped IO by Closing the File Descriptor </h2>
<p>Therefore, we need to cancel the outstanding overlapped IO request before the thread exits. NT's &lt;tt&gt;CancelIo()&lt;/tt&gt; function would be ideal for this purpose. Unfortunately, &lt;tt&gt;CancelIo()&lt;/tt&gt; is not available on NT 3.51. So we can't go this route as long as we are supporting NT 3.51.
The only reliable way to cancel outstanding overlapped IO request that works on both NT 3.51 and 4.0 is to close the file descriptor, hence the rule of thumb stated at the beginning of this memo.
</p>
<h2 id="Limitations"> Limitations </h2>
<p>This seemingly harsh way to force the completion of outstanding overlapped IO request has the following limitations:
</p>
<ul><li> It is difficult for threads to shared a file descriptor. For example, suppose thread A and thread B call &lt;tt&gt;PR_Accept()&lt;/tt&gt; on the same socket, and they time out at the same time. Following the rule of thumb, both threads would close the socket. The first &lt;tt&gt;PR_Close()&lt;/tt&gt; would succeed, but the second &lt;tt&gt;PR_Close()&lt;/tt&gt; would be freeing freed memory. A solution that may work is to use a lock to ensure only one thread can be using that socket at all times.
</li><li> Once there is a timeout or interrupt error, the file descriptor is no longer usable. Suppose the file descriptor is intended to be used for the life time of the process, for example, the logging file, this is really not acceptable. A possible solution is to add a &lt;tt&gt;PR_DisableInterrupt()&lt;/tt&gt; function to turn off interrupts when accessing such file descriptors.
</li></ul>
<blockquote><em>A related known bug is that timeout and interrupt don't work for &lt;tt&gt;PR_Connect()&lt;/tt&gt; on NT. This bug is due to a different limitation in our NT implementation.</em></blockquote>
<h2 id="Conclusions"> Conclusions </h2>
<p>As long as we need to support NT 3.51, we need to program under the guideline that after an IO timeout or interrupt error, the thread must make sure the file descriptor is closed before it exits. Programs should also take care in sharing file descriptors and using IO timeout or interrupt on files that need to stay open throughout the process.
</p><p>When we stop supporting NT 3.51, we can look into using NT 4's &lt;tt&gt;CancelIo()&lt;/tt&gt; function to cancel outstanding overlapped IO requests when we get IO timeout or interrupt errors. If &lt;tt&gt;CancelIo()&lt;/tt&gt; really works as advertised, that should fundamentally solve this problem.
</p><p>If these limitations with IO timeout and interrupt are not acceptable to the needs of your programs, you can consider using the Win95 version of NSPR. The Win95 version runs without trouble on NT, but you would lose the better performance provided by NT fibers and asynchronous IO.
</p><p><br>
</p>
<h2 id="Original_Document_Information"> Original Document Information </h2>
<div class="originaldocinfo">
<ul><li> Author: <a class="link-mailto" href="mailto:larryh@netscape.com">larryh@netscape.com</a>
</li><li> Last Updated Date: December 1, 2004
</li></ul>
</div>