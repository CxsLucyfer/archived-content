<h2 id="Introduction" name="Introduction">Introduction</h2>
<p><a class="internal" href="/en/Dehydra" title="en/Dehydra">Dehydra</a> represents C++ types and variables as JavaScript objects. The objects are designed to distill that type system to the minimum such that it can be easy to match on.</p>
<p>Often, the best way to become familiar with the Dehydra objects is to print out the objects:</p>
<ul> <li><a class="internal" href="/En/Dehydra/Using_Dehydra" title="en/Dehydra/Using Dehydra">Dehydra example code</a> </li> <li>an <a class="external" href="http://dxr.mozilla.org/viewsource/" title="http://dxr.mozilla.org/viewsource/">online tool</a> for pretty-printing dehydra data</li>
</ul>
<h2 id="Understanding_Properties">Understanding Properties</h2>
<p>Dehydra only sets properties that are applicable. For example, class types and typedefs are declared and will have a <code><a href="#loc">.loc</a></code> property. Intrinsic types such as "int" are not declared and will not have a <code>.loc</code>.</p>
<p>Dehydra only sets boolean flags when they are true. For example, a pointer type will have <code><a href="#isPointer">.isPointer</a> == true</code>, but a class type will not have an <code>.isPointer</code> property.</p>
<h2 id="Common_Properties">Common Properties</h2>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code id="loc">.loc</code></td> <td><em><a href="#Location_Objects">location object</a><br> </em></td> <td>Source location of a type or declaration.</td> </tr> <tr> <td><code id="attributes">.attributes</code></td> <td><em>array of objects<br> </em></td> <td>Attributes of the type or declaration. Each member of the array has the following properties: <pre>
{
  name: <em>string</em>,
  value: <em>string or number, if applicable</em>
}
</pre> See an <a href="/En/Dehydra/Using_Dehydra#final-example" title="En/Dehydra/Using_Dehydra#final-example">example</a> on enforcing final classes. Code can be annotated with arbitrary user attributes: <code>__attribute__((user("customstring")))</code>.</td> </tr> </tbody>
</table>
<h2 id="Variable_Objects" name="Variable_Objects">Variable Objects</h2>
<p>Dehydra presents AST nodes as variables. These types are used to represent variables, functions, assignments, etc. The following properties are usually available:</p>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.name</code></td> <td><em>string<br> </em></td> <td>The function or variable name.</td> </tr> <tr> <td><code>.type</code></td> <td><em><a href="#Type_Objects">type object</a><br> </em></td> <td>The type of this function or variable.</td> </tr> <tr> <td><code>.isStatic</code></td> <td><em>boolean flag<br> </em></td> <td> </td> </tr> <tr> <td><code>.isReturn</code></td> <td><em>boolean flag</em></td> <td>The variable is being returned.</td> </tr> <tr> <td><code>.isDecl</code></td> <td><em>boolean flag<br> </em></td> <td>The variable is being declared (local variables only).</td> </tr> <tr> <td><code>.assign</code></td> <td><em>array of variable objects<br> </em></td> <td>This variable is the LHS of an assignment. The value is an array of values that were assigned.</td> </tr> <tr> <td><code>.isFcall</code></td> <td><em>boolean flag<br> </em></td> <td>The variable is being used as a function call.</td> </tr> <tr> <td><code>.arguments</code></td> <td><em>array of variable objects<br> </em></td> <td>Arguments used to make a function call.</td> </tr> <tr> <td><code>.parameters</code></td> <td><em>array of variable objects<br> </em></td> <td>A function definition's parameter names and types</td> </tr> <tr> <td><code>.memberOf</code></td> <td><em><a href="#Aggregate_Type">aggregate type object</a><br> </em></td> <td>Indicates the aggregate type(class/struct) in the type system that this variable is a member of.</td> </tr> <tr> <td><code>.fieldOf</code></td> <td><em>variable object<br> </em></td> <td>Provides the object being dereferenced, in the AST system. Applicable when accessing member variables or nonstatic member functions of aggregate types, e.g. the "foo" variable would be a .fieldOf memberVar/Fn in <code>foo-&gt;memberVar</code> or <code>foo-&gt;memberFn()</code>. Note that when constructing the return value of a function (e.g. <code>return T();</code>), no container variable is available; in this case, <code>.isReturn</code> will be true (see <a href="#Function_Variable">Function Variable</a>).</td> </tr> </tbody>
</table>
<p>Variables can identified by their DehydraDecl() prototype.</p>
<h3 id="Function_Variable" name="Function_Variable">Function Variable</h3>
<p>Function objects are an extension of <a href="#Variable_Object">Variable Objects</a>. The following additional properties are available on functions:</p>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.isVirtual</code></td> <td><em>true or "pure"<br> </em></td> <td>true for virtual methods, or "pure" for pure virtuals (e.g. <code>virtual void foo() = 0;</code>).</td> </tr> <tr> <td><code>.isConstructor</code></td> <td><em>boolean flag<br> </em></td> <td>Constructors generally have a <code>.fieldOf</code> attribute (see <a href="#Variable_Object">Variable Objects</a>).</td> </tr> <tr> <td><code>.isFunction</code></td> <td><em>boolean flag</em></td> <td>true for function variables.</td> </tr> </tbody>
</table>
<h2 id="Type_Object" name="Type_Object">Type Objects</h2>
<p>Dehydra provides detailed type objects. Dehydra Type objects use the DehydraType() prototype.</p>
<h3 id="Type_Flags" name="Type_Flags">Common Type Properties</h3>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.name</code></td> <td><em>string<br> </em></td> <td>If applicable, the name of of the type. For typedefs and classes, this is the declared name. For built-in types this is the standard name such as "int". Some types such as bitfields may not have names.</td> </tr> <tr> <td><code>.typedef<br> </code></td> <td><em>type object<br> </em></td> <td>If this is a typedef, the original type.</td> </tr> <tr> <td><code>.isConst<br> </code></td> <td><em>boolean flag<br> </em></td> <td> </td> </tr> <tr> <td><code>.isVolatile<br> </code></td> <td><em>boolean flag<br> </em></td> <td> </td> </tr> <tr> <td><code>.variantOf<br> </code></td> <td><em>type object<br> </em></td> <td>"const int" and "int" are separate types in GCC; the const version is considered a <em>variant</em> of the normal version. The variantOf property allows access to the original type object.</td> </tr> <tr> <td><code>.hasDefault<br> </code></td> <td><em>boolean flag<br> </em></td> <td>Applicable to <a href="#Function_Type">function</a> parameters only. Indicates whether the parameter has a default value, e.g. <code>void foo(int i = 42)</code>.</td> </tr> </tbody>
</table>
<h3 id="Aggregate_Type" name="Aggregate_Type">Aggregate Types (class/struct/union/enum)</h3>
<p>This type object represents aggregate types in GCC.</p>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.kind</code></td> <td><em>string<br> </em></td> <td>One of "class", "struct", "union", or "enum".</td> </tr> <tr> <td><code>.isIncomplete</code></td> <td><em>boolean flag<br> </em></td> <td>the type was forward-declared and the full declaration has not been processed.</td> </tr> <tr> <td><code id="bases">.bases</code></td> <td><em>array of objects<br> </em></td> <td>Inheritance information about the class. Each member of the array has the following properties: <pre>
{
  access: 'public' | 'protected' | 'private',
  type: <em><a href="#Aggregate_Type">type object representing the base class</a></em>
}
</pre> </td> </tr> <tr> <td><code id="members">.members</code></td> <td><em>array of <a href="#Variable_Object">variable objects</a><br> </em></td> <td>An array containing all the member variables and methods. <em>Note: the .members will not include static member functions.</em></td> </tr> <tr> <td><code id="template">.template</code></td> <td><em><a href="#Template_Object">template object</a><br> </em></td> <td>The template from which this class was instantiated, if applicable.</td> </tr> </tbody>
</table>
<h3 id="Pointer_Type" name="Pointer_Type">Pointer and Reference Types</h3>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.isPointer</code></td> <td><em>boolean flag<br> </em></td> <td> </td> </tr> <tr> <td><code>.isReference</code></td> <td><em>boolean flag<br> </em></td> <td> </td> </tr> <tr> <td><code>.type</code></td> <td><em><a href="#Type_Objects">type object</a><br> </em></td> <td>The type this points to or references</td> </tr> </tbody>
</table>
<h3 id="Array_Type" name="Array_Type">Array Type</h3>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.isArray</code></td> <td><em>boolean flag<br> </em></td> <td> </td> </tr> <tr> <td><code>.max</code></td> <td><em>integer<br> </em></td> <td>or normal fixed-size arrays, the index of the largest element of the array. For example, an <code>int[10]</code> would have <code>.max = 9</code></td> </tr> <tr> <td><code>.variableLength</code></td> <td><em>boolean flag<br> </em></td> <td>true if the type represents a C99 variable-length array type</td> </tr> </tbody>
</table>
<h3 id="Number_Type" name="Number_Type">Number Type</h3>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.precision</code></td> <td><em>integer<br> </em></td> <td>for floating-point types, the precision of the type</td> </tr> <tr> <td><code>.min</code></td> <td><em>integer<br> </em></td> <td>for integer types, the minimum value capable of being stored</td> </tr> <tr> <td><code>.max</code></td> <td><em>integer<br> </em></td> <td>for integer types, the maximum value capable of being stored</td> </tr> <tr> <td><code>.isSigned</code></td> <td><em>boolean flag<br> </em></td> <td>for integer types, true if the type stores signed values</td> </tr> <tr> <td><code>.isUnsigned</code></td> <td><em>boolean flag<br> </em></td> <td>for integer types, true if the type stores unsigned values</td> </tr> <tr> <td><code>.bitfieldBits</code></td> <td><em>integer<br> </em></td> <td>if the type represents a bitfield, the number of bits used by the bitfield</td> </tr> <tr> <td><code>.bitfieldOf</code></td> <td><em><a href="#Number_Type">number type object</a><br> </em></td> <td>if the type represents a bitfield, the base type of the bitfield.</td> </tr> </tbody>
</table>
<h3 id="Function_Type" name="Function_Type">Function Type</h3>
<p>These represent the types functions and methods in the type system:</p>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code id="function.type">.type</code></td> <td><em>type object<br> </em></td> <td>the function return type.</td> </tr> <tr> <td><code id="function.parameters">.parameters</code></td> <td><em>array of type objects<br> </em></td> <td>the parameter types for the function.</td> </tr> <tr> <td><code>.isExplicit</code></td> <td><em>boolean flag</em></td> <td>true for constructors declared using the C++ explicit keyword</td> </tr> </tbody>
</table>
<h2 id="Template_Objects" name="Template_Objects">Template Objects</h2>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> <td>Description</td> </tr> </thead> <tbody> <tr> <td><code>.name</code></td> <td><em>string<br> </em></td> <td>the name of the template, for example "nsCOMPtr".</td> </tr> <tr> <td><code>.arguments</code></td> <td><em>array<br> </em></td> <td>an array where arguments are either strings representing C++ constants or <a href="#Type_Object">type objects</a>.</td> </tr> </tbody>
</table>
<h2 id="Location_Objects" name="Location_Objects">Location Objects</h2>
<p>Location objects are passed to builtin functions such as <a class="internal" href="/En/Dehydra/Function_Reference#warning" title="En/Dehydra/Function Reference#warning">warning</a>() and <a class="internal" href="/En/Dehydra/Function_Reference#error" title="En/Dehydra/Function Reference#error">error</a>() to specify the location of the message. They convert to a string of the form "file:line:column". They have the following properties:</p>
<table class="standard-table"> <thead> <tr> <td>Property</td> <td>Type</td> </tr> </thead> <tbody> <tr> <td><code>.file</code></td> <td><em>string<br> </em></td> </tr> <tr> <td><code>.line</code></td> <td><em>integer</em></td> </tr> <tr> <td><code>.column</code></td> <td><em>integer (optional)</em></td> </tr> </tbody>
</table>