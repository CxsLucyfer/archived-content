---
title: Content Scripts（内容脚本）
slug: Mozilla/Add-ons/SDK/Guides/Content_Scripts
translation_of: Archive/Add-ons/Add-on_SDK/Guides/Content_Scripts
---
<article id="wikiArticle"><section class="Quick_links" id="Quick_Links">
  <ol>
    <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions"><strong>Browser extensions</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Getting started</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/What_are_WebExtensions">What are extensions?</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Your_first_WebExtension">Your first extension</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Your_second_WebExtension">Your second extension</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Anatomy_of_a_WebExtension">Anatomy of an extension</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Examples">Example extensions</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/What_next_">What next?</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Concepts</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Using_the_JavaScript_APIs">Using the JavaScript APIs</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Content_scripts">Content scripts</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Match_patterns">Match patterns</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Working_with_files">Working with files</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Internationalization">Internationalization</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Security_best_practices">Security best practices</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Content_Security_Policy">Content Security Policy</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Native_messaging">Native messaging</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>User interface</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface">User Interface</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Browser_action">Toolbar button</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Page_actions">Address bar button</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Sidebars">Sidebars</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Context_menu_items">Context menu items</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Options_pages">Options page</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Extension_pages">Extension pages</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Notifications">Notifications</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/Omnibox">Address bar suggestions</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/user_interface/devtools_panels">Developer tools panels</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>How to</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Intercept_HTTP_requests">Intercept HTTP requests</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Modify_a_web_page">Modify a web page</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Safely_inserting_external_content_into_a_page">Insert external content</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Add_a_button_to_the_toolbar">Add a button to the toolbar</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Implement_a_settings_page">Implement a settings page</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Working_with_the_Tabs_API">Work with the Tabs API</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Work_with_the_Bookmarks_API">Work with the Bookmarks API</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Work_with_the_Cookies_API">Work with the Cookies API</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Work_with_contextual_identities">Work with contextual identities</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/onboarding_upboarding_offboarding_best_practices">Onboard, upboard, and offboard users</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Porting</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Firefox_differentiators">Firefox differentiators</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Porting_a_Google_Chrome_extension">Porting a Google Chrome extension</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Porting_a_legacy_Firefox_add-on">Porting a legacy Firefox extension</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Embedded_WebExtensions">Embedded WebExtensions</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Comparison_with_the_Add-on_SDK">Comparison with the Add-on SDK</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Comparison_with_XUL_XPCOM_extensions">Comparison with XUL/XPCOM extensions</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Differences_between_API_implementations">Differences between API implementations</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Chrome_incompatibilities">Chrome incompatibilities</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Differences_between_desktop_and_Android">Differences between desktop and Android</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Firefox workflow</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Development_Tools">Developer tools</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/User_experience_best_practices">User Experience</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Temporary_Installation_in_Firefox">Temporary Installation in Firefox</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Debugging">Debugging</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Testing_persistent_and_restart_features">Testing persistent and restart features</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Developing_WebExtensions_for_Firefox_for_Android">Developing for Firefox for Android</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Getting_started_with_web-ext">Getting started with web-ext</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/web-ext_command_reference">web-ext command reference</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/WebExtensions_and_the_Add-on_ID">Extensions and the Add-on ID</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Request_the_right_permissions">Request the right permissions</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>JavaScript APIs</summary>
        <ol><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Browser_support_for_JavaScript_APIs">Browser support for JavaScript APIs</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/alarms">alarms</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/bookmarks">bookmarks</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/browserAction">browserAction</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/contextMenus">contextMenus</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/cookies">cookies</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/devtools.inspectedWindow">devtools.inspectedWindow</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/history">history</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/runtime">runtime</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/storage">storage</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/tabs">tabs</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/webNavigation">webNavigation</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/webRequest">webRequest</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/windows">windows</a></li></ol>
      </details>
    </li>

    <li class="toggle">
      <details>
      <summary>Manifest keys</summary>
      <ol><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/browser_specific_settings">applications</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/browser_action">browser_action</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/content_scripts">content_scripts</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/default_locale">default_locale</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/developer">developer</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/manifest_version">manifest_version</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/version">version</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/%E4%B8%BB%E9%A1%B5%E5%9C%B0%E5%9D%80">主页地址</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/author">作者 - author</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/name">名称 - name</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/background">后台 - background</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/description">描述 - description</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/permissions">权限 - permissions</a></li><li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/manifest.json/short_name">短名称 - short_name</a></li></ol>
      </details>
    </li>

    <li><a href="/zh-CN/docs/Mozilla/Add-ons/Themes"><strong>Themes</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Browser themes</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Themes/Theme_concepts">Browser theme concepts</a></li>
        </ol>
      </details>
    </li>
    <li><a href="/zh-CN/docs/Mozilla/Add-ons/Distribution"><strong>Publishing and Distribution</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Publishing add-ons</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Distribution">Signing and distribution overview</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Package_your_extension_">Package your extension</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Distribution/Submitting_an_add-on">Submit an add-on</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Source_Code_Submission">Source code submission</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Distribution/Resources_for_publishers">Resources for publishers</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Listing">Creating an appealing listing</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Distribution/Make_money_from_browser_extensions">Make money from browser extensions</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Distribution/Promoting_your_extension_or_theme">Promoting your extension or theme</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/AMO/Policy/Reviews">Review policies</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/AMO/Policy/Agreement">Developer agreement</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/AMO/Policy/Featured">Featured add-ons</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/Distribution/Retiring_your_extension">Retiring your extension</a></li>
        </ol>
      </details>
    </li>
    <li class="toggle">
      <details>
        <summary>Distributing add-ons</summary>
        <ol>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Alternative_distribution_options/Sideloading_add-ons">For sideloading</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Alternative_distribution_options/Add-ons_for_desktop_apps">For desktop apps</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Alternative_distribution_options/Add-ons_in_the_enterprise">For an enterprise</a></li>
        </ol>
      </details>
    </li>
    <li><a href="https://discourse.mozilla.org/c/add-ons"><strong>Community and Support</strong></a></li>
    <li class="toggle">
      <details>
        <summary>Channels</summary>
        <ol>
          <li><a href="https://blog.mozilla.org/addons">Add-ons blog</a></li>
          <li><a href="https://discourse.mozilla.org/c/add-ons">Add-on forums</a></li>
          <li><a href="http://stackoverflow.com/questions/tagged/firefox-addon">Stack Overflow</a></li>
          <li><a href="/zh-CN/docs/Mozilla/Add-ons/#Contact_us">Contact us</a></li>
        </ol>
      </details>
    </li>
  </ol>
</section>
<p><span class="seoSummary">很多 add-ons 需要访问和修改 web 页面的内容。但是 add-on 的主代码不能直接访问 web 内容。替代方案是, SDK add-ons 需要使用一些分散的脚本代理访问 web 内容，这些脚本被称作<em>内容脚本（content scripts）</em>。本页面描述如何开发和部署内容脚本。 </span></p>

<p>内容脚本是在使用SDK时很令人疑惑的点，但你很有可能不得不使用它们。下面有五个基本原则：</p>

<ul>
 <li>add-on 的主代码，包括&quot;main.js&quot;和其他&quot;lib&quot;下的模块，可以使用 SDK <a href="/zh-CN/docs/Mozilla/Add-ons/SDK/High-Level_APIs">高层次</a>和<a href="/zh-CN/docs/Mozilla/Add-ons/SDK/Low-Level_APIs">低层次</a> APIs，但不能直接访问 web 内容</li>
 <li>内容脚本 <a href="/en-US/Add-ons/SDK/Guides/Two_Types_of_Scripts#API_Access_for_Add-on_Code_and_Content_Scripts">不能使用 SDK 的 API</a>（访问不了 globals 的 <code>exports</code>、<code>require</code>），但你可以访问 web 内容</li>
 <li>SDK API 可以使用，内容脚本，比如 <a href="/en-US/Add-ons/SDK/High-Level_APIs/page-mod">page-mod</a> 和 <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs">tabs</a>，提供了一些函数，使得 add-on 的主代码可以将内容脚本载入web页面中。</li>
 <li>内容脚本可以作为字符串加载，但是更常见的是分离存储为 add-on 的&quot;data&quot;目录下文件。 jpm 不会默认创建&quot;data&quot;目录，所以你必须添加该目录并把脚本放进去。</li>
 <li>一个消息传递 API 允许主代码和内容脚本间相互通信。</li>
</ul>

<p>这个完整的 add-on 表现出所有的这些原则。它的&quot;main.js&quot;使用 <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs">tabs</a> 模块附加了一个内容脚本到当前标签页。本例中内容脚本作为字符串传递，内容脚本简单地替换了页面的内容：</p>

<pre class="brush: js">// main.js
var tabs = require(&quot;sdk/tabs&quot;);
var contentScriptString = &apos;document.body.innerHTML = &quot;&lt;h1&gt;this page has been eaten&lt;/h1&gt;&quot;;&apos;

tabs.activeTab.attach({
  contentScript: contentScriptString
});</pre>

<p>下面的高层次 SDK 模块能使用内容脚本来修改 web 页面：</p>

<ul>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/page-mod">page-mod</a>：使你能附加一个内容脚本到匹配上特定 URL 模式的web页面。</li>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs">tabs</a>：导出一个 <code>Tab</code> 对象来处理浏览器标签页。<code>Tab</code> 对象包括了一个 <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs#attach(options)"><code>attach()</code></a> 函数来附加内容脚本到标签页。</li>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/page-worker">page-worker</a>：让你能够恢复一个 web 页面，但不显示它。你可以附加内容脚本到该页面，来访问和操作该页面的 DOM。</li>
 <li><a href="/en-US/Add-ons/SDK/High-Level_APIs/context-menu">context-menu</a>：使用内容脚本来和按钮所在的页面交互。</li>
</ul>

<p>另外，还能使用 HTML 定义了一些 SDK 用户接口组件，并且使用分类的脚本来和这些内容交互。从很多方面来讲，这些脚本就像内容脚本一样，但它们并不是本文的关注点。要学习如何和用户接口模块的内容交互，请参看模块定义文档：<a href="/en-US/Add-ons/SDK/High-Level_APIs/panel">panel</a>、<a href="/en-US/Add-ons/SDK/Low-Level_APIs/ui_sidebar">sidebar</a>、<a href="/en-US/Add-ons/SDK/Low-Level_APIs/ui_frame">frame</a>。</p>

<p>这篇指南中列出的几乎所有的示例都是完整并且且最小的，可以在 Github 的 <a href="https://github.com/mdn/addon-sdk-content-scripts">addon-sdk-content-scripts repository</a> 页面上获得。</p>

<h2 id="加载用户脚本">加载用户脚本</h2>

<article id="wikiArticle">
<p>你可以声明一个字符串或者指定 <code>contentScript</code> 或 <code>contentScriptFile</code> 选项加载一个单独的脚本。<code>contentScript</code> 选项接受一个作为脚本的字符串：</p>

<pre class="brush: js">// main.js

var pageMod = require(&quot;sdk/page-mod&quot;);
var contentScriptValue = &apos;document.body.innerHTML = &apos; +
                         &apos; &quot;&lt;h1&gt;Page matches ruleset&lt;/h1&gt;&quot;;&apos;;

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScript: contentScriptValue
});</pre>

<p><code>contentScriptFile</code> 选项接受一个作为 resource:// URL 的字符串，指向一个存储在你的 add-on 的 <code>data</code> 目录中的脚本文件。jpm不会默认创建&quot;data&quot;目录，所以你必须创建该目录并将你的用户脚本放进去。</p>

<p>本 add-on 提供一个 URL ，指向&quot;content-script.js&quot;文件，存储在 add-on 根目录下的 <code>data</code> 子目录：</p>

<pre class="brush: js">// main.js

var data = require(&quot;sdk/self&quot;).data;
var pageMod = require(&quot;sdk/page-mod&quot;);

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScriptFile: data.url(&quot;content-script.js&quot;)
});</pre>

<pre class="brush: js">// content-script.js

document.body.innerHTML = &quot;&lt;h1&gt;Page matches ruleset&lt;/h1&gt;&quot;;</pre>

<div class="note notecard">
<p>从 Firefox 34 开始，你可以使用&quot;./content-script.js&quot;替代 self.data.url(&quot;content-script.js&quot;)。所以你可以像这样重写：</p>

<pre class="brush: js">var pageMod = require(&quot;sdk/page-mod&quot;);

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScriptFile: &quot;./content-script.js&quot;
});
</pre>
</div>

<div class="warning notecard">
<p>除非你的内容脚本非常简单并且固定是一个静态的字符串，请不要使用 <code>contentScript</code>：否则，你会在从 AMO 获取你的add-on上遇到问题。</p>

<p>相反，把脚本放到一个单独的文件并用 <code>contentScriptFile</code> 加载它。这回事你的代码更易维护、安全、调试和审核。</p>
</div>

<p>你可以给 <code>contentScript</code> 或 <code>contentScriptFile</code> 传递字符串数组来加载多个脚本：</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);

tabs.on(&apos;ready&apos;, function(tab) {
  tab.attach({
      contentScript: [&apos;document.body.style.border = &quot;5px solid red&quot;;&apos;, &apos;window.alert(&quot;hi&quot;);&apos;]
  });
});
</pre>

<pre class="brush: js">// main.js

var data = require(&quot;sdk/self&quot;).data;
var pageMod = require(&quot;sdk/page-mod&quot;);

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScriptFile: [data.url(&quot;jquery.min.js&quot;), data.url(&quot;my-content-script.js&quot;)]
});</pre>

<p>如果你这么做，这些脚本之间可以直接交互，就像他们被同一个 web 页面加载一样。</p>

<p>你也可以把 <code>contentScript</code> 和 <code>contentScriptFile</code> 一起用。如果你这么做，使用 <code>contentScriptFile</code> 定义的脚本会在使用 <code>contentScript</code> 定义的脚本之前加载。这使你能够用 URL 加载比如 jQuery 这样的 JavaScript 库，然后传递一个简单的能够使用jQuery脚本：</p>

<pre class="brush: js">// main.js

var data = require(&quot;sdk/self&quot;).data;
var pageMod = require(&quot;sdk/page-mod&quot;);

var contentScriptString = &apos;$(&quot;body&quot;).html(&quot;&lt;h1&gt;Page matches ruleset&lt;/h1&gt;&quot;);&apos;;

pageMod.PageMod({
  include: &quot;*.mozilla.org&quot;,
  contentScript: contentScriptString,
  contentScriptFile: data.url(&quot;jquery.js&quot;)
});</pre>

<div class="warning notecard">
<p>除非你的内容脚本非常简单并且固定是一个静态的字符串，请不要使用 <code>contentScript</code>：否则，在从 AMO 获取你的 add-on 上，你会遇到问题。</p>

<p>相反，把脚本放到一个单独的文件并用 <code>contentScriptFile</code> 加载它。这回事你的代码更易维护、安全、调试和审核。</p>
</div>

<h3 id="控制附加脚本的时间">控制附加脚本的时间</h3>

<p><code>contentScriptWhen</code> 选项指定了什么时候加载内容脚本。从这里选一个：</p>

<ul>
 <li><code>&quot;start&quot;</code>：页面 document 元素插入 DOM 之后，立即加载脚本。这时 DOM 的内容仍未加载，所以脚本不能与其交互。</li>
 <li><code>&quot;ready&quot;</code>：页面 DOM 加载完后加载脚本：也就是说，在那个时间点 <a href="https://developer.mozilla.org/en/Gecko-Specific_DOM_Events">DOMContentLoaded</a> 事件触发。这时，内容脚本可以和DOM内容交互，但外部引用的样式表和图片可能还没有完成加载。</li>
 <li><code>&quot;end&quot;</code>：页面上所有内容（DOM、JS、CSS、images）加载完后，加载脚本，就是在 <a href="https://developer.mozilla.org/en/DOM/window.onload">window.onload 事件</a>触发的时候</li>
</ul>

<p>默认值为 <code>&quot;end&quot;</code>。</p>

<p>注意 <a href="/en-US/Add-ons/SDK/High-Level_APIs/tabs#attach(options)"><code>tab.attach()</code></a> 不支持 contentScriptWhen，因为它原来就是在页面加载页面的时候被调用的。</p>

<h3 id="传递配置选项">传递配置选项</h3>

<p><code>contentScriptOptions</code> 是一个作为只读对象暴露给内容脚本的JSON对象，在 <code><a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/self">self</a>.options</code> 的属性里:</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);

tabs.on(&apos;ready&apos;, function(tab) {
  tab.attach({
      contentScript: &apos;window.alert(self.options.message);&apos;,
      contentScriptOptions: {&quot;message&quot; : &quot;hello world&quot;}
  });
});</pre>

<p>这里可以使用任何可以转成json的值（object、array、string等等）。</p>

<h2 id="访问_DOM">访问 DOM</h2>

<p>内容脚本可以访问页面的 DOM，就像任何页面中加载的脚本（页面脚本）一样。但是内容脚本和页面脚本之间是隔离的：</p>

<ul>
 <li>内容脚本不能看到任何由页面脚本添加到页面的 JavaScript 对象</li>
 <li>如果页面脚本重定义了某个 DOM 对象的行为，但内容脚本只会看到原来的那个行为。</li>
</ul>

<p>相反也是如此：页面脚本不能看到内容脚本添加的 JavaScript 对象。</p>

<p>例如，假想一个页面用页面脚本添加变量 <code>foo</code> 到 <code>window</code> 对象：</p>

<pre class="brush: html">&lt;!DOCTYPE html&quot;&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
    window.foo = &quot;hello from page script&quot;
    &lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;</pre>

<p>在这个脚本后面加载到页面的其他脚本也可以访问 <code>foo</code>。但是内容脚本不能：</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);
var mod = require(&quot;sdk/page-mod&quot;);
var self = require(&quot;sdk/self&quot;);

var pageUrl = self.data.url(&quot;page.html&quot;)

var pageMod = mod.PageMod({
  include: pageUrl,
  contentScript: &quot;console.log(window.foo);&quot;
})

tabs.open(pageUrl);</pre>

<pre>console.log: my-addon: null
</pre>

<p>这种隔离策略有着很合理的理由。首先，这意味着内容脚本不会泄露对象给 web 页面，这样可能会打开安全漏洞。第二，这意味着，在内容脚本创建对象的时候，可以不用担心是否会和页面脚本添加的对象相冲突。</p>

<p>这种隔离意味着，例如，如果一个 web 页面加载了 jQuery 库，那么内容脚本不能够看到由该库添加的 <code>jQuery</code> 对象——但是可以看到内容脚本添加的自己的 <code>jQuery</code> 对象，并且它不会和页面脚本的 jQuery 版本冲突。</p>

<h3 id="和页面脚本交互">和页面脚本交互</h3>

<p>一般来说，这种内容脚本和页面脚本的隔离正是你所希望的。但是有时候你也许会希望和页面脚本交互：你想在内容脚本和页面脚本之间共享对象来，来在它们之间发送消息。如果你需要这么做，请阅读<a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/Interacting_with_page_scripts">和页面脚本交互</a>。</p>

<h3 id="事件监听器">事件监听器</h3>

<p>你可以监听 DOM 的事件，就像在页面脚本中一样，但是有两个重要的区别：</p>

<p>第一，如果你向 <a href="https://developer.mozilla.org/en/DOM/element.setAttribute"><code>setAttribute()</code></a> 传递字符串，来定义了事件监听器，那么此监听器被当做是在页面上下文中的，所以它不能访问任何内容脚本中的变量。</p>

<p>如下，内容脚本会失败报错&quot;theMessage is not defined&quot;：</p>

<pre class="brush: js">var theMessage = &quot;Hello from content script!&quot;;
anElement.setAttribute(&quot;onclick&quot;, &quot;alert(theMessage);&quot;);</pre>

<p>Second, if you define an event listener by direct assignment to a <a href="/en-US/docs/Web/API/GlobalEventHandlers">global event handler</a> like <code>onclick</code>, then the assignment might be overridden by the page. For example, here&apos;s an add-on that tries to add a click handler by assignment to <code>window.onclick</code>:</p>

<pre class="brush: js">var myScript = &quot;window.onclick = function() {&quot; +
               &quot;  console.log(&apos;unsafewindow.onclick: &apos; + window.document.title);&quot; +
               &quot;}&quot;;

require(&quot;sdk/page-mod&quot;).PageMod({
  include: &quot;*&quot;,
  contentScript: myScript,
  contentScriptWhen: &quot;start&quot;
});</pre>

<p>这个示例会在大多数页面上正常工作，但是会在定义 <code>onclick</code> 的页面上失败：</p>

<pre class="brush: html">&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
    window.onclick = function() {
      window.alert(&quot;it&apos;s my click now!&quot;);
    }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<p>由于这些原因，最好还是用 <a href="https://developer.mozilla.org/en/DOM/element.addEventListener"><code>addEventListener()</code> 添加一个事件监听器</a>，定义监听器为一个函数：</p>

<pre class="brush: js">var theMessage = &quot;Hello from content script!&quot;;

anElement.onclick = function() {
  alert(theMessage);
};

anotherElement.addEventListener(&quot;click&quot;, function() {
  alert(theMessage);
});</pre>

<h2 id="和_add-on_通信">和 add-on 通信</h2>

<p>为了使 add-on 脚本和内容脚本相互通信，任何一通信端都要访问 <code>port</code> 对象。</p>

<ul>
 <li>要从一头发送消息到另一头，使用 <code>port.emit()</code></li>
 <li>要从另一头接收消息，使用 <code>port.on()</code></li>
</ul>

<p><img src="https://mdn.mozillademos.org/files/7873/content-scripting-overview.png" alt style="display: block; margin-left: auto; margin-right: auto;">消息是异步的：也就是说，发送方不会等待接收方的回应，而仅仅是发送消息完后继续处理别的事情。</p>

<p>这里有一个简单的 add-on 使用 <code>port</code> 发送一个消息到内容脚本：</p>

<pre class="brush: js">// main.js

var tabs = require(&quot;sdk/tabs&quot;);
var self = require(&quot;sdk/self&quot;);

tabs.on(&quot;ready&quot;, function(tab) {
  var worker = tab.attach({
    contentScriptFile: self.data.url(&quot;content-script.js&quot;)
  });
  worker.port.emit(&quot;alert&quot;, &quot;Message from the add-on&quot;);
});

tabs.open(&quot;http://www.mozilla.org&quot;);</pre>

<pre class="brush: js">// content-script.js

self.port.on(&quot;alert&quot;, function(message) {
  window.alert(message);
});</pre>

<div class="note notecard">
<p>context-menu 模块没有使用这里描述的通信模型。了解更多关于使用 context-menu 和内容脚本通信的事情，参看 <a href="/en-US/Add-ons/SDK/High-Level_APIs/context-menu">context-menu documentation</a>。</p>
</div>

<h3 id="在内容脚本中访问_port"><code>在内容脚本中访问 port</code></h3>

<p>内容脚本中，<code>port</code> 对象是作为global下 <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/self"><code>self</code></a> 对象的属性。所以要从内容脚本中发送消息的话：</p>

<pre class="brush: js">self.port.emit(&quot;myContentScriptMessage&quot;, myContentScriptMessagePayload);</pre>

<p>要从 add-on 代码接收消息</p>

<pre class="brush: js">self.port.on(&quot;myAddonMessage&quot;, function(myAddonMessagePayload) {
  // Handle the message
});</pre>

<div class="note notecard">
<p>注意 global下 <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/self"><code>self</code></a> 对象和 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/self"><code>self</code> 模块</a>完全不一样，后者提供一个API给 add-on，用来访问它的数据文件和ID。</p>
</div>

<h3 id="在内容脚本中访问_port_2">在内容脚本中访问 port</h3>

<p>在 add-on 代码中，联通 add-on 和某一特定内容脚本上下文的通道被封装入 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/content_worker"><code>worker</code></a> 对象。所以和内容脚本通信的 <code>port</code> 对象其实是其相对应的 <code>worker</code> 对象的一个属性。</p>

<p>但是，这个 worker 没有暴露给 add-on 代码，以及同样所有的模块。</p>

<h4 id="从_page-worker">从 <code>page-worker</code></h4>

<p><code>page-worker</code> 对象直接整合了 work API。所以要从一个由 <code>page-worker</code> 关联的内容脚本接收消息的话，你可以使用 <code>pageWorker.port.on()</code>：</p>

<pre class="brush: js">// main.js

var self = require(&quot;sdk/self&quot;);

var pageWorker = require(&quot;sdk/page-worker&quot;).Page({
  contentScriptFile: self.data.url(&quot;content-script.js&quot;),
  contentURL: &quot;http://en.wikipedia.org/wiki/Internet&quot;
});

pageWorker.port.on(&quot;first-para&quot;, function(firstPara) {
  console.log(firstPara);
});</pre>

<p>要从你的 add-on 发送用户定义的消息，你可以只调用 <code>pageWorker.port.emit()</code>：</p>

<pre class="brush: js">// main.js

var self = require(&quot;sdk/self&quot;);

var pageWorker = require(&quot;sdk/page-worker&quot;).Page({
  contentScriptFile: self.data.url(&quot;content-script.js&quot;),
  contentURL: &quot;http://en.wikipedia.org/wiki/Internet&quot;
});

pageWorker.port.on(&quot;first-para&quot;, function(firstPara) {
  console.log(firstPara);
});

pageWorker.port.emit(&quot;get-first-para&quot;);</pre>

<pre class="brush: js">// content-script.js

self.port.on(&quot;get-first-para&quot;, getFirstPara);

function getFirstPara() {
  var paras = document.getElementsByTagName(&quot;p&quot;);
  if (paras.length &gt; 0) {
    var firstPara = paras[0].textContent;
    self.port.emit(&quot;first-para&quot;, firstPara);
  }
}</pre>

<h4 id="从_page-mod">从<code> page-mod</code></h4>

<p>单个 <code>page-mod</code> 对象可以附加它的脚本到多个页面，每个页面有它自己的上下文来运行内容脚本，所以每个页面都需要相互隔离的通道（worker）。</p>

<p>所以 <code>page-mod</code> 没有直接整合 worker 的 API。而是在每次内容脚本被附加到页面时，page-mod 发送一个 <code>attach</code> 事件，它的监听器会给对应的上下文传递一个 worker。通过为 <code>attach</code> 提供一个监听器，你可以访问被一个 page-mod 附加到页面上的内容脚本的 <code>port</code> 对象：</p>

<pre class="brush: js">// main.js

var pageMods = require(&quot;sdk/page-mod&quot;);
var self = require(&quot;sdk/self&quot;);

var pageMod = pageMods.PageMod({
  include: [&apos;*&apos;],
  contentScriptFile: self.data.url(&quot;content-script.js&quot;),
  onAttach: startListening
});

function startListening(worker) {
  worker.port.on(&apos;click&apos;, function(html) {
    worker.port.emit(&apos;warning&apos;, &apos;Do not click this again&apos;);
  });
}</pre>

<pre class="brush: js">// content-script.js

window.addEventListener(&apos;click&apos;, function(event) {
  self.port.emit(&apos;click&apos;, event.target.toString());
  event.stopPropagation();
  event.preventDefault();
}, false);

self.port.on(&apos;warning&apos;, function(message) {
  window.alert(message);
});
</pre>

<p>上面的 add-on 里有两条消息：</p>

<ul>
 <li>当用户点击页面元素时，<code>click</code> 从 page-mod 被发送到当前 add-on。</li>
 <li><code>warning</code> 发送一条傻气的字符串回给page-mod</li>
</ul>

<h4 id="从_Tab.attach()">从 <code>Tab.attach()</code></h4>

<p><code>Tab.attach()</code> 方法返回一个 worker，你可以用来和附加的内容脚本通信。</p>

<p>这个 add-on 添加了一个按钮到Firefox：等用户点击按钮是，这个 add-on 附加一个内容脚本到当前的标签页，发送给内容脚本一条名为 &quot;my-addon-message&quot;的消息，并且监听名为&quot;my-script-response&quot;的响应：</p>

<pre class="brush: js">//main.js

var tabs = require(&quot;sdk/tabs&quot;);
var buttons = require(&quot;sdk/ui/button/action&quot;);
var self = require(&quot;sdk/self&quot;);

buttons.ActionButton({
  id: &quot;attach-script&quot;,
  label: &quot;Attach the script&quot;,
  icon: &quot;./icon-16.png&quot;,
  onClick: attachScript
});

function attachScript() {
  var worker = tabs.activeTab.attach({
    contentScriptFile: self.data.url(&quot;content-script.js&quot;)
  });
  worker.port.on(&quot;my-script-response&quot;, function(response) {
    console.log(response);
  });
  worker.port.emit(&quot;my-addon-message&quot;, &quot;Message from the add-on&quot;);
}
</pre>

<pre class="brush: js">// content-script.js

self.port.on(&quot;my-addon-message&quot;, handleMessage);

function handleMessage(message) {
  alert(message);
  self.port.emit(&quot;my-script-response&quot;, &quot;Response from content script&quot;);
}</pre>

<h3 id="port的API">port的API</h3>

<p>参看 <a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/port"><code>port</code> 对象的参考文档</a>.</p>
</article>

<h3 id="postMessage的API">postMessage的API</h3>

<p>在 <code>port</code> 对象加载之前，add-on 代码和内容脚本可以使用另一个 API 通信：</p>

<ul>
 <li>内容脚本调用 <code>self.postMessage()</code> 来发送，并用 <code>self.on()</code> 来接收</li>
 <li>内容脚本调用 <code>worker.postMessage()</code> 来发送，并用 <code>worker.on()</code> 来接收</li>
</ul>

<p>这个API依然可用，并且还有<a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/using_postMessage">文档</a>，但是没有理由替代前文描述的 <code>port</code> API。 例外是 <a href="/en-US/Add-ons/SDK/High-Level_APIs/context-menu">context-menu</a> 模块，它还是使用 postMessage。</p>

<h3 id="内容脚本的内容脚本">内容脚本的内容脚本</h3>

<p>内容脚本可用直接和其他同一个上下文中的内容脚本通信。举个例子，如果一次 <code>Tab.attach()</code> 的调用附加了两个脚本，那么他们可用直接相互查看，就像加载在同一页面内的页面脚本一样。但是如果你调用 <code>Tab.attach()</code> 两次，每次附加一个内容脚本，那么这些内容脚本之间不能通信。你必须使用port API 通过 add-on 的主代码来传递消息。</p>

<h2 id="跨域的内容脚本">跨域的内容脚本</h2>

<p>默认情况下，内容脚本没有跨域的权限。特别是，它们不能访问在不同 <code>iframe</code> 中的在另外的域名上的内容，也不能发起跨域的 XMLHttpRequests。</p>

<p>但是，你可以把需要的域名添加到 <a href="/en-US/Add-ons/SDK/Tools/package_json">package.json</a> 中<code>&quot;permissions&quot;</code>键下的 <code>&quot;cross-domain-content&quot;</code>键下，为这些域名打开这些特性。参阅文章<a href="/en-US/Add-ons/SDK/Guides/Content_Scripts/Cross_Domain_Content_Scripts">跨域内容脚本</a>。</p>
</article>

<div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"> </div>

<div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd"> </div>
